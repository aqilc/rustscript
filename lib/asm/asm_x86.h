/*
 * asm_x86.h v1.0.0 - Aqil Contractor @AqilC 2023
 * Licenced under Attribution-NonCommercial-ShareAlike 3.0
 *
 * This file includes all of the source for the "chasm" library macros and functions.
 * WARNING: CURRENTLY NOT FULLY THREAD SAFE. Use with caution when using in thread safe code!
 */

#pragma once
#include <stdbool.h>
#include <stdint.h>

enum x64OperandType: uint64_t {
	NONE = 0, //for an operand constructed without a type

	HINT = 0x1,

	// IMMEDIATES
	IMM8 = 0x2, IMM16 = 0x4, IMM32 = 0x8, IMM64 = 0x10,
	
	LABEL = 0x20,

	M8 = 0x40, M16 = 0x80, M32 = 0x100, M64 = 0x200, M128 = 0x400, M256 = 0x800, M512 = 0x1000,
	M80 = 0x2000,
	// M16INT = 0x2000, M32INT = 0x4000, M64INT = 0x8000, M32FP = 0x10000, M64FP = 0x20000,
	// M80FP = 0x40000, M80BCD = 0x80000, M2BYTE = 0x100000, M28BYTE = 0x200000,
	// M108BYTE = 0x400000, M512BYTE = 0x800000,
	FARPTR1616 = 0x1000000, FARPTR1632 = 0x2000000, FARPTR1664 = 0x4000000,
	
	MM = 0x8000000,

	PREF66 = 0x10000000,
	PREFREX_W = 0x20000000,
	FAR = 0x40000000,

	MOFFS8 = 0x80000000, MOFFS16 = 0x100000000, MOFFS32 = 0x200000000, MOFFS64 = 0x400000000,

	R8 = 0x800000000, RH = 0x1000000000, AL = 0x2000000000, CL = 0x4000000000,
	R16 = 0x8000000000, AX = 0x10000000000, DX = 0x20000000000,
	R32 = 0x40000000000, EAX = 0x80000000000,
	R64 = 0x100000000000, RAX = 0x200000000000,

	REL8 = 0x400000000000,
	REL32 = 0x800000000000,

	SREG = 0x1000000000000, FS = 0x2000000000000, GS = 0x4000000000000,

	ST = 0x8000000000000, ST_0 = 0x10000000000000,

	XMM = 0x20000000000000, XMM_0 = 0x40000000000000,
	YMM = 0x80000000000000,
	ZMM = 0x100000000000000,
	
	CR0_7 = 0x200000000000000, CR8 = 0x400000000000000,
	DREG = 0x800000000000000,
	
	ONE = 0x1000000000000000 // EXACTLY ENOUGH TO FIT IN A 64-BIT INTEGER LETS FUCKING GO
	// 2 bytes + 2 bits for extra things that can't fit in `value`, like segment registers ðŸ˜ˆ
};
typedef enum x64OperandType x64OperandType;

// enum x64OperandSize { SIZE_BYTE = 1, SIZE_WORD, SIZE_DWORD, SIZE_QUAD };
// typedef enum x64OperandSize x64OperandSize;

enum x64Op {
	END_ASM, ADC, ADD, ADDPD, ADDPS, ADDSD, ADDSS, ADDSUBPD, ADDSUBPS, AESDEC, AESDECLAST, AESENC, AESENCLAST, AESIMC, AESKEYGENASSIST, AND, ANDPD, ANDPS, ANDNPD, ANDNPS, BLENDPD, BLENDPS, BLENDVPD, BLENDVPS, BSF, BSR, BSWAP, BT, BTC, BTR, BTS, CALL, CBW, CWDE, CDQE, CLC, CLD, CLFLUSH, CLI, CLTS, CMC, CMOVA, CMOVAE, CMOVB, CMOVBE, CMOVC, CMOVE, CMOVG, CMOVGE, CMOVL, CMOVLE, CMOVNA, CMOVNAE, CMOVNB, CMOVNBE, CMOVNC, CMOVNE, CMOVNG, CMOVNGE, CMOVNL, CMOVNLE, CMOVNO, CMOVNP, CMOVNS, CMOVNZ, CMOVO, CMOVP, CMOVPE, CMOVPO, CMOVS, CMOVZ, CMP, CMPPD, CMPPS, CMPS, CMPSB, CMPSW, CMPSD, CMPSQ, CMPSS, CMPXCHG, CMPXCHG8B, CMPXCHG16B, COMISD, COMISS, CPUID, CRC32, CVTDQ2PD, CVTDQ2PS, CVTPD2DQ, CVTPD2PI, CVTPD2PS, CVTPI2PD, CVTPI2PS, CVTPS2DQ, CVTPS2PD, CVTPS2PI, CVTSD2SI, CVTSD2SS, CVTSI2SD, CVTSI2SS, CVTSS2SD, CVTSS2SI, CVTTPD2DQ, CVTTPD2PI, CVTTPS2DQ, CVTTPS2PI, CVTTSD2SI, CVTTSS2SI, CWD, CDQ, CQO, DEC, DIV, DIVPD, DIVPS, DIVSD, DIVSS, DPPD, DPPS, EMMS, ENTER, EXTRACTPS, F2XM1, FABS, FADD, FADDP, FIADD, FBLD, FBSTP, FCHS, FCLEX, FNCLEX, FCMOVB, FCMOVE, FCMOVBE, FCMOVU, FCMOVNB, FCMOVNE, FCMOVNBE, FCMOVNU, FCOM, FCOMP, FCOMPP, FCOMI, FCOMIP, FUCOMI, FUCOMIP, FCOS, FDECSTP, FDIV, FDIVP, FIDIV, FDIVR, FDIVRP, FIDIVR, FFREE, FICOM, FICOMP, FILD, FINCSTP, FINIT, FNINIT, FIST, FISTP, FISTTP, FLD, FLD1, FLDL2T, FLDL2E, FLDPI, FLDLG2, FLDLN2, FLDZ, FLDCW, FLDENV, FMUL, FMULP, FIMUL, FNOP, FPATAN, FPREM, FPREM1, FPTAN, FRNDINT, FRSTOR, FSAVE, FNSAVE, FSCALE, FSIN, FSINCOS, FSQRT, FST, FSTP, FSTCW, FNSTCW, FSTENV, FNSTENV, FSTSW, FNSTSW, FSUB, FSUBP, FISUB, FSUBR, FSUBRP, FISUBR, FTST, FUCOM, FUCOMP, FUCOMPP, FXAM, FXCH, FXRSTOR, FXRSTOR64, FXSAVE, FXSAVE64, FXTRACT, FYL2X, FYL2XP1, HADDPD, HADDPS, HLT, HSUBPD, HSUBPS, IDIV, IMUL, IN, INC, INS, INSB, INSW, INSD, INSERTPS, INT3, INT1, INT, INVD, INVLPG, INVPCID, IRET, IRETD, IRETQ, JA, JAE, JB, JBE, JC, JECXZ, JRCXZ, JE, JG, JGE, JL, JLE, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG, JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, JMP, LAHF, LAR, LDDQU, LDMXCSR, LSS, LFS, LGS, LEA, LEAVE, LFENCE, LGDT, LIDT, LLDT, LMSW, LOCK, LODS, LODSB, LODSW, LODSD, LODSQ, LOOP, LOOPE, LOOPNE, LSL, LTR, LZCNT, MASKMOVDQU, MASKMOVQ, MAXPD, MAXPS, MAXSD, MAXSS, MFENCE, MINPD, MINPS, MINSD, MINSS, MONITOR, MOV, MOVAPD, MOVAPS, MOVBE, MOVD, MOVQ, MOVDDUP, MOVDQA, MOVDQU, MOVDQ2Q, MOVHLPS, MOVHPD, MOVHPS, MOVLHPS, MOVLPD, MOVLPS, MOVMSKPD, MOVMSKPS, MOVNTDQA, MOVNTDQ, MOVNTI, MOVNTPD, MOVNTPS, MOVNTQ, MOVQ2DQ, MOVS, MOVSB, MOVSW, MOVSD, MOVSQ, MOVSHDUP, MOVSLDUP, MOVSS, MOVSX, MOVSXD, MOVUPD, MOVUPS, MOVZX, MPSADBW, MUL, MULPD, MULPS, MULSD, MULSS, MWAIT, NEG, NOP, NOT, OR, ORPD, ORPS, OUT, OUTS, OUTSB, OUTSW, OUTSD, PABSB, PABSW, PABSD, PACKSSWB, PACKSSDW, PACKUSDW, PACKUSWB, PADDB, PADDW, PADDD, PADDQ, PADDSB, PADDSW, PADDUSB, PADDUSW, PALIGNR, PAND, PANDN, PAUSE, PAVGB, PAVGW, PBLENDVB, PBLENDW, PCLMULQDQ, PCMPEQB, PCMPEQW, PCMPEQD, PCMPEQQ, PCMPESTRI, PCMPESTRM, PCMPGTB, PCMPGTW, PCMPGTD, PCMPGTQ, PCMPISTRI, PCMPISTRM, PEXTRB, PEXTRD, PEXTRQ, PEXTRW, PHADDW, PHADDD, PHADDSW, PHMINPOSUW, PHSUBW, PHSUBD, PHSUBSW, PINSRB, PINSRD, PINSRW, PMADDUBSW, PMADDWD, PMAXSB, PMAXSD, PMAXSW, PMAXUB, PMAXUD, PMAXUW, PMINSB, PMINSD, PMINSW, PMINUB, PMINUD, PMINUW, PMOVMSKB, PMOVSXBW, PMOVSXBD, PMOVSXBQ, PMOVSXWD, PMOVSXWQ, PMOVSXDQ, PMOVZXBW, PMOVZXBD, PMOVZXBQ, PMOVZXWD, PMOVZXWQ, PMOVZXDQ, PMULDQ, PMULHRSW, PMULHUW, PMULHW, PMULLD, PMULLW, PMULUDQ, POP, POPCNT, POPF, POPFQ, POR, PREFETCHT0, PREFETCHT1, PREFETCHT2, PREFETCHNTA, PSADBW, PSHUFB, PSHUFD, PSHUFHW, PSHUFLW, PSHUFW, PSIGNB, PSIGNW, PSIGND, PSLLDQ, PSLLW, PSLLD, PSLLQ, PSRAW, PSRAD, PSRLDQ, PSRLW, PSRLD, PSRLQ, PSUBB, PSUBW, PSUBD, PSUBQ, PSUBSB, PSUBSW, PSUBUSB, PSUBUSW, PTEST, PUNPCKHBW, PUNPCKHWD, PUNPCKHDQ, PUNPCKHQDQ, PUNPCKLBW, PUNPCKLWD, PUNPCKLDQ, PUNPCKLQDQ, PUSH, PUSHQ, PUSHW, PUSHF, PUSHFQ, PXOR, RCL, RCR, ROL, ROR, RCPPS, RCPSS, RDFSBASE, RDGSBASE, RDMSR, RDPMC, RDRAND, RDTSC, RDTSCP, REP_INS, REP_MOVS, REP_OUTS, REP_LODS, REP_STOS, REPE_CMPS, REPE_SCAS, REPNE_CMPS, REPNE_SCAS, RET, ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS, RSQRTPS, RSQRTSS, SAHF, SAL, SAR, SHL, SHR, SBB, SCAS, SCASB, SCASW, SCASD, SCASQ, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE, SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE, SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SFENCE, SGDT, SHLD, SHRD, SHUFPD, SHUFPS, SIDT, SLDT, SMSW, SQRTPD, SQRTPS, SQRTSD, SQRTSS, STC, STD, STI, STMXCSR, STOS, STOSB, STOSW, STOSD, STOSQ, STR, SUB, SUBPD, SUBPS, SUBSD, SUBSS, SWAPGS, SYSCALL, SYSENTER, SYSEXIT, SYSRET, TEST, TZCNT, UCOMISD, UCOMISS, UD2, UNPCKHPD, UNPCKHPS, UNPCKLPD, UNPCKLPS, VERR, VERW, WAIT, FWAIT, WBINVD, WRFSBASE, WRGSBASE, WRMSR, XACQUIRE, XRELEASE, XABORT, XADD, XBEGIN, XCHG, XEND, XGETBV, XLAT, XLATB, XOR, XORPD, XORPS, XRSTOR, XRSTOR64, XSAVE, XSAVE64, XSAVEOPT, XSAVEOPT64, XSETBV, XTEST, LABEL_DEF
};
typedef enum x64Op x64Op;

union x64Operand {
	struct {
		x64OperandType type;
		int64_t value;
	};
};
typedef union x64Operand x64Operand;

struct x64Ins {
	x64Op op;
	x64Operand params[4];
};
typedef struct x64Ins x64Ins;
typedef x64Ins x64[];

struct x64LookupGeneralIns {
	char* name;
	unsigned int numactualins;
	struct x64LookupActualIns {
		char* orig_ins;
		char* orig_opcode;
		char* desc;
		uint8_t mem_operand; // Index of memory operand if there is one + 1
		uint8_t reg_operand; // Index of register operand if there is one + 1
		uint8_t rel_operand; // Index of relative jump operand if there is one + 1
		bool vexxopevex;
		uint32_t prefixes;
		uint8_t rex;
		uint8_t opcode[4];
		uint8_t oplen;
		bool modrmreq;
		bool modrmreg;
    uint8_t modrm;
		uint8_t displacement;
    uint8_t immediate;
		x64OperandType args[4];
		uint32_t arglen;
		bool preffered;
	}* ins;
};
typedef struct x64LookupActualIns x64LookupActualIns;
typedef struct x64LookupGeneralIns x64LookupGeneralIns;

// static const x64LookupActualIns x64ActualTable[] = {

static const x64LookupGeneralIns x64Table[] = {
	{ "adc", 38, (struct x64LookupActualIns[]) { {
		.args = { AL, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "ADC AL, imm8", .orig_opcode = "14 ib",
		.desc = "Add with carry imm8 to AL",
		.opcode = { 0x14 }, .oplen = 1,
	}, {
		.args = { AX, IMM16 }, .arglen = 2, .immediate = 2,
		.orig_ins = "ADC AX, imm16", .orig_opcode = "15 iw",
		.desc = "Add with carry imm16 to AX.",
		.prefixes = 0x66, .opcode = { 0x15 }, .oplen = 1,
	}, {
		.args = { EAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "ADC EAX, imm32", .orig_opcode = "15 id",
		.desc = "Add with carry imm32 to EAX.",
		.opcode = { 0x15 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "ADC RAX, imm32", .orig_opcode = "REX.W+ 15 id",
		.desc = "Add with carry imm32 sign extended to 64- bits to RAX.",
		.opcode = { 0x15 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m8, imm8", .orig_opcode = "80 /2 ib",
		.desc = "Add with carry imm8 to r/m8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m8, imm8", .orig_opcode = "80 /2 ib",
		.desc = "Add with carry imm8 to r/m8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m16, imm16", .orig_opcode = "81 /2 iw",
		.desc = "Add with carry imm16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m16, imm16", .orig_opcode = "81 /2 iw",
		.desc = "Add with carry imm16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m32, imm32", .orig_opcode = "81 /2 id",
		.desc = "Add with CF imm32 to r/m32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m32, imm32", .orig_opcode = "81 /2 id",
		.desc = "Add with CF imm32 to r/m32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { M64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m64, imm32", .orig_opcode = "REX.W+ 81 /2 id",
		.desc = "Add with CF imm32 sign extended to 64-bits to r/m64.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { R64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m64, imm32", .orig_opcode = "REX.W+ 81 /2 id",
		.desc = "Add with CF imm32 sign extended to 64-bits to r/m64.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m16, imm8", .orig_opcode = "83 /2 ib",
		.desc = "Add with CF sign-extended imm8 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m16, imm8", .orig_opcode = "83 /2 ib",
		.desc = "Add with CF sign-extended imm8 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m32, imm8", .orig_opcode = "83 /2 ib",
		.desc = "Add with CF sign-extended imm8 into r/m32.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m32, imm8", .orig_opcode = "83 /2 ib",
		.desc = "Add with CF sign-extended imm8 into r/m32.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m64, imm8", .orig_opcode = "REX.W+ 83 /2 ib",
		.desc = "Add with CF sign-extended imm8 into r/m64.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADC r/m64, imm8", .orig_opcode = "REX.W+ 83 /2 ib",
		.desc = "Add with CF sign-extended imm8 into r/m64.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADC r/m8, r8", .orig_opcode = "10 /r",
		.desc = "Add with carry byte register to r/m8.",
		.opcode = { 0x10 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADC r/m8, r8", .orig_opcode = "10 /r",
		.desc = "Add with carry byte register to r/m8.",
		.opcode = { 0x10 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADC r/m8, r8", .orig_opcode = "10 /r",
		.desc = "Add with carry byte register to r/m8.",
		.opcode = { 0x10 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADC r/m8, r8", .orig_opcode = "10 /r",
		.desc = "Add with carry byte register to r/m8.",
		.opcode = { 0x10 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADC r/m16, r16", .orig_opcode = "11 /r",
		.desc = "Add with carry r16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x11 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADC r/m16, r16", .orig_opcode = "11 /r",
		.desc = "Add with carry r16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x11 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADC r/m32, r32", .orig_opcode = "11 /r",
		.desc = "Add with CF r32 to r/m32.",
		.opcode = { 0x11 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADC r/m32, r32", .orig_opcode = "11 /r",
		.desc = "Add with CF r32 to r/m32.",
		.opcode = { 0x11 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADC r/m64, r64", .orig_opcode = "REX.W+ 11 /r",
		.desc = "Add with CF r64 to r/m64.",
		.opcode = { 0x11 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADC r/m64, r64", .orig_opcode = "REX.W+ 11 /r",
		.desc = "Add with CF r64 to r/m64.",
		.opcode = { 0x11 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADC r8, r/m8", .orig_opcode = "12 /r",
		.desc = "Add with carry r/m8 to byte register.",
		.opcode = { 0x12 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADC r8, r/m8", .orig_opcode = "12 /r",
		.desc = "Add with carry r/m8 to byte register.",
		.opcode = { 0x12 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADC r8, r/m8", .orig_opcode = "12 /r",
		.desc = "Add with carry r/m8 to byte register.",
		.opcode = { 0x12 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADC r8, r/m8", .orig_opcode = "12 /r",
		.desc = "Add with carry r/m8 to byte register.",
		.opcode = { 0x12 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADC r16, r/m16", .orig_opcode = "13 /r",
		.desc = "Add with carry r/m16 to r16.",
		.prefixes = 0x66, .opcode = { 0x13 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADC r16, r/m16", .orig_opcode = "13 /r",
		.desc = "Add with carry r/m16 to r16.",
		.prefixes = 0x66, .opcode = { 0x13 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADC r32, r/m32", .orig_opcode = "13 /r",
		.desc = "Add with CF r/m32 to r32.",
		.opcode = { 0x13 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADC r32, r/m32", .orig_opcode = "13 /r",
		.desc = "Add with CF r/m32 to r32.",
		.opcode = { 0x13 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADC r64, r/m64", .orig_opcode = "REX.W+ 13 /r",
		.desc = "Add with CF r/m64 to r64.",
		.opcode = { 0x13 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADC r64, r/m64", .orig_opcode = "REX.W+ 13 /r",
		.desc = "Add with CF r/m64 to r64.",
		.opcode = { 0x13 }, .oplen = 1,
	} } },
	{ "add", 38, (struct x64LookupActualIns[]) { {
		.args = { AL, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "ADD AL, imm8", .orig_opcode = "04 ib",
		.desc = "Add imm8 to AL.",
		.opcode = { 0x04 }, .oplen = 1,
	}, {
		.args = { AX, IMM16 }, .arglen = 2, .immediate = 2,
		.orig_ins = "ADD AX, imm16", .orig_opcode = "05 iw",
		.desc = "Add imm16 to AX.",
		.prefixes = 0x66, .opcode = { 0x05 }, .oplen = 1,
	}, {
		.args = { EAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "ADD EAX, imm32", .orig_opcode = "05 id",
		.desc = "Add imm32 to EAX.",
		.opcode = { 0x05 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "ADD RAX, imm32", .orig_opcode = "REX.W+ 05 id",
		.desc = "Add imm32 sign-extended to 64-bits to RAX.",
		.opcode = { 0x05 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m8, imm8", .orig_opcode = "80 /0 ib",
		.desc = "Add imm8 to r/m8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m8, imm8", .orig_opcode = "80 /0 ib",
		.desc = "Add imm8 to r/m8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m16, imm16", .orig_opcode = "81 /0 iw",
		.desc = "Add imm16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m16, imm16", .orig_opcode = "81 /0 iw",
		.desc = "Add imm16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m32, imm32", .orig_opcode = "81 /0 id",
		.desc = "Add imm32 to r/m32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m32, imm32", .orig_opcode = "81 /0 id",
		.desc = "Add imm32 to r/m32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { M64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m64, imm32", .orig_opcode = "REX.W+ 81 /0 id",
		.desc = "Add imm32 sign-extended to 64-bits to r/m64.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { R64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m64, imm32", .orig_opcode = "REX.W+ 81 /0 id",
		.desc = "Add imm32 sign-extended to 64-bits to r/m64.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m16, imm8", .orig_opcode = "83 /0 ib",
		.desc = "Add sign-extended imm8 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m16, imm8", .orig_opcode = "83 /0 ib",
		.desc = "Add sign-extended imm8 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m32, imm8", .orig_opcode = "83 /0 ib",
		.desc = "Add sign-extended imm8 to r/m32.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m32, imm8", .orig_opcode = "83 /0 ib",
		.desc = "Add sign-extended imm8 to r/m32.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m64, imm8", .orig_opcode = "REX.W+ 83 /0 ib",
		.desc = "Add sign-extended imm8 to r/m64.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ADD r/m64, imm8", .orig_opcode = "REX.W+ 83 /0 ib",
		.desc = "Add sign-extended imm8 to r/m64.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADD r/m8, r8", .orig_opcode = "00 /r",
		.desc = "Add r8 to r/m8.",
		.opcode = { 0x00 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADD r/m8, r8", .orig_opcode = "00 /r",
		.desc = "Add r8 to r/m8.",
		.opcode = { 0x00 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADD r/m8, r8", .orig_opcode = "00 /r",
		.desc = "Add r8 to r/m8.",
		.opcode = { 0x00 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADD r/m8, r8", .orig_opcode = "00 /r",
		.desc = "Add r8 to r/m8.",
		.opcode = { 0x00 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADD r/m16, r16", .orig_opcode = "01 /r",
		.desc = "Add r16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x01 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADD r/m16, r16", .orig_opcode = "01 /r",
		.desc = "Add r16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x01 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADD r/m32, r32", .orig_opcode = "01 /r",
		.desc = "Add r32 to r/m32.",
		.opcode = { 0x01 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADD r/m32, r32", .orig_opcode = "01 /r",
		.desc = "Add r32 to r/m32.",
		.opcode = { 0x01 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADD r/m64, r64", .orig_opcode = "REX.W+ 01 /r",
		.desc = "Add r64 to r/m64.",
		.opcode = { 0x01 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "ADD r/m64, r64", .orig_opcode = "REX.W+ 01 /r",
		.desc = "Add r64 to r/m64.",
		.opcode = { 0x01 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADD r8, r/m8", .orig_opcode = "02 /r",
		.desc = "Add r/m8 to r8.",
		.opcode = { 0x02 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADD r8, r/m8", .orig_opcode = "02 /r",
		.desc = "Add r/m8 to r8.",
		.opcode = { 0x02 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADD r8, r/m8", .orig_opcode = "02 /r",
		.desc = "Add r/m8 to r8.",
		.opcode = { 0x02 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADD r8, r/m8", .orig_opcode = "02 /r",
		.desc = "Add r/m8 to r8.",
		.opcode = { 0x02 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADD r16, r/m16", .orig_opcode = "03 /r",
		.desc = "Add r/m16 to r16.",
		.prefixes = 0x66, .opcode = { 0x03 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADD r16, r/m16", .orig_opcode = "03 /r",
		.desc = "Add r/m16 to r16.",
		.prefixes = 0x66, .opcode = { 0x03 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADD r32, r/m32", .orig_opcode = "03 /r",
		.desc = "Add r/m32 to r32.",
		.opcode = { 0x03 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADD r32, r/m32", .orig_opcode = "03 /r",
		.desc = "Add r/m32 to r32.",
		.opcode = { 0x03 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADD r64, r/m64", .orig_opcode = "REX.W+ 03 /r",
		.desc = "Add r/m64 to r64.",
		.opcode = { 0x03 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADD r64, r/m64", .orig_opcode = "REX.W+ 03 /r",
		.desc = "Add r/m64 to r64.",
		.opcode = { 0x03 }, .oplen = 1,
	} } },
	{ "addpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDPD xmm1, xmm2/m128", .orig_opcode = "66 0F 58 /r",
		.desc = "Add packed double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x58 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDPD xmm1, xmm2/m128", .orig_opcode = "66 0F 58 /r",
		.desc = "Add packed double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x58 }, .oplen = 2,
	} } },
	{ "addps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDPS xmm1, xmm2/m128", .orig_opcode = "0F 58 /r",
		.desc = "Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1.",
		.opcode = { 0x0F, 0x58 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDPS xmm1, xmm2/m128", .orig_opcode = "0F 58 /r",
		.desc = "Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1.",
		.opcode = { 0x0F, 0x58 }, .oplen = 2,
	} } },
	{ "addsd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 58 /r",
		.desc = "Add the low double-precision floating-point value from xmm2/m64 to xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x58 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 58 /r",
		.desc = "Add the low double-precision floating-point value from xmm2/m64 to xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x58 }, .oplen = 2,
	} } },
	{ "addss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 58 /r",
		.desc = "Add the low single-precision floating-point value from xmm2/m32 to xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x58 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 58 /r",
		.desc = "Add the low single-precision floating-point value from xmm2/m32 to xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x58 }, .oplen = 2,
	} } },
	{ "addsubpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDSUBPD xmm1, xmm2/m128", .orig_opcode = "66 0F D0 /r",
		.desc = "Add/subtract double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDSUBPD xmm1, xmm2/m128", .orig_opcode = "66 0F D0 /r",
		.desc = "Add/subtract double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD0 }, .oplen = 2,
	} } },
	{ "addsubps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDSUBPS xmm1, xmm2/m128", .orig_opcode = "F2 0F D0 /r",
		.desc = "Add/subtract single-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0xD0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ADDSUBPS xmm1, xmm2/m128", .orig_opcode = "F2 0F D0 /r",
		.desc = "Add/subtract single-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0xD0 }, .oplen = 2,
	} } },
	{ "aesdec", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESDEC xmm1, xmm2/m128", .orig_opcode = "66 0F 38 DE /r",
		.desc = "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xDE }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESDEC xmm1, xmm2/m128", .orig_opcode = "66 0F 38 DE /r",
		.desc = "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xDE }, .oplen = 3,
	} } },
	{ "aesdeclast", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESDECLAST xmm1, xmm2/m128", .orig_opcode = "66 0F 38 DF /r",
		.desc = "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xDF }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESDECLAST xmm1, xmm2/m128", .orig_opcode = "66 0F 38 DF /r",
		.desc = "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xDF }, .oplen = 3,
	} } },
	{ "aesenc", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESENC xmm1, xmm2/m128", .orig_opcode = "66 0F 38 DC /r",
		.desc = "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xDC }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESENC xmm1, xmm2/m128", .orig_opcode = "66 0F 38 DC /r",
		.desc = "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xDC }, .oplen = 3,
	} } },
	{ "aesenclast", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESENCLAST xmm1, xmm2/m128", .orig_opcode = "66 0F 38 DD /r",
		.desc = "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xDD }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESENCLAST xmm1, xmm2/m128", .orig_opcode = "66 0F 38 DD /r",
		.desc = "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xDD }, .oplen = 3,
	} } },
	{ "aesimc", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESIMC xmm1, xmm2/m128", .orig_opcode = "66 0F 38 DB /r",
		.desc = "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xDB }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESIMC xmm1, xmm2/m128", .orig_opcode = "66 0F 38 DB /r",
		.desc = "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xDB }, .oplen = 3,
	} } },
	{ "aeskeygenassist", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESKEYGENASSIST xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A DF /r ib",
		.desc = "Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0xDF }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AESKEYGENASSIST xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A DF /r ib",
		.desc = "Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0xDF }, .oplen = 3,
	} } },
	{ "and", 38, (struct x64LookupActualIns[]) { {
		.args = { AL, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "AND AL, imm8", .orig_opcode = "24 ib",
		.desc = "AL AND imm8.",
		.opcode = { 0x24 }, .oplen = 1,
	}, {
		.args = { AX, IMM16 }, .arglen = 2, .immediate = 2,
		.orig_ins = "AND AX, imm16", .orig_opcode = "25 iw",
		.desc = "AX AND imm16.",
		.prefixes = 0x66, .opcode = { 0x25 }, .oplen = 1,
	}, {
		.args = { EAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "AND EAX, imm32", .orig_opcode = "25 id",
		.desc = "EAX AND imm32.",
		.opcode = { 0x25 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "AND RAX, imm32", .orig_opcode = "REX.W+ 25 id",
		.desc = "RAX AND imm32 sign-extended to 64-bits.",
		.opcode = { 0x25 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m8, imm8", .orig_opcode = "80 /4 ib",
		.desc = "r/m8 AND imm8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m8, imm8", .orig_opcode = "80 /4 ib",
		.desc = "r/m8 AND imm8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m16, imm16", .orig_opcode = "81 /4 iw",
		.desc = "r/m16 AND imm16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m16, imm16", .orig_opcode = "81 /4 iw",
		.desc = "r/m16 AND imm16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m32, imm32", .orig_opcode = "81 /4 id",
		.desc = "r/m32 AND imm32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m32, imm32", .orig_opcode = "81 /4 id",
		.desc = "r/m32 AND imm32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m64, imm32", .orig_opcode = "REX.W+ 81 /4 id",
		.desc = "r/m64 AND imm32 sign extended to 64-bits.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m64, imm32", .orig_opcode = "REX.W+ 81 /4 id",
		.desc = "r/m64 AND imm32 sign extended to 64-bits.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m16, imm8", .orig_opcode = "83 /4 ib",
		.desc = "r/m16 AND imm8 (sign-extended).",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m16, imm8", .orig_opcode = "83 /4 ib",
		.desc = "r/m16 AND imm8 (sign-extended).",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m32, imm8", .orig_opcode = "83 /4 ib",
		.desc = "r/m32 AND imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m32, imm8", .orig_opcode = "83 /4 ib",
		.desc = "r/m32 AND imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m64, imm8", .orig_opcode = "REX.W+ 83 /4 ib",
		.desc = "r/m64 AND imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "AND r/m64, imm8", .orig_opcode = "REX.W+ 83 /4 ib",
		.desc = "r/m64 AND imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "AND r/m8, r8", .orig_opcode = "20 /r",
		.desc = "r/m8 AND r8.",
		.opcode = { 0x20 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "AND r/m8, r8", .orig_opcode = "20 /r",
		.desc = "r/m8 AND r8.",
		.opcode = { 0x20 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "AND r/m8, r8", .orig_opcode = "20 /r",
		.desc = "r/m8 AND r8.",
		.opcode = { 0x20 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "AND r/m8, r8", .orig_opcode = "20 /r",
		.desc = "r/m8 AND r8.",
		.opcode = { 0x20 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "AND r/m16, r16", .orig_opcode = "21 /r",
		.desc = "r/m16 AND r16.",
		.prefixes = 0x66, .opcode = { 0x21 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "AND r/m16, r16", .orig_opcode = "21 /r",
		.desc = "r/m16 AND r16.",
		.prefixes = 0x66, .opcode = { 0x21 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "AND r/m32, r32", .orig_opcode = "21 /r",
		.desc = "r/m32 AND r32.",
		.opcode = { 0x21 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "AND r/m32, r32", .orig_opcode = "21 /r",
		.desc = "r/m32 AND r32.",
		.opcode = { 0x21 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "AND r/m64, r64", .orig_opcode = "REX.W+ 21 /r",
		.desc = "r/m64 AND r32.",
		.opcode = { 0x21 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "AND r/m64, r64", .orig_opcode = "REX.W+ 21 /r",
		.desc = "r/m64 AND r32.",
		.opcode = { 0x21 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AND r8, r/m8", .orig_opcode = "22 /r",
		.desc = "r8 AND r/m8.",
		.opcode = { 0x22 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AND r8, r/m8", .orig_opcode = "22 /r",
		.desc = "r8 AND r/m8.",
		.opcode = { 0x22 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AND r8, r/m8", .orig_opcode = "22 /r",
		.desc = "r8 AND r/m8.",
		.opcode = { 0x22 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AND r8, r/m8", .orig_opcode = "22 /r",
		.desc = "r8 AND r/m8.",
		.opcode = { 0x22 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AND r16, r/m16", .orig_opcode = "23 /r",
		.desc = "r16 AND r/m16.",
		.prefixes = 0x66, .opcode = { 0x23 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AND r16, r/m16", .orig_opcode = "23 /r",
		.desc = "r16 AND r/m16.",
		.prefixes = 0x66, .opcode = { 0x23 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AND r32, r/m32", .orig_opcode = "23 /r",
		.desc = "r32 AND r/m32.",
		.opcode = { 0x23 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AND r32, r/m32", .orig_opcode = "23 /r",
		.desc = "r32 AND r/m32.",
		.opcode = { 0x23 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AND r64, r/m64", .orig_opcode = "REX.W+ 23 /r",
		.desc = "r64 AND r/m64.",
		.opcode = { 0x23 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "AND r64, r/m64", .orig_opcode = "REX.W+ 23 /r",
		.desc = "r64 AND r/m64.",
		.opcode = { 0x23 }, .oplen = 1,
	} } },
	{ "andpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ANDPD xmm1, xmm2/m128", .orig_opcode = "66 0F 54 /r",
		.desc = "Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x54 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ANDPD xmm1, xmm2/m128", .orig_opcode = "66 0F 54 /r",
		.desc = "Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x54 }, .oplen = 2,
	} } },
	{ "andps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ANDPS xmm1, xmm2/m128", .orig_opcode = "0F 54 /r",
		.desc = "Bitwise logical AND of xmm2/m128 and xmm1.",
		.opcode = { 0x0F, 0x54 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ANDPS xmm1, xmm2/m128", .orig_opcode = "0F 54 /r",
		.desc = "Bitwise logical AND of xmm2/m128 and xmm1.",
		.opcode = { 0x0F, 0x54 }, .oplen = 2,
	} } },
	{ "andnpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ANDNPD xmm1, xmm2/m128", .orig_opcode = "66 0F 55 /r",
		.desc = "Bitwise logical AND NOT of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x55 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ANDNPD xmm1, xmm2/m128", .orig_opcode = "66 0F 55 /r",
		.desc = "Bitwise logical AND NOT of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x55 }, .oplen = 2,
	} } },
	{ "andnps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ANDNPS xmm1, xmm2/m128", .orig_opcode = "0F 55 /r",
		.desc = "Bitwise logical AND NOT of xmm2/m128 and xmm1.",
		.opcode = { 0x0F, 0x55 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ANDNPS xmm1, xmm2/m128", .orig_opcode = "0F 55 /r",
		.desc = "Bitwise logical AND NOT of xmm2/m128 and xmm1.",
		.opcode = { 0x0F, 0x55 }, .oplen = 2,
	} } },
	{ "blendpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BLENDPD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 0D /r ib",
		.desc = "Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0D }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BLENDPD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 0D /r ib",
		.desc = "Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0D }, .oplen = 3,
	} } },
	{ "blendps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BLENDPS xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 0C /r ib",
		.desc = "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0C }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BLENDPS xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 0C /r ib",
		.desc = "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0C }, .oplen = 3,
	} } },
	{ "blendvpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, XMM_0 }, .arglen = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BLENDVPD xmm1, xmm2/m128, <XMM0>", .orig_opcode = "66 0F 38 15 /r",
		.desc = "Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x15 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, XMM_0 }, .arglen = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BLENDVPD xmm1, xmm2/m128, <XMM0>", .orig_opcode = "66 0F 38 15 /r",
		.desc = "Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x15 }, .oplen = 3,
	} } },
	{ "blendvps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, XMM_0 }, .arglen = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BLENDVPS xmm1, xmm2/m128, <XMM0>", .orig_opcode = "66 0F 38 14 /r",
		.desc = "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x14 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, XMM_0 }, .arglen = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BLENDVPS xmm1, xmm2/m128, <XMM0>", .orig_opcode = "66 0F 38 14 /r",
		.desc = "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x14 }, .oplen = 3,
	} } },
	{ "bsf", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSF r16, r/m16", .orig_opcode = "0F BC /r",
		.desc = "Bit scan forward on r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSF r16, r/m16", .orig_opcode = "0F BC /r",
		.desc = "Bit scan forward on r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSF r32, r/m32", .orig_opcode = "0F BC /r",
		.desc = "Bit scan forward on r/m32.",
		.opcode = { 0x0F, 0xBC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSF r32, r/m32", .orig_opcode = "0F BC /r",
		.desc = "Bit scan forward on r/m32.",
		.opcode = { 0x0F, 0xBC }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSF r64, r/m64", .orig_opcode = "REX.W+ 0F BC",
		.desc = "Bit scan forward on r/m64.",
		.opcode = { 0x0F, 0xBC }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSF r64, r/m64", .orig_opcode = "REX.W+ 0F BC",
		.desc = "Bit scan forward on r/m64.",
		.opcode = { 0x0F, 0xBC }, .oplen = 2,
	} } },
	{ "bsr", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSR r16, r/m16", .orig_opcode = "0F BD /r",
		.desc = "Bit scan reverse on r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSR r16, r/m16", .orig_opcode = "0F BD /r",
		.desc = "Bit scan reverse on r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSR r32, r/m32", .orig_opcode = "0F BD /r",
		.desc = "Bit scan reverse on r/m32.",
		.opcode = { 0x0F, 0xBD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSR r32, r/m32", .orig_opcode = "0F BD /r",
		.desc = "Bit scan reverse on r/m32.",
		.opcode = { 0x0F, 0xBD }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSR r64, r/m64", .orig_opcode = "REX.W+ 0F BD",
		.desc = "Bit scan reverse on r/m64.",
		.opcode = { 0x0F, 0xBD }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "BSR r64, r/m64", .orig_opcode = "REX.W+ 0F BD",
		.desc = "Bit scan reverse on r/m64.",
		.opcode = { 0x0F, 0xBD }, .oplen = 2,
	} } },
	{ "bswap", 2, (struct x64LookupActualIns[]) { {
		.args = { R32 }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "BSWAP r32", .orig_opcode = "0F C8 +rd",
		.desc = "Reverses the byte order of a 32-bit register.",
		.opcode = { 0x0F, 0xC8 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64 }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "BSWAP r64", .orig_opcode = "REX.W+ 0F C8 +rd",
		.desc = "Reverses the byte order of a 64-bit register.",
		.opcode = { 0x0F, 0xC8 }, .oplen = 2,
	} } },
	{ "bt", 12, (struct x64LookupActualIns[]) { {
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BT r/m16, r16", .orig_opcode = "0F A3",
		.desc = "Store selected bit in CF flag.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xA3 }, .oplen = 2,
	}, {
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BT r/m16, r16", .orig_opcode = "0F A3",
		.desc = "Store selected bit in CF flag.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xA3 }, .oplen = 2,
	}, {
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BT r/m32, r32", .orig_opcode = "0F A3",
		.desc = "Store selected bit in CF flag.",
		.opcode = { 0x0F, 0xA3 }, .oplen = 2,
	}, {
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BT r/m32, r32", .orig_opcode = "0F A3",
		.desc = "Store selected bit in CF flag.",
		.opcode = { 0x0F, 0xA3 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BT r/m64, r64", .orig_opcode = "REX.W+ 0F A3",
		.desc = "Store selected bit in CF flag.",
		.opcode = { 0x0F, 0xA3 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BT r/m64, r64", .orig_opcode = "REX.W+ 0F A3",
		.desc = "Store selected bit in CF flag.",
		.opcode = { 0x0F, 0xA3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BT r/m16, imm8", .orig_opcode = "0F BA /4 ib",
		.desc = "Store selected bit in CF flag.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BT r/m16, imm8", .orig_opcode = "0F BA /4 ib",
		.desc = "Store selected bit in CF flag.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BT r/m32, imm8", .orig_opcode = "0F BA /4 ib",
		.desc = "Store selected bit in CF flag.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BT r/m32, imm8", .orig_opcode = "0F BA /4 ib",
		.desc = "Store selected bit in CF flag.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BT r/m64, imm8", .orig_opcode = "REX.W+ 0F BA /4 ib",
		.desc = "Store selected bit in CF flag.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BT r/m64, imm8", .orig_opcode = "REX.W+ 0F BA /4 ib",
		.desc = "Store selected bit in CF flag.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	} } },
	{ "btc", 12, (struct x64LookupActualIns[]) { {
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTC r/m16, r16", .orig_opcode = "0F BB",
		.desc = "Store selected bit in CF flag and complement.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBB }, .oplen = 2,
	}, {
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTC r/m16, r16", .orig_opcode = "0F BB",
		.desc = "Store selected bit in CF flag and complement.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBB }, .oplen = 2,
	}, {
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTC r/m32, r32", .orig_opcode = "0F BB",
		.desc = "Store selected bit in CF flag and complement.",
		.opcode = { 0x0F, 0xBB }, .oplen = 2,
	}, {
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTC r/m32, r32", .orig_opcode = "0F BB",
		.desc = "Store selected bit in CF flag and complement.",
		.opcode = { 0x0F, 0xBB }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTC r/m64, r64", .orig_opcode = "REX.W+ 0F BB",
		.desc = "Store selected bit in CF flag and complement.",
		.opcode = { 0x0F, 0xBB }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTC r/m64, r64", .orig_opcode = "REX.W+ 0F BB",
		.desc = "Store selected bit in CF flag and complement.",
		.opcode = { 0x0F, 0xBB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTC r/m16, imm8", .orig_opcode = "0F BA /7 ib",
		.desc = "Store selected bit in CF flag and complement.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTC r/m16, imm8", .orig_opcode = "0F BA /7 ib",
		.desc = "Store selected bit in CF flag and complement.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTC r/m32, imm8", .orig_opcode = "0F BA /7 ib",
		.desc = "Store selected bit in CF flag and complement.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTC r/m32, imm8", .orig_opcode = "0F BA /7 ib",
		.desc = "Store selected bit in CF flag and complement.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTC r/m64, imm8", .orig_opcode = "REX.W+ 0F BA /7 ib",
		.desc = "Store selected bit in CF flag and complement.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTC r/m64, imm8", .orig_opcode = "REX.W+ 0F BA /7 ib",
		.desc = "Store selected bit in CF flag and complement.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	} } },
	{ "btr", 12, (struct x64LookupActualIns[]) { {
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTR r/m16, r16", .orig_opcode = "0F B3",
		.desc = "Store selected bit in CF flag and clear.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xB3 }, .oplen = 2,
	}, {
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTR r/m16, r16", .orig_opcode = "0F B3",
		.desc = "Store selected bit in CF flag and clear.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xB3 }, .oplen = 2,
	}, {
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTR r/m32, r32", .orig_opcode = "0F B3",
		.desc = "Store selected bit in CF flag and clear.",
		.opcode = { 0x0F, 0xB3 }, .oplen = 2,
	}, {
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTR r/m32, r32", .orig_opcode = "0F B3",
		.desc = "Store selected bit in CF flag and clear.",
		.opcode = { 0x0F, 0xB3 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTR r/m64, r64", .orig_opcode = "REX.W+ 0F B3",
		.desc = "Store selected bit in CF flag and clear.",
		.opcode = { 0x0F, 0xB3 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTR r/m64, r64", .orig_opcode = "REX.W+ 0F B3",
		.desc = "Store selected bit in CF flag and clear.",
		.opcode = { 0x0F, 0xB3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTR r/m16, imm8", .orig_opcode = "0F BA /6 ib",
		.desc = "Store selected bit in CF flag and clear.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTR r/m16, imm8", .orig_opcode = "0F BA /6 ib",
		.desc = "Store selected bit in CF flag and clear.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTR r/m32, imm8", .orig_opcode = "0F BA /6 ib",
		.desc = "Store selected bit in CF flag and clear.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTR r/m32, imm8", .orig_opcode = "0F BA /6 ib",
		.desc = "Store selected bit in CF flag and clear.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTR r/m64, imm8", .orig_opcode = "REX.W+ 0F BA /6 ib",
		.desc = "Store selected bit in CF flag and clear.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTR r/m64, imm8", .orig_opcode = "REX.W+ 0F BA /6 ib",
		.desc = "Store selected bit in CF flag and clear.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	} } },
	{ "bts", 12, (struct x64LookupActualIns[]) { {
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTS r/m16, r16", .orig_opcode = "0F AB",
		.desc = "Store selected bit in CF flag and set.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAB }, .oplen = 2,
	}, {
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTS r/m16, r16", .orig_opcode = "0F AB",
		.desc = "Store selected bit in CF flag and set.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAB }, .oplen = 2,
	}, {
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTS r/m32, r32", .orig_opcode = "0F AB",
		.desc = "Store selected bit in CF flag and set.",
		.opcode = { 0x0F, 0xAB }, .oplen = 2,
	}, {
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTS r/m32, r32", .orig_opcode = "0F AB",
		.desc = "Store selected bit in CF flag and set.",
		.opcode = { 0x0F, 0xAB }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTS r/m64, r64", .orig_opcode = "REX.W+ 0F AB",
		.desc = "Store selected bit in CF flag and set.",
		.opcode = { 0x0F, 0xAB }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "BTS r/m64, r64", .orig_opcode = "REX.W+ 0F AB",
		.desc = "Store selected bit in CF flag and set.",
		.opcode = { 0x0F, 0xAB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTS r/m16, imm8", .orig_opcode = "0F BA /5 ib",
		.desc = "Store selected bit in CF flag and set.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTS r/m16, imm8", .orig_opcode = "0F BA /5 ib",
		.desc = "Store selected bit in CF flag and set.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTS r/m32, imm8", .orig_opcode = "0F BA /5 ib",
		.desc = "Store selected bit in CF flag and set.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTS r/m32, imm8", .orig_opcode = "0F BA /5 ib",
		.desc = "Store selected bit in CF flag and set.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTS r/m64, imm8", .orig_opcode = "REX.W+ 0F BA /5 ib",
		.desc = "Store selected bit in CF flag and set.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "BTS r/m64, imm8", .orig_opcode = "REX.W+ 0F BA /5 ib",
		.desc = "Store selected bit in CF flag and set.",
		.opcode = { 0x0F, 0xBA }, .oplen = 2,
	} } },
	{ "call", 5, (struct x64LookupActualIns[]) { {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "CALL rel32", .orig_opcode = "E8 cd",
		.desc = "Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode.",
		.opcode = { 0xE8 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "CALL r/m64", .orig_opcode = "FF /2",
		.desc = "Call near, absolute indirect, address given in r/m64.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "CALL r/m64", .orig_opcode = "FF /2",
		.desc = "Call near, absolute indirect, address given in r/m64.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "CALL m16:32", .orig_opcode = "FF /3",
		.desc = "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "CALL m16:64", .orig_opcode = "REX.W+ FF /3",
		.desc = "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction.",
		.opcode = { 0xFF }, .oplen = 1,
	} } },
	{ "cbw", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CBW", .orig_opcode = "PREF.66+ 98",
		.desc = "AX = sign-extend of AL.",
		.prefixes = 0x66, .opcode = { 0x98 }, .oplen = 1,
	} } },
	{ "cwde", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CWDE", .orig_opcode = "98",
		.desc = "EAX = sign-extend of AX.",
		.opcode = { 0x98 }, .oplen = 1,
	} } },
	{ "cdqe", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, 
		.orig_ins = "CDQE", .orig_opcode = "REX.W+ 98",
		.desc = "RAX = sign-extend of EAX.",
		.opcode = { 0x98 }, .oplen = 1,
	} } },
	{ "clc", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CLC", .orig_opcode = "F8",
		.desc = "Clear CF flag.",
		.opcode = { 0xF8 }, .oplen = 1,
	} } },
	{ "cld", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CLD", .orig_opcode = "FC",
		.desc = "Clear DF flag.",
		.opcode = { 0xFC }, .oplen = 1,
	} } },
	{ "clflush", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "CLFLUSH m8", .orig_opcode = "0F AE /7",
		.desc = "Flushes cache line containing m8.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "cli", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CLI", .orig_opcode = "FA",
		.desc = "Clear interrupt flag; interrupts disabled when interrupt flag cleared.",
		.opcode = { 0xFA }, .oplen = 1,
	} } },
	{ "clts", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CLTS", .orig_opcode = "0F 06",
		.desc = "Clears TS flag in CR0.",
		.opcode = { 0x0F, 0x06 }, .oplen = 2,
	} } },
	{ "cmc", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CMC", .orig_opcode = "F5",
		.desc = "Complement CF flag.",
		.opcode = { 0xF5 }, .oplen = 1,
	} } },
	{ "cmova", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVA r16, r/m16", .orig_opcode = "0F 47 /r",
		.desc = "Move if above (CF=0 and ZF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x47 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVA r16, r/m16", .orig_opcode = "0F 47 /r",
		.desc = "Move if above (CF=0 and ZF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x47 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVA r32, r/m32", .orig_opcode = "0F 47 /r",
		.desc = "Move if above (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x47 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVA r32, r/m32", .orig_opcode = "0F 47 /r",
		.desc = "Move if above (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x47 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVA r64, r/m64", .orig_opcode = "REX.W+ 0F 47 /r",
		.desc = "Move if above (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x47 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVA r64, r/m64", .orig_opcode = "REX.W+ 0F 47 /r",
		.desc = "Move if above (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x47 }, .oplen = 2,
	} } },
	{ "cmovae", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVAE r16, r/m16", .orig_opcode = "0F 43 /r",
		.desc = "Move if above or equal (CF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVAE r16, r/m16", .orig_opcode = "0F 43 /r",
		.desc = "Move if above or equal (CF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVAE r32, r/m32", .orig_opcode = "0F 43 /r",
		.desc = "Move if above or equal (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVAE r32, r/m32", .orig_opcode = "0F 43 /r",
		.desc = "Move if above or equal (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVAE r64, r/m64", .orig_opcode = "REX.W+ 0F 43 /r",
		.desc = "Move if above or equal (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVAE r64, r/m64", .orig_opcode = "REX.W+ 0F 43 /r",
		.desc = "Move if above or equal (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	} } },
	{ "cmovb", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVB r16, r/m16", .orig_opcode = "0F 42 /r",
		.desc = "Move if below (CF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVB r16, r/m16", .orig_opcode = "0F 42 /r",
		.desc = "Move if below (CF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVB r32, r/m32", .orig_opcode = "0F 42 /r",
		.desc = "Move if below (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVB r32, r/m32", .orig_opcode = "0F 42 /r",
		.desc = "Move if below (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVB r64, r/m64", .orig_opcode = "REX.W+ 0F 42 /r",
		.desc = "Move if below (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVB r64, r/m64", .orig_opcode = "REX.W+ 0F 42 /r",
		.desc = "Move if below (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	} } },
	{ "cmovbe", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVBE r16, r/m16", .orig_opcode = "0F 46 /r",
		.desc = "Move if below or equal (CF=1 or ZF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x46 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVBE r16, r/m16", .orig_opcode = "0F 46 /r",
		.desc = "Move if below or equal (CF=1 or ZF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x46 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVBE r32, r/m32", .orig_opcode = "0F 46 /r",
		.desc = "Move if below or equal (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x46 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVBE r32, r/m32", .orig_opcode = "0F 46 /r",
		.desc = "Move if below or equal (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x46 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVBE r64, r/m64", .orig_opcode = "REX.W+ 0F 46 /r",
		.desc = "Move if below or equal (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x46 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVBE r64, r/m64", .orig_opcode = "REX.W+ 0F 46 /r",
		.desc = "Move if below or equal (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x46 }, .oplen = 2,
	} } },
	{ "cmovc", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVC r16, r/m16", .orig_opcode = "0F 42 /r",
		.desc = "Move if carry (CF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVC r16, r/m16", .orig_opcode = "0F 42 /r",
		.desc = "Move if carry (CF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVC r32, r/m32", .orig_opcode = "0F 42 /r",
		.desc = "Move if carry (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVC r32, r/m32", .orig_opcode = "0F 42 /r",
		.desc = "Move if carry (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVC r64, r/m64", .orig_opcode = "REX.W+ 0F 42 /r",
		.desc = "Move if carry (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVC r64, r/m64", .orig_opcode = "REX.W+ 0F 42 /r",
		.desc = "Move if carry (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	} } },
	{ "cmove", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVE r16, r/m16", .orig_opcode = "0F 44 /r",
		.desc = "Move if equal (ZF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x44 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVE r16, r/m16", .orig_opcode = "0F 44 /r",
		.desc = "Move if equal (ZF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x44 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVE r32, r/m32", .orig_opcode = "0F 44 /r",
		.desc = "Move if equal (ZF=1).",
		.opcode = { 0x0F, 0x44 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVE r32, r/m32", .orig_opcode = "0F 44 /r",
		.desc = "Move if equal (ZF=1).",
		.opcode = { 0x0F, 0x44 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVE r64, r/m64", .orig_opcode = "REX.W+ 0F 44 /r",
		.desc = "Move if equal (ZF=1).",
		.opcode = { 0x0F, 0x44 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVE r64, r/m64", .orig_opcode = "REX.W+ 0F 44 /r",
		.desc = "Move if equal (ZF=1).",
		.opcode = { 0x0F, 0x44 }, .oplen = 2,
	} } },
	{ "cmovg", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVG r16, r/m16", .orig_opcode = "0F 4F /r",
		.desc = "Move if greater (ZF=0 and SF=OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVG r16, r/m16", .orig_opcode = "0F 4F /r",
		.desc = "Move if greater (ZF=0 and SF=OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVG r32, r/m32", .orig_opcode = "0F 4F /r",
		.desc = "Move if greater (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x4F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVG r32, r/m32", .orig_opcode = "0F 4F /r",
		.desc = "Move if greater (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x4F }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVG r64, r/m64", .orig_opcode = "REX.W+ 0F 4F /r",
		.desc = "Move if greater (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x4F }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVG r64, r/m64", .orig_opcode = "REX.W+ 0F 4F /r",
		.desc = "Move if greater (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x4F }, .oplen = 2,
	} } },
	{ "cmovge", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVGE r16, r/m16", .orig_opcode = "0F 4D /r",
		.desc = "Move if greater or equal (SF=OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVGE r16, r/m16", .orig_opcode = "0F 4D /r",
		.desc = "Move if greater or equal (SF=OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVGE r32, r/m32", .orig_opcode = "0F 4D /r",
		.desc = "Move if greater or equal (SF=OF).",
		.opcode = { 0x0F, 0x4D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVGE r32, r/m32", .orig_opcode = "0F 4D /r",
		.desc = "Move if greater or equal (SF=OF).",
		.opcode = { 0x0F, 0x4D }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVGE r64, r/m64", .orig_opcode = "REX.W+ 0F 4D /r",
		.desc = "Move if greater or equal (SF=OF).",
		.opcode = { 0x0F, 0x4D }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVGE r64, r/m64", .orig_opcode = "REX.W+ 0F 4D /r",
		.desc = "Move if greater or equal (SF=OF).",
		.opcode = { 0x0F, 0x4D }, .oplen = 2,
	} } },
	{ "cmovl", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVL r16, r/m16", .orig_opcode = "0F 4C /r",
		.desc = "Move if less (SF != OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVL r16, r/m16", .orig_opcode = "0F 4C /r",
		.desc = "Move if less (SF != OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVL r32, r/m32", .orig_opcode = "0F 4C /r",
		.desc = "Move if less (SF!= OF).",
		.opcode = { 0x0F, 0x4C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVL r32, r/m32", .orig_opcode = "0F 4C /r",
		.desc = "Move if less (SF!= OF).",
		.opcode = { 0x0F, 0x4C }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVL r64, r/m64", .orig_opcode = "REX.W+ 0F 4C /r",
		.desc = "Move if less (SF!= OF).",
		.opcode = { 0x0F, 0x4C }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVL r64, r/m64", .orig_opcode = "REX.W+ 0F 4C /r",
		.desc = "Move if less (SF!= OF).",
		.opcode = { 0x0F, 0x4C }, .oplen = 2,
	} } },
	{ "cmovle", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVLE r16, r/m16", .orig_opcode = "0F 4E /r",
		.desc = "Move if less or equal (ZF=1 or SF!= OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVLE r16, r/m16", .orig_opcode = "0F 4E /r",
		.desc = "Move if less or equal (ZF=1 or SF!= OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVLE r32, r/m32", .orig_opcode = "0F 4E /r",
		.desc = "Move if less or equal (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x4E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVLE r32, r/m32", .orig_opcode = "0F 4E /r",
		.desc = "Move if less or equal (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x4E }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVLE r64, r/m64", .orig_opcode = "REX.W+ 0F 4E /r",
		.desc = "Move if less or equal (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x4E }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVLE r64, r/m64", .orig_opcode = "REX.W+ 0F 4E /r",
		.desc = "Move if less or equal (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x4E }, .oplen = 2,
	} } },
	{ "cmovna", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNA r16, r/m16", .orig_opcode = "0F 46 /r",
		.desc = "Move if not above (CF=1 or ZF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x46 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNA r16, r/m16", .orig_opcode = "0F 46 /r",
		.desc = "Move if not above (CF=1 or ZF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x46 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNA r32, r/m32", .orig_opcode = "0F 46 /r",
		.desc = "Move if not above (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x46 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNA r32, r/m32", .orig_opcode = "0F 46 /r",
		.desc = "Move if not above (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x46 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNA r64, r/m64", .orig_opcode = "REX.W+ 0F 46 /r",
		.desc = "Move if not above (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x46 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNA r64, r/m64", .orig_opcode = "REX.W+ 0F 46 /r",
		.desc = "Move if not above (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x46 }, .oplen = 2,
	} } },
	{ "cmovnae", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNAE r16, r/m16", .orig_opcode = "0F 42 /r",
		.desc = "Move if not above or equal (CF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNAE r16, r/m16", .orig_opcode = "0F 42 /r",
		.desc = "Move if not above or equal (CF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNAE r32, r/m32", .orig_opcode = "0F 42 /r",
		.desc = "Move if not above or equal (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNAE r32, r/m32", .orig_opcode = "0F 42 /r",
		.desc = "Move if not above or equal (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNAE r64, r/m64", .orig_opcode = "REX.W+ 0F 42 /r",
		.desc = "Move if not above or equal (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNAE r64, r/m64", .orig_opcode = "REX.W+ 0F 42 /r",
		.desc = "Move if not above or equal (CF=1).",
		.opcode = { 0x0F, 0x42 }, .oplen = 2,
	} } },
	{ "cmovnb", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNB r16, r/m16", .orig_opcode = "0F 43 /r",
		.desc = "Move if not below (CF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNB r16, r/m16", .orig_opcode = "0F 43 /r",
		.desc = "Move if not below (CF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNB r32, r/m32", .orig_opcode = "0F 43 /r",
		.desc = "Move if not below (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNB r32, r/m32", .orig_opcode = "0F 43 /r",
		.desc = "Move if not below (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNB r64, r/m64", .orig_opcode = "REX.W+ 0F 43 /r",
		.desc = "Move if not below (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNB r64, r/m64", .orig_opcode = "REX.W+ 0F 43 /r",
		.desc = "Move if not below (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	} } },
	{ "cmovnbe", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNBE r16, r/m16", .orig_opcode = "0F 47 /r",
		.desc = "Move if not below or equal (CF=0 and ZF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x47 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNBE r16, r/m16", .orig_opcode = "0F 47 /r",
		.desc = "Move if not below or equal (CF=0 and ZF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x47 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNBE r32, r/m32", .orig_opcode = "0F 47 /r",
		.desc = "Move if not below or equal (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x47 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNBE r32, r/m32", .orig_opcode = "0F 47 /r",
		.desc = "Move if not below or equal (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x47 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNBE r64, r/m64", .orig_opcode = "REX.W+ 0F 47 /r",
		.desc = "Move if not below or equal (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x47 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNBE r64, r/m64", .orig_opcode = "REX.W+ 0F 47 /r",
		.desc = "Move if not below or equal (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x47 }, .oplen = 2,
	} } },
	{ "cmovnc", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNC r16, r/m16", .orig_opcode = "0F 43 /r",
		.desc = "Move if not carry (CF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNC r16, r/m16", .orig_opcode = "0F 43 /r",
		.desc = "Move if not carry (CF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNC r32, r/m32", .orig_opcode = "0F 43 /r",
		.desc = "Move if not carry (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNC r32, r/m32", .orig_opcode = "0F 43 /r",
		.desc = "Move if not carry (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNC r64, r/m64", .orig_opcode = "REX.W+ 0F 43 /r",
		.desc = "Move if not carry (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNC r64, r/m64", .orig_opcode = "REX.W+ 0F 43 /r",
		.desc = "Move if not carry (CF=0).",
		.opcode = { 0x0F, 0x43 }, .oplen = 2,
	} } },
	{ "cmovne", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNE r16, r/m16", .orig_opcode = "0F 45 /r",
		.desc = "Move if not equal (ZF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x45 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNE r16, r/m16", .orig_opcode = "0F 45 /r",
		.desc = "Move if not equal (ZF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x45 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNE r32, r/m32", .orig_opcode = "0F 45 /r",
		.desc = "Move if not equal (ZF=0).",
		.opcode = { 0x0F, 0x45 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNE r32, r/m32", .orig_opcode = "0F 45 /r",
		.desc = "Move if not equal (ZF=0).",
		.opcode = { 0x0F, 0x45 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNE r64, r/m64", .orig_opcode = "REX.W+ 0F 45 /r",
		.desc = "Move if not equal (ZF=0).",
		.opcode = { 0x0F, 0x45 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNE r64, r/m64", .orig_opcode = "REX.W+ 0F 45 /r",
		.desc = "Move if not equal (ZF=0).",
		.opcode = { 0x0F, 0x45 }, .oplen = 2,
	} } },
	{ "cmovng", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNG r16, r/m16", .orig_opcode = "0F 4E /r",
		.desc = "Move if not greater (ZF=1 or SF!= OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNG r16, r/m16", .orig_opcode = "0F 4E /r",
		.desc = "Move if not greater (ZF=1 or SF!= OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNG r32, r/m32", .orig_opcode = "0F 4E /r",
		.desc = "Move if not greater (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x4E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNG r32, r/m32", .orig_opcode = "0F 4E /r",
		.desc = "Move if not greater (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x4E }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNG r64, r/m64", .orig_opcode = "REX.W+ 0F 4E /r",
		.desc = "Move if not greater (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x4E }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNG r64, r/m64", .orig_opcode = "REX.W+ 0F 4E /r",
		.desc = "Move if not greater (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x4E }, .oplen = 2,
	} } },
	{ "cmovnge", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNGE r16, r/m16", .orig_opcode = "0F 4C /r",
		.desc = "Move if not greater or equal (SF!= OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNGE r16, r/m16", .orig_opcode = "0F 4C /r",
		.desc = "Move if not greater or equal (SF!= OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNGE r32, r/m32", .orig_opcode = "0F 4C /r",
		.desc = "Move if not greater or equal (SF!= OF).",
		.opcode = { 0x0F, 0x4C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNGE r32, r/m32", .orig_opcode = "0F 4C /r",
		.desc = "Move if not greater or equal (SF!= OF).",
		.opcode = { 0x0F, 0x4C }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNGE r64, r/m64", .orig_opcode = "REX.W+ 0F 4C /r",
		.desc = "Move if not greater or equal (SF!= OF).",
		.opcode = { 0x0F, 0x4C }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNGE r64, r/m64", .orig_opcode = "REX.W+ 0F 4C /r",
		.desc = "Move if not greater or equal (SF!= OF).",
		.opcode = { 0x0F, 0x4C }, .oplen = 2,
	} } },
	{ "cmovnl", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNL r16, r/m16", .orig_opcode = "0F 4D /r",
		.desc = "Move if not less (SF=OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNL r16, r/m16", .orig_opcode = "0F 4D /r",
		.desc = "Move if not less (SF=OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNL r32, r/m32", .orig_opcode = "0F 4D /r",
		.desc = "Move if not less (SF=OF).",
		.opcode = { 0x0F, 0x4D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNL r32, r/m32", .orig_opcode = "0F 4D /r",
		.desc = "Move if not less (SF=OF).",
		.opcode = { 0x0F, 0x4D }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNL r64, r/m64", .orig_opcode = "REX.W+ 0F 4D /r",
		.desc = "Move if not less (SF=OF).",
		.opcode = { 0x0F, 0x4D }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNL r64, r/m64", .orig_opcode = "REX.W+ 0F 4D /r",
		.desc = "Move if not less (SF=OF).",
		.opcode = { 0x0F, 0x4D }, .oplen = 2,
	} } },
	{ "cmovnle", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNLE r16, r/m16", .orig_opcode = "0F 4F /r",
		.desc = "Move if not less or equal (ZF=0 and SF=OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNLE r16, r/m16", .orig_opcode = "0F 4F /r",
		.desc = "Move if not less or equal (ZF=0 and SF=OF).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNLE r32, r/m32", .orig_opcode = "0F 4F /r",
		.desc = "Move if not less or equal (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x4F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNLE r32, r/m32", .orig_opcode = "0F 4F /r",
		.desc = "Move if not less or equal (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x4F }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNLE r64, r/m64", .orig_opcode = "REX.W+ 0F 4F /r",
		.desc = "Move if not less or equal (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x4F }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNLE r64, r/m64", .orig_opcode = "REX.W+ 0F 4F /r",
		.desc = "Move if not less or equal (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x4F }, .oplen = 2,
	} } },
	{ "cmovno", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNO r16, r/m16", .orig_opcode = "0F 41 /r",
		.desc = "Move if not overflow (OF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x41 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNO r16, r/m16", .orig_opcode = "0F 41 /r",
		.desc = "Move if not overflow (OF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x41 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNO r32, r/m32", .orig_opcode = "0F 41 /r",
		.desc = "Move if not overflow (OF=0).",
		.opcode = { 0x0F, 0x41 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNO r32, r/m32", .orig_opcode = "0F 41 /r",
		.desc = "Move if not overflow (OF=0).",
		.opcode = { 0x0F, 0x41 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNO r64, r/m64", .orig_opcode = "REX.W+ 0F 41 /r",
		.desc = "Move if not overflow (OF=0).",
		.opcode = { 0x0F, 0x41 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNO r64, r/m64", .orig_opcode = "REX.W+ 0F 41 /r",
		.desc = "Move if not overflow (OF=0).",
		.opcode = { 0x0F, 0x41 }, .oplen = 2,
	} } },
	{ "cmovnp", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNP r16, r/m16", .orig_opcode = "0F 4B /r",
		.desc = "Move if not parity (PF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNP r16, r/m16", .orig_opcode = "0F 4B /r",
		.desc = "Move if not parity (PF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNP r32, r/m32", .orig_opcode = "0F 4B /r",
		.desc = "Move if not parity (PF=0).",
		.opcode = { 0x0F, 0x4B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNP r32, r/m32", .orig_opcode = "0F 4B /r",
		.desc = "Move if not parity (PF=0).",
		.opcode = { 0x0F, 0x4B }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNP r64, r/m64", .orig_opcode = "REX.W+ 0F 4B /r",
		.desc = "Move if not parity (PF=0).",
		.opcode = { 0x0F, 0x4B }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNP r64, r/m64", .orig_opcode = "REX.W+ 0F 4B /r",
		.desc = "Move if not parity (PF=0).",
		.opcode = { 0x0F, 0x4B }, .oplen = 2,
	} } },
	{ "cmovns", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNS r16, r/m16", .orig_opcode = "0F 49 /r",
		.desc = "Move if not sign (SF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x49 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNS r16, r/m16", .orig_opcode = "0F 49 /r",
		.desc = "Move if not sign (SF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x49 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNS r32, r/m32", .orig_opcode = "0F 49 /r",
		.desc = "Move if not sign (SF=0).",
		.opcode = { 0x0F, 0x49 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNS r32, r/m32", .orig_opcode = "0F 49 /r",
		.desc = "Move if not sign (SF=0).",
		.opcode = { 0x0F, 0x49 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNS r64, r/m64", .orig_opcode = "REX.W+ 0F 49 /r",
		.desc = "Move if not sign (SF=0).",
		.opcode = { 0x0F, 0x49 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNS r64, r/m64", .orig_opcode = "REX.W+ 0F 49 /r",
		.desc = "Move if not sign (SF=0).",
		.opcode = { 0x0F, 0x49 }, .oplen = 2,
	} } },
	{ "cmovnz", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNZ r16, r/m16", .orig_opcode = "0F 45 /r",
		.desc = "Move if not zero (ZF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x45 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNZ r16, r/m16", .orig_opcode = "0F 45 /r",
		.desc = "Move if not zero (ZF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x45 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNZ r32, r/m32", .orig_opcode = "0F 45 /r",
		.desc = "Move if not zero (ZF=0).",
		.opcode = { 0x0F, 0x45 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNZ r32, r/m32", .orig_opcode = "0F 45 /r",
		.desc = "Move if not zero (ZF=0).",
		.opcode = { 0x0F, 0x45 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNZ r64, r/m64", .orig_opcode = "REX.W+ 0F 45 /r",
		.desc = "Move if not zero (ZF=0).",
		.opcode = { 0x0F, 0x45 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVNZ r64, r/m64", .orig_opcode = "REX.W+ 0F 45 /r",
		.desc = "Move if not zero (ZF=0).",
		.opcode = { 0x0F, 0x45 }, .oplen = 2,
	} } },
	{ "cmovo", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVO r16, r/m16", .orig_opcode = "0F 40 /r",
		.desc = "Move if overflow (OF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x40 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVO r16, r/m16", .orig_opcode = "0F 40 /r",
		.desc = "Move if overflow (OF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x40 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVO r32, r/m32", .orig_opcode = "0F 40 /r",
		.desc = "Move if overflow (OF=1).",
		.opcode = { 0x0F, 0x40 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVO r32, r/m32", .orig_opcode = "0F 40 /r",
		.desc = "Move if overflow (OF=1).",
		.opcode = { 0x0F, 0x40 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVO r64, r/m64", .orig_opcode = "REX.W+ 0F 40 /r",
		.desc = "Move if overflow (OF=1).",
		.opcode = { 0x0F, 0x40 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVO r64, r/m64", .orig_opcode = "REX.W+ 0F 40 /r",
		.desc = "Move if overflow (OF=1).",
		.opcode = { 0x0F, 0x40 }, .oplen = 2,
	} } },
	{ "cmovp", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVP r16, r/m16", .orig_opcode = "0F 4A /r",
		.desc = "Move if parity (PF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVP r16, r/m16", .orig_opcode = "0F 4A /r",
		.desc = "Move if parity (PF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVP r32, r/m32", .orig_opcode = "0F 4A /r",
		.desc = "Move if parity (PF=1).",
		.opcode = { 0x0F, 0x4A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVP r32, r/m32", .orig_opcode = "0F 4A /r",
		.desc = "Move if parity (PF=1).",
		.opcode = { 0x0F, 0x4A }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVP r64, r/m64", .orig_opcode = "REX.W+ 0F 4A /r",
		.desc = "Move if parity (PF=1).",
		.opcode = { 0x0F, 0x4A }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVP r64, r/m64", .orig_opcode = "REX.W+ 0F 4A /r",
		.desc = "Move if parity (PF=1).",
		.opcode = { 0x0F, 0x4A }, .oplen = 2,
	} } },
	{ "cmovpe", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPE r16, r/m16", .orig_opcode = "0F 4A /r",
		.desc = "Move if parity even (PF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPE r16, r/m16", .orig_opcode = "0F 4A /r",
		.desc = "Move if parity even (PF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPE r32, r/m32", .orig_opcode = "0F 4A /r",
		.desc = "Move if parity even (PF=1).",
		.opcode = { 0x0F, 0x4A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPE r32, r/m32", .orig_opcode = "0F 4A /r",
		.desc = "Move if parity even (PF=1).",
		.opcode = { 0x0F, 0x4A }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPE r64, r/m64", .orig_opcode = "REX.W+ 0F 4A /r",
		.desc = "Move if parity even (PF=1).",
		.opcode = { 0x0F, 0x4A }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPE r64, r/m64", .orig_opcode = "REX.W+ 0F 4A /r",
		.desc = "Move if parity even (PF=1).",
		.opcode = { 0x0F, 0x4A }, .oplen = 2,
	} } },
	{ "cmovpo", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPO r16, r/m16", .orig_opcode = "0F 4B /r",
		.desc = "Move if parity odd (PF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPO r16, r/m16", .orig_opcode = "0F 4B /r",
		.desc = "Move if parity odd (PF=0).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x4B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPO r32, r/m32", .orig_opcode = "0F 4B /r",
		.desc = "Move if parity odd (PF=0).",
		.opcode = { 0x0F, 0x4B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPO r32, r/m32", .orig_opcode = "0F 4B /r",
		.desc = "Move if parity odd (PF=0).",
		.opcode = { 0x0F, 0x4B }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPO r64, r/m64", .orig_opcode = "REX.W+ 0F 4B /r",
		.desc = "Move if parity odd (PF=0).",
		.opcode = { 0x0F, 0x4B }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVPO r64, r/m64", .orig_opcode = "REX.W+ 0F 4B /r",
		.desc = "Move if parity odd (PF=0).",
		.opcode = { 0x0F, 0x4B }, .oplen = 2,
	} } },
	{ "cmovs", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVS r16, r/m16", .orig_opcode = "0F 48 /r",
		.desc = "Move if sign (SF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x48 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVS r16, r/m16", .orig_opcode = "0F 48 /r",
		.desc = "Move if sign (SF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x48 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVS r32, r/m32", .orig_opcode = "0F 48 /r",
		.desc = "Move if sign (SF=1).",
		.opcode = { 0x0F, 0x48 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVS r32, r/m32", .orig_opcode = "0F 48 /r",
		.desc = "Move if sign (SF=1).",
		.opcode = { 0x0F, 0x48 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVS r64, r/m64", .orig_opcode = "REX.W+ 0F 48 /r",
		.desc = "Move if sign (SF=1).",
		.opcode = { 0x0F, 0x48 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVS r64, r/m64", .orig_opcode = "REX.W+ 0F 48 /r",
		.desc = "Move if sign (SF=1).",
		.opcode = { 0x0F, 0x48 }, .oplen = 2,
	} } },
	{ "cmovz", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVZ r16, r/m16", .orig_opcode = "0F 44 /r",
		.desc = "Move if zero (ZF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x44 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVZ r16, r/m16", .orig_opcode = "0F 44 /r",
		.desc = "Move if zero (ZF=1).",
		.prefixes = 0x66, .opcode = { 0x0F, 0x44 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVZ r32, r/m32", .orig_opcode = "0F 44 /r",
		.desc = "Move if zero (ZF=1).",
		.opcode = { 0x0F, 0x44 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVZ r32, r/m32", .orig_opcode = "0F 44 /r",
		.desc = "Move if zero (ZF=1).",
		.opcode = { 0x0F, 0x44 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVZ r64, r/m64", .orig_opcode = "REX.W+ 0F 44 /r",
		.desc = "Move if zero (ZF=1).",
		.opcode = { 0x0F, 0x44 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMOVZ r64, r/m64", .orig_opcode = "REX.W+ 0F 44 /r",
		.desc = "Move if zero (ZF=1).",
		.opcode = { 0x0F, 0x44 }, .oplen = 2,
	} } },
	{ "cmp", 38, (struct x64LookupActualIns[]) { {
		.args = { AL, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "CMP AL, imm8", .orig_opcode = "3C ib",
		.desc = "Compare imm8 with AL.",
		.opcode = { 0x3C }, .oplen = 1,
	}, {
		.args = { AX, IMM16 }, .arglen = 2, .immediate = 2,
		.orig_ins = "CMP AX, imm16", .orig_opcode = "3D iw",
		.desc = "Compare imm16 with AX.",
		.prefixes = 0x66, .opcode = { 0x3D }, .oplen = 1,
	}, {
		.args = { EAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "CMP EAX, imm32", .orig_opcode = "3D id",
		.desc = "Compare imm32 with EAX.",
		.opcode = { 0x3D }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "CMP RAX, imm32", .orig_opcode = "REX.W+ 3D id",
		.desc = "Compare imm32 sign-extended to 64-bits with RAX.",
		.opcode = { 0x3D }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m8, imm8", .orig_opcode = "80 /7 ib",
		.desc = "Compare imm8 with r/m8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m8, imm8", .orig_opcode = "80 /7 ib",
		.desc = "Compare imm8 with r/m8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m16, imm16", .orig_opcode = "81 /7 iw",
		.desc = "Compare imm16 with r/m16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m16, imm16", .orig_opcode = "81 /7 iw",
		.desc = "Compare imm16 with r/m16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m32, imm32", .orig_opcode = "81 /7 id",
		.desc = "Compare imm32 with r/m32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m32, imm32", .orig_opcode = "81 /7 id",
		.desc = "Compare imm32 with r/m32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { M64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m64, imm32", .orig_opcode = "REX.W+ 81 /7 id",
		.desc = "Compare imm32 sign-extended to 64-bits with r/m64.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { R64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m64, imm32", .orig_opcode = "REX.W+ 81 /7 id",
		.desc = "Compare imm32 sign-extended to 64-bits with r/m64.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m16, imm8", .orig_opcode = "83 /7 ib",
		.desc = "Compare imm8 with r/m16.",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m16, imm8", .orig_opcode = "83 /7 ib",
		.desc = "Compare imm8 with r/m16.",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m32, imm8", .orig_opcode = "83 /7 ib",
		.desc = "Compare imm8 with r/m32.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m32, imm8", .orig_opcode = "83 /7 ib",
		.desc = "Compare imm8 with r/m32.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m64, imm8", .orig_opcode = "REX.W+ 83 /7 ib",
		.desc = "Compare imm8 with r/m64.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "CMP r/m64, imm8", .orig_opcode = "REX.W+ 83 /7 ib",
		.desc = "Compare imm8 with r/m64.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMP r/m8, r8", .orig_opcode = "38 /r",
		.desc = "Compare r8 with r/m8.",
		.opcode = { 0x38 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMP r/m8, r8", .orig_opcode = "38 /r",
		.desc = "Compare r8 with r/m8.",
		.opcode = { 0x38 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMP r/m8, r8", .orig_opcode = "38 /r",
		.desc = "Compare r8 with r/m8.",
		.opcode = { 0x38 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMP r/m8, r8", .orig_opcode = "38 /r",
		.desc = "Compare r8 with r/m8.",
		.opcode = { 0x38 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMP r/m16, r16", .orig_opcode = "39 /r",
		.desc = "Compare r16 with r/m16.",
		.prefixes = 0x66, .opcode = { 0x39 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMP r/m16, r16", .orig_opcode = "39 /r",
		.desc = "Compare r16 with r/m16.",
		.prefixes = 0x66, .opcode = { 0x39 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMP r/m32, r32", .orig_opcode = "39 /r",
		.desc = "Compare r32 with r/m32.",
		.opcode = { 0x39 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMP r/m32, r32", .orig_opcode = "39 /r",
		.desc = "Compare r32 with r/m32.",
		.opcode = { 0x39 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMP r/m64, r64", .orig_opcode = "REX.W+ 39 /r",
		.desc = "Compare r64 with r/m64.",
		.opcode = { 0x39 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMP r/m64, r64", .orig_opcode = "REX.W+ 39 /r",
		.desc = "Compare r64 with r/m64.",
		.opcode = { 0x39 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMP r8, r/m8", .orig_opcode = "3A /r",
		.desc = "Compare r/m8 with r8.",
		.opcode = { 0x3A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMP r8, r/m8", .orig_opcode = "3A /r",
		.desc = "Compare r/m8 with r8.",
		.opcode = { 0x3A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMP r8, r/m8", .orig_opcode = "3A /r",
		.desc = "Compare r/m8 with r8.",
		.opcode = { 0x3A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMP r8, r/m8", .orig_opcode = "3A /r",
		.desc = "Compare r/m8 with r8.",
		.opcode = { 0x3A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMP r16, r/m16", .orig_opcode = "3B /r",
		.desc = "Compare r/m16 with r16.",
		.prefixes = 0x66, .opcode = { 0x3B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMP r16, r/m16", .orig_opcode = "3B /r",
		.desc = "Compare r/m16 with r16.",
		.prefixes = 0x66, .opcode = { 0x3B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMP r32, r/m32", .orig_opcode = "3B /r",
		.desc = "Compare r/m32 with r32.",
		.opcode = { 0x3B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMP r32, r/m32", .orig_opcode = "3B /r",
		.desc = "Compare r/m32 with r32.",
		.opcode = { 0x3B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMP r64, r/m64", .orig_opcode = "REX.W+ 3B /r",
		.desc = "Compare r/m64 with r64.",
		.opcode = { 0x3B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMP r64, r/m64", .orig_opcode = "REX.W+ 3B /r",
		.desc = "Compare r/m64 with r64.",
		.opcode = { 0x3B }, .oplen = 1,
	} } },
	{ "cmppd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMPPD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F C2 /r ib",
		.desc = "Compare packed double-precision floating- point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMPPD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F C2 /r ib",
		.desc = "Compare packed double-precision floating- point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC2 }, .oplen = 2,
	} } },
	{ "cmpps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMPPS xmm1, xmm2/m128, imm8", .orig_opcode = "0F C2 /r ib",
		.desc = "Compare packed single-precision floating- point values in xmm2/mem and xmm1 using imm8 as comparison predicate.",
		.opcode = { 0x0F, 0xC2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMPPS xmm1, xmm2/m128, imm8", .orig_opcode = "0F C2 /r ib",
		.desc = "Compare packed single-precision floating- point values in xmm2/mem and xmm1 using imm8 as comparison predicate.",
		.opcode = { 0x0F, 0xC2 }, .oplen = 2,
	} } },
	{ "cmps", 4, (struct x64LookupActualIns[]) { {
		.args = { M8, M8 }, .arglen = 2,
		.orig_ins = "CMPS m8, m8", .orig_opcode = "A6",
		.desc = "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly.",
		.opcode = { 0xA6 }, .oplen = 1,
	}, {
		.args = { M128, M128 }, .arglen = 2,
		.orig_ins = "CMPS m16, m16", .orig_opcode = "A7",
		.desc = "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly.",
		.opcode = { 0xA7 }, .oplen = 1,
	}, {
		.args = { M32, M32 }, .arglen = 2,
		.orig_ins = "CMPS m32, m32", .orig_opcode = "A7",
		.desc = "For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly.",
		.opcode = { 0xA7 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { M64, M64 }, .arglen = 2,
		.orig_ins = "CMPS m64, m64", .orig_opcode = "REX.W+ A7",
		.desc = "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.",
		.opcode = { 0xA7 }, .oplen = 1,
	} } },
	{ "cmpsb", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CMPSB", .orig_opcode = "A6",
		.desc = "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64- bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly.",
		.opcode = { 0xA6 }, .oplen = 1,
	} } },
	{ "cmpsw", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CMPSW", .orig_opcode = "PREF.66+ A7",
		.desc = "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64- bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly.",
		.prefixes = 0x66, .opcode = { 0xA7 }, .oplen = 1,
	} } },
	{ "cmpsd", 3, (struct x64LookupActualIns[]) { {
		.orig_ins = "CMPSD", .orig_opcode = "A7",
		.desc = "For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly.",
		.opcode = { 0xA7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMPSD xmm1, xmm2/m64, imm8", .orig_opcode = "F2 0F C2 /r ib",
		.desc = "Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0xC2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMPSD xmm1, xmm2/m64, imm8", .orig_opcode = "F2 0F C2 /r ib",
		.desc = "Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0xC2 }, .oplen = 2,
	} } },
	{ "cmpsq", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, 
		.orig_ins = "CMPSQ", .orig_opcode = "REX.W+ A7",
		.desc = "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.",
		.opcode = { 0xA7 }, .oplen = 1,
	} } },
	{ "cmpss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMPSS xmm1, xmm2/m32, imm8", .orig_opcode = "F3 0F C2 /r ib",
		.desc = "Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xC2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CMPSS xmm1, xmm2/m32, imm8", .orig_opcode = "F3 0F C2 /r ib",
		.desc = "Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xC2 }, .oplen = 2,
	} } },
	{ "cmpxchg", 10, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMPXCHG r/m8, r8", .orig_opcode = "0F B0 /r",
		.desc = "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.",
		.opcode = { 0x0F, 0xB0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMPXCHG r/m8, r8", .orig_opcode = "0F B0 /r",
		.desc = "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.",
		.opcode = { 0x0F, 0xB0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMPXCHG r/m8, r8", .orig_opcode = "0F B0 /r",
		.desc = "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.",
		.opcode = { 0x0F, 0xB0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMPXCHG r/m8, r8", .orig_opcode = "0F B0 /r",
		.desc = "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.",
		.opcode = { 0x0F, 0xB0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMPXCHG r/m16, r16", .orig_opcode = "0F B1 /r",
		.desc = "Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xB1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMPXCHG r/m16, r16", .orig_opcode = "0F B1 /r",
		.desc = "Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xB1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMPXCHG r/m32, r32", .orig_opcode = "0F B1 /r",
		.desc = "Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX.",
		.opcode = { 0x0F, 0xB1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMPXCHG r/m32, r32", .orig_opcode = "0F B1 /r",
		.desc = "Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX.",
		.opcode = { 0x0F, 0xB1 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMPXCHG r/m64, r64", .orig_opcode = "REX.W+ 0F B1 /r",
		.desc = "Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX.",
		.opcode = { 0x0F, 0xB1 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "CMPXCHG r/m64, r64", .orig_opcode = "REX.W+ 0F B1 /r",
		.desc = "Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX.",
		.opcode = { 0x0F, 0xB1 }, .oplen = 2,
	} } },
	{ "cmpxchg8b", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "CMPXCHG8B m64", .orig_opcode = "0F C7 /1",
		.desc = "Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX.",
		.opcode = { 0x0F, 0xC7 }, .oplen = 2,
	} } },
	{ "cmpxchg16b", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "CMPXCHG16B m128", .orig_opcode = "REX.W+ 0F C7 /1",
		.desc = "Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX.",
		.opcode = { 0x0F, 0xC7 }, .oplen = 2,
	} } },
	{ "comisd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "COMISD xmm1, xmm2/m64", .orig_opcode = "66 0F 2F /r",
		.desc = "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "COMISD xmm1, xmm2/m64", .orig_opcode = "66 0F 2F /r",
		.desc = "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2F }, .oplen = 2,
	} } },
	{ "comiss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "COMISS xmm1, xmm2/m32", .orig_opcode = "0F 2F /r",
		.desc = "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.",
		.opcode = { 0x0F, 0x2F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "COMISS xmm1, xmm2/m32", .orig_opcode = "0F 2F /r",
		.desc = "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.",
		.opcode = { 0x0F, 0x2F }, .oplen = 2,
	} } },
	{ "cpuid", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CPUID", .orig_opcode = "0F A2",
		.desc = "Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).",
		.opcode = { 0x0F, 0xA2 }, .oplen = 2,
	} } },
	{ "crc32", 10, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CRC32 r32, r/m8", .orig_opcode = "F2 0F 38 F0 /r",
		.desc = "Accumulate CRC32 on r/m8.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x38, 0xF0 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CRC32 r32, r/m8", .orig_opcode = "F2 0F 38 F0 /r",
		.desc = "Accumulate CRC32 on r/m8.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x38, 0xF0 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CRC32 r32, r/m16", .orig_opcode = "F2 0F 38 F1 /r",
		.desc = "Accumulate CRC32 on r/m16.",
		.prefixes = 0x66F2, .opcode = { 0x0F, 0x38, 0xF1 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CRC32 r32, r/m16", .orig_opcode = "F2 0F 38 F1 /r",
		.desc = "Accumulate CRC32 on r/m16.",
		.prefixes = 0x66F2, .opcode = { 0x0F, 0x38, 0xF1 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CRC32 r32, r/m32", .orig_opcode = "F2 0F 38 F1 /r",
		.desc = "Accumulate CRC32 on r/m32.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x38, 0xF1 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CRC32 r32, r/m32", .orig_opcode = "F2 0F 38 F1 /r",
		.desc = "Accumulate CRC32 on r/m32.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x38, 0xF1 }, .oplen = 3,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CRC32 r64, r/m8", .orig_opcode = "F2 REX.W+ 0F 38 F0 /r",
		.desc = "Accumulate CRC32 on r/m8.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x38, 0xF0 }, .oplen = 3,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CRC32 r64, r/m8", .orig_opcode = "F2 REX.W+ 0F 38 F0 /r",
		.desc = "Accumulate CRC32 on r/m8.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x38, 0xF0 }, .oplen = 3,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CRC32 r64, r/m64", .orig_opcode = "F2 REX.W+ 0F 38 F1 /r",
		.desc = "Accumulate CRC32 on r/m64.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x38, 0xF1 }, .oplen = 3,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CRC32 r64, r/m64", .orig_opcode = "F2 REX.W+ 0F 38 F1 /r",
		.desc = "Accumulate CRC32 on r/m64.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x38, 0xF1 }, .oplen = 3,
	} } },
	{ "cvtdq2pd", 2, (struct x64LookupActualIns[]) { {
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTDQ2PD xmm1, xmm2/m64", .orig_opcode = "F3 0F E6",
		.desc = "Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xE6 }, .oplen = 2,
	}, {
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTDQ2PD xmm1, xmm2/m64", .orig_opcode = "F3 0F E6",
		.desc = "Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xE6 }, .oplen = 2,
	} } },
	{ "cvtdq2ps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTDQ2PS xmm1, xmm2/m128", .orig_opcode = "0F 5B /r",
		.desc = "Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.",
		.opcode = { 0x0F, 0x5B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTDQ2PS xmm1, xmm2/m128", .orig_opcode = "0F 5B /r",
		.desc = "Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.",
		.opcode = { 0x0F, 0x5B }, .oplen = 2,
	} } },
	{ "cvtpd2dq", 2, (struct x64LookupActualIns[]) { {
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPD2DQ xmm1, xmm2/m128", .orig_opcode = "F2 0F E6",
		.desc = "Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0xE6 }, .oplen = 2,
	}, {
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPD2DQ xmm1, xmm2/m128", .orig_opcode = "F2 0F E6",
		.desc = "Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0xE6 }, .oplen = 2,
	} } },
	{ "cvtpd2pi", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPD2PI mm, xmm/m128", .orig_opcode = "66 0F 2D /r",
		.desc = "Convert two packed double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPD2PI mm, xmm/m128", .orig_opcode = "66 0F 2D /r",
		.desc = "Convert two packed double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2D }, .oplen = 2,
	} } },
	{ "cvtpd2ps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPD2PS xmm1, xmm2/m128", .orig_opcode = "66 0F 5A /r",
		.desc = "Convert two packed double-precision floating- point values in xmm2/m128 to two packed single-precision floating-point values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPD2PS xmm1, xmm2/m128", .orig_opcode = "66 0F 5A /r",
		.desc = "Convert two packed double-precision floating- point values in xmm2/m128 to two packed single-precision floating-point values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5A }, .oplen = 2,
	} } },
	{ "cvtpi2pd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPI2PD xmm, mm/m64", .orig_opcode = "66 0F 2A /r",
		.desc = "Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPI2PD xmm, mm/m64", .orig_opcode = "66 0F 2A /r",
		.desc = "Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2A }, .oplen = 2,
	} } },
	{ "cvtpi2ps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPI2PS xmm, mm/m64", .orig_opcode = "0F 2A /r",
		.desc = "Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm.",
		.opcode = { 0x0F, 0x2A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPI2PS xmm, mm/m64", .orig_opcode = "0F 2A /r",
		.desc = "Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm.",
		.opcode = { 0x0F, 0x2A }, .oplen = 2,
	} } },
	{ "cvtps2dq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPS2DQ xmm1, xmm2/m128", .orig_opcode = "66 0F 5B /r",
		.desc = "Convert four packed single-precision floating- point values from xmm2/m128 to four packed signed doubleword integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPS2DQ xmm1, xmm2/m128", .orig_opcode = "66 0F 5B /r",
		.desc = "Convert four packed single-precision floating- point values from xmm2/m128 to four packed signed doubleword integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5B }, .oplen = 2,
	} } },
	{ "cvtps2pd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPS2PD xmm1, xmm2/m64", .orig_opcode = "0F 5A /r",
		.desc = "Convert two packed single-precision floating- point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.",
		.opcode = { 0x0F, 0x5A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPS2PD xmm1, xmm2/m64", .orig_opcode = "0F 5A /r",
		.desc = "Convert two packed single-precision floating- point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.",
		.opcode = { 0x0F, 0x5A }, .oplen = 2,
	} } },
	{ "cvtps2pi", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPS2PI mm, xmm/m64", .orig_opcode = "0F 2D /r",
		.desc = "Convert two packed single-precision floating- point values from xmm/m64 to two packed signed doubleword integers in mm.",
		.opcode = { 0x0F, 0x2D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTPS2PI mm, xmm/m64", .orig_opcode = "0F 2D /r",
		.desc = "Convert two packed single-precision floating- point values from xmm/m64 to two packed signed doubleword integers in mm.",
		.opcode = { 0x0F, 0x2D }, .oplen = 2,
	} } },
	{ "cvtsd2si", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSD2SI r32, xmm/m64", .orig_opcode = "F2 0F 2D /r",
		.desc = "Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSD2SI r32, xmm/m64", .orig_opcode = "F2 0F 2D /r",
		.desc = "Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2D }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSD2SI r64, xmm/m64", .orig_opcode = "F2 REX.W+ 0F 2D /r",
		.desc = "Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2D }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSD2SI r64, xmm/m64", .orig_opcode = "F2 REX.W+ 0F 2D /r",
		.desc = "Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2D }, .oplen = 2,
	} } },
	{ "cvtsd2ss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSD2SS xmm1, xmm2/m64", .orig_opcode = "F2 0F 5A /r",
		.desc = "Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x5A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSD2SS xmm1, xmm2/m64", .orig_opcode = "F2 0F 5A /r",
		.desc = "Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x5A }, .oplen = 2,
	} } },
	{ "cvtsi2sd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSI2SD xmm, r/m32", .orig_opcode = "F2 0F 2A /r",
		.desc = "Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSI2SD xmm, r/m32", .orig_opcode = "F2 0F 2A /r",
		.desc = "Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2A }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSI2SD xmm, r/m64", .orig_opcode = "F2 REX.W+ 0F 2A /r",
		.desc = "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2A }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { XMM, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSI2SD xmm, r/m64", .orig_opcode = "F2 REX.W+ 0F 2A /r",
		.desc = "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2A }, .oplen = 2,
	} } },
	{ "cvtsi2ss", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSI2SS xmm, r/m32", .orig_opcode = "F3 0F 2A /r",
		.desc = "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSI2SS xmm, r/m32", .orig_opcode = "F3 0F 2A /r",
		.desc = "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2A }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSI2SS xmm, r/m64", .orig_opcode = "F3 REX.W+ 0F 2A /r",
		.desc = "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2A }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { XMM, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSI2SS xmm, r/m64", .orig_opcode = "F3 REX.W+ 0F 2A /r",
		.desc = "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2A }, .oplen = 2,
	} } },
	{ "cvtss2sd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSS2SD xmm1, xmm2/m32", .orig_opcode = "F3 0F 5A /r",
		.desc = "Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSS2SD xmm1, xmm2/m32", .orig_opcode = "F3 0F 5A /r",
		.desc = "Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5A }, .oplen = 2,
	} } },
	{ "cvtss2si", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSS2SI r32, xmm/m32", .orig_opcode = "F3 0F 2D /r",
		.desc = "Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSS2SI r32, xmm/m32", .orig_opcode = "F3 0F 2D /r",
		.desc = "Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2D }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSS2SI r64, xmm/m32", .orig_opcode = "F3 REX.W+ 0F 2D /r",
		.desc = "Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2D }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTSS2SI r64, xmm/m32", .orig_opcode = "F3 REX.W+ 0F 2D /r",
		.desc = "Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2D }, .oplen = 2,
	} } },
	{ "cvttpd2dq", 2, (struct x64LookupActualIns[]) { {
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTPD2DQ xmm1, xmm2/m128", .orig_opcode = "66 0F E6",
		.desc = "Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE6 }, .oplen = 2,
	}, {
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTPD2DQ xmm1, xmm2/m128", .orig_opcode = "66 0F E6",
		.desc = "Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE6 }, .oplen = 2,
	} } },
	{ "cvttpd2pi", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTPD2PI mm, xmm/m128", .orig_opcode = "66 0F 2C /r",
		.desc = "Convert two packer double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm using truncation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTPD2PI mm, xmm/m128", .orig_opcode = "66 0F 2C /r",
		.desc = "Convert two packer double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm using truncation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2C }, .oplen = 2,
	} } },
	{ "cvttps2dq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTPS2DQ xmm1, xmm2/m128", .orig_opcode = "F3 0F 5B /r",
		.desc = "Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTPS2DQ xmm1, xmm2/m128", .orig_opcode = "F3 0F 5B /r",
		.desc = "Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5B }, .oplen = 2,
	} } },
	{ "cvttps2pi", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTPS2PI mm, xmm/m64", .orig_opcode = "0F 2C /r",
		.desc = "Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation.",
		.opcode = { 0x0F, 0x2C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTPS2PI mm, xmm/m64", .orig_opcode = "0F 2C /r",
		.desc = "Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation.",
		.opcode = { 0x0F, 0x2C }, .oplen = 2,
	} } },
	{ "cvttsd2si", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTSD2SI r32, xmm/m64", .orig_opcode = "F2 0F 2C /r",
		.desc = "Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTSD2SI r32, xmm/m64", .orig_opcode = "F2 0F 2C /r",
		.desc = "Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2C }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTSD2SI r64, xmm/m64", .orig_opcode = "F2 REX.W+ 0F 2C /r",
		.desc = "Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2C }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTSD2SI r64, xmm/m64", .orig_opcode = "F2 REX.W+ 0F 2C /r",
		.desc = "Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x2C }, .oplen = 2,
	} } },
	{ "cvttss2si", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTSS2SI r32, xmm/m32", .orig_opcode = "F3 0F 2C /r",
		.desc = "Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTSS2SI r32, xmm/m32", .orig_opcode = "F3 0F 2C /r",
		.desc = "Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2C }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTSS2SI r64, xmm/m32", .orig_opcode = "F3 REX.W+ 0F 2C /r",
		.desc = "Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2C }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "CVTTSS2SI r64, xmm/m32", .orig_opcode = "F3 REX.W+ 0F 2C /r",
		.desc = "Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x2C }, .oplen = 2,
	} } },
	{ "cwd", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CWD", .orig_opcode = "PREF.66+ 99",
		.desc = "DX:AX = sign-extend of AX.",
		.prefixes = 0x66, .opcode = { 0x99 }, .oplen = 1,
	} } },
	{ "cdq", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "CDQ", .orig_opcode = "99",
		.desc = "EDX:EAX = sign-extend of EAX.",
		.opcode = { 0x99 }, .oplen = 1,
	} } },
	{ "cqo", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, 
		.orig_ins = "CQO", .orig_opcode = "REX.W+ 99",
		.desc = "RDX:RAX = sign-extend of RAX.",
		.opcode = { 0x99 }, .oplen = 1,
	} } },
	{ "dec", 8, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DEC r/m8", .orig_opcode = "FE /1",
		.desc = "Decrement r/m8 by 1.",
		.opcode = { 0xFE }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DEC r/m8", .orig_opcode = "FE /1",
		.desc = "Decrement r/m8 by 1.",
		.opcode = { 0xFE }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DEC r/m16", .orig_opcode = "FF /1",
		.desc = "Decrement r/m16 by 1.",
		.prefixes = 0x66, .opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DEC r/m16", .orig_opcode = "FF /1",
		.desc = "Decrement r/m16 by 1.",
		.prefixes = 0x66, .opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DEC r/m32", .orig_opcode = "FF /1",
		.desc = "Decrement r/m32 by 1.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DEC r/m32", .orig_opcode = "FF /1",
		.desc = "Decrement r/m32 by 1.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DEC r/m64", .orig_opcode = "REX.W+ FF /1",
		.desc = "Decrement r/m64 by 1.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DEC r/m64", .orig_opcode = "REX.W+ FF /1",
		.desc = "Decrement r/m64 by 1.",
		.opcode = { 0xFF }, .oplen = 1,
	} } },
	{ "div", 8, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DIV r/m8", .orig_opcode = "F6 /6",
		.desc = "Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DIV r/m8", .orig_opcode = "F6 /6",
		.desc = "Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DIV r/m16", .orig_opcode = "F7 /6",
		.desc = "Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DIV r/m16", .orig_opcode = "F7 /6",
		.desc = "Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DIV r/m32", .orig_opcode = "F7 /6",
		.desc = "Unsigned divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DIV r/m32", .orig_opcode = "F7 /6",
		.desc = "Unsigned divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DIV r/m64", .orig_opcode = "REX.W+ F7 /6",
		.desc = "Unsigned divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "DIV r/m64", .orig_opcode = "REX.W+ F7 /6",
		.desc = "Unsigned divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.",
		.opcode = { 0xF7 }, .oplen = 1,
	} } },
	{ "divpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DIVPD xmm1, xmm2/m128", .orig_opcode = "66 0F 5E /r",
		.desc = "Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DIVPD xmm1, xmm2/m128", .orig_opcode = "66 0F 5E /r",
		.desc = "Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5E }, .oplen = 2,
	} } },
	{ "divps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DIVPS xmm1, xmm2/m128", .orig_opcode = "0F 5E /r",
		.desc = "Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.",
		.opcode = { 0x0F, 0x5E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DIVPS xmm1, xmm2/m128", .orig_opcode = "0F 5E /r",
		.desc = "Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.",
		.opcode = { 0x0F, 0x5E }, .oplen = 2,
	} } },
	{ "divsd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DIVSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 5E /r",
		.desc = "Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x5E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DIVSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 5E /r",
		.desc = "Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x5E }, .oplen = 2,
	} } },
	{ "divss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DIVSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 5E /r",
		.desc = "Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DIVSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 5E /r",
		.desc = "Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5E }, .oplen = 2,
	} } },
	{ "dppd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DPPD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 41 /r ib",
		.desc = "Selectively multiply packed DP floating-point values from xmm1 with packed DP floating- point values from xmm2, add and selectively store the packed DP floating-point values to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x41 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DPPD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 41 /r ib",
		.desc = "Selectively multiply packed DP floating-point values from xmm1 with packed DP floating- point values from xmm2, add and selectively store the packed DP floating-point values to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x41 }, .oplen = 3,
	} } },
	{ "dpps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DPPS xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 40 /r ib",
		.desc = "Selectively multiply packed SP floating-point values from xmm1 with packed SP floating- point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x40 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "DPPS xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 40 /r ib",
		.desc = "Selectively multiply packed SP floating-point values from xmm1 with packed SP floating- point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x40 }, .oplen = 3,
	} } },
	{ "emms", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "EMMS", .orig_opcode = "0F 77",
		.desc = "Set the x87 FPU tag word to empty.",
		.opcode = { 0x0F, 0x77 }, .oplen = 2,
	} } },
	{ "enter", 1, (struct x64LookupActualIns[]) { {
		.args = { IMM8, IMM16 }, .arglen = 2, .immediate = 1,
		.orig_ins = "ENTER imm8, imm16", .orig_opcode = "C8 ib iw",
		.desc = "Create a nested stack frame for a procedure.",
		.opcode = { 0xC8 }, .oplen = 1,
	} } },
	{ "extractps", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "EXTRACTPS reg/m32, xmm2, imm8", .orig_opcode = "66 0F 3A 17 /r ib",
		.desc = "Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x17 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "EXTRACTPS reg/m32, xmm2, imm8", .orig_opcode = "66 0F 3A 17 /r ib",
		.desc = "Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x17 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "EXTRACTPS reg/m32, xmm2, imm8", .orig_opcode = "66 0F 3A 17 /r ib",
		.desc = "Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x17 }, .oplen = 3,
	} } },
	{ "f2xm1", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "F2XM1", .orig_opcode = "D9 F0",
		.desc = "Replace ST(0) with (2^(ST(0)) - 1).",
		.opcode = { 0xD9, 0xF0 }, .oplen = 2,
	} } },
	{ "fabs", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FABS", .orig_opcode = "D9 E1",
		.desc = "Replace ST with its absolute value.",
		.opcode = { 0xD9, 0xE1 }, .oplen = 2,
	} } },
	{ "fadd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FADD m32fp", .orig_opcode = "D8 /0",
		.desc = "Add m32fp to ST(0) and store result in ST(0).",
		.opcode = { 0xD8 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FADD m64fp", .orig_opcode = "DC /0",
		.desc = "Add m64fp to ST(0) and store result in ST(0).",
		.opcode = { 0xDC }, .oplen = 1,
	}, {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FADD ST(0), ST(i)", .orig_opcode = "D8 C0 +i",
		.desc = "Add ST(0) to ST(i) and store result in ST(0).",
		.opcode = { 0xD8, 0xC0 }, .oplen = 2,
	}, {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FADD ST(i), ST(0)", .orig_opcode = "DC C0 +i",
		.desc = "Add ST(i) to ST(0) and store result in ST(i).",
		.opcode = { 0xDC, 0xC0 }, .oplen = 2,
	} } },
	{ "faddp", 2, (struct x64LookupActualIns[]) { {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FADDP ST(i), ST(0)", .orig_opcode = "DE C0 +i",
		.desc = "Add ST(0) to ST(i), store result in ST(i), and pop the register stack.",
		.opcode = { 0xDE, 0xC0 }, .oplen = 2,
	}, {
		.orig_ins = "FADDP", .orig_opcode = "DE C1",
		.desc = "Add ST(0) to ST(1), store result in ST(1), and pop the register stack.",
		.opcode = { 0xDE, 0xC1 }, .oplen = 2,
	} } },
	{ "fiadd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FIADD m32int", .orig_opcode = "DA /0",
		.desc = "Add m32int to ST(0) and store result in ST(0).",
		.opcode = { 0xDA }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FIADD m16int", .orig_opcode = "DE /0",
		.desc = "Add m16int to ST(0) and store result in ST(0).",
		.opcode = { 0xDE }, .oplen = 1,
	} } },
	{ "fbld", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FBLD m80bcd", .orig_opcode = "DF /4",
		.desc = "Convert BCD value to floating-point and push onto the FPU stack.",
		.opcode = { 0xDF }, .oplen = 1,
	} } },
	{ "fbstp", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FBSTP m80bcd", .orig_opcode = "DF /6",
		.desc = "Store ST(0) in m80bcd and pop ST(0).",
		.opcode = { 0xDF }, .oplen = 1,
	} } },
	{ "fchs", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FCHS", .orig_opcode = "D9 E0",
		.desc = "Complements sign of ST(0).",
		.opcode = { 0xD9, 0xE0 }, .oplen = 2,
	} } },
	{ "fclex", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FCLEX", .orig_opcode = "9B DB E2",
		.desc = "Clear floating-point exception flags after checking for pending unmasked floating-point exceptions.",
		.prefixes = 0x9B, .opcode = { 0xDB, 0xE2 }, .oplen = 2,
	} } },
	{ "fnclex", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FNCLEX", .orig_opcode = "DB E2",
		.desc = "Clear floating-point exception flags without checking for pending unmasked floating-point exceptions.",
		.opcode = { 0xDB, 0xE2 }, .oplen = 2,
	} } },
	{ "fcmovb", 1, (struct x64LookupActualIns[]) { {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FCMOVB ST(0), ST(i)", .orig_opcode = "DA C0 +i",
		.desc = "Move if below (CF=1).",
		.opcode = { 0xDA, 0xC0 }, .oplen = 2,
	} } },
	{ "fcmove", 1, (struct x64LookupActualIns[]) { {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FCMOVE ST(0), ST(i)", .orig_opcode = "DA C8 +i",
		.desc = "Move if equal (ZF=1).",
		.opcode = { 0xDA, 0xC8 }, .oplen = 2,
	} } },
	{ "fcmovbe", 1, (struct x64LookupActualIns[]) { {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FCMOVBE ST(0), ST(i)", .orig_opcode = "DA D0 +i",
		.desc = "Move if below or equal (CF=1 or ZF=1).",
		.opcode = { 0xDA, 0xD0 }, .oplen = 2,
	} } },
	{ "fcmovu", 1, (struct x64LookupActualIns[]) { {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FCMOVU ST(0), ST(i)", .orig_opcode = "DA D8 +i",
		.desc = "Move if unordered (PF=1).",
		.opcode = { 0xDA, 0xD8 }, .oplen = 2,
	} } },
	{ "fcmovnb", 1, (struct x64LookupActualIns[]) { {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FCMOVNB ST(0), ST(i)", .orig_opcode = "DB C0 +i",
		.desc = "Move if not below (CF=0).",
		.opcode = { 0xDB, 0xC0 }, .oplen = 2,
	} } },
	{ "fcmovne", 1, (struct x64LookupActualIns[]) { {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FCMOVNE ST(0), ST(i)", .orig_opcode = "DB C8 +i",
		.desc = "Move if not equal (ZF=0).",
		.opcode = { 0xDB, 0xC8 }, .oplen = 2,
	} } },
	{ "fcmovnbe", 1, (struct x64LookupActualIns[]) { {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FCMOVNBE ST(0), ST(i)", .orig_opcode = "DB D0 +i",
		.desc = "Move if not below or equal (CF=0 and ZF=0).",
		.opcode = { 0xDB, 0xD0 }, .oplen = 2,
	} } },
	{ "fcmovnu", 1, (struct x64LookupActualIns[]) { {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FCMOVNU ST(0), ST(i)", .orig_opcode = "DB D8 +i",
		.desc = "Move if not unordered (PF=0).",
		.opcode = { 0xDB, 0xD8 }, .oplen = 2,
	} } },
	{ "fcom", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FCOM m32fp", .orig_opcode = "D8 /2",
		.desc = "Compare ST(0) with m32fp.",
		.opcode = { 0xD8 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FCOM m64fp", .orig_opcode = "DC /2",
		.desc = "Compare ST(0) with m64fp.",
		.opcode = { 0xDC }, .oplen = 1,
	}, {
		.args = { ST }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "FCOM ST(i)", .orig_opcode = "D8 D0 +i",
		.desc = "Compare ST(0) with ST(i).",
		.opcode = { 0xD8, 0xD0 }, .oplen = 2,
	}, {
		.orig_ins = "FCOM", .orig_opcode = "D8 D1",
		.desc = "Compare ST(0) with ST(1).",
		.opcode = { 0xD8, 0xD1 }, .oplen = 2,
	} } },
	{ "fcomp", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FCOMP m32fp", .orig_opcode = "D8 /3",
		.desc = "Compare ST(0) with m32fp and pop register stack.",
		.opcode = { 0xD8 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FCOMP m64fp", .orig_opcode = "DC /3",
		.desc = "Compare ST(0) with m64fp and pop register stack.",
		.opcode = { 0xDC }, .oplen = 1,
	}, {
		.args = { ST }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "FCOMP ST(i)", .orig_opcode = "D8 D8 +i",
		.desc = "Compare ST(0) with ST(i) and pop register stack.",
		.opcode = { 0xD8, 0xD8 }, .oplen = 2,
	}, {
		.orig_ins = "FCOMP", .orig_opcode = "D8 D9",
		.desc = "Compare ST(0) with ST(1) and pop register stack.",
		.opcode = { 0xD8, 0xD9 }, .oplen = 2,
	} } },
	{ "fcompp", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FCOMPP", .orig_opcode = "DE D9",
		.desc = "Compare ST(0) with ST(1) and pop register stack twice.",
		.opcode = { 0xDE, 0xD9 }, .oplen = 2,
	} } },
	{ "fcomi", 1, (struct x64LookupActualIns[]) { {
		.args = { ST, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FCOMI ST, ST(i)", .orig_opcode = "DB F0 +i",
		.desc = "Compare ST(0) with ST(i) and set status flags accordingly.",
		.opcode = { 0xDB, 0xF0 }, .oplen = 2,
	} } },
	{ "fcomip", 1, (struct x64LookupActualIns[]) { {
		.args = { ST, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FCOMIP ST, ST(i)", .orig_opcode = "DF F0 +i",
		.desc = "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.",
		.opcode = { 0xDF, 0xF0 }, .oplen = 2,
	} } },
	{ "fucomi", 1, (struct x64LookupActualIns[]) { {
		.args = { ST, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FUCOMI ST, ST(i)", .orig_opcode = "DB E8 +i",
		.desc = "Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly.",
		.opcode = { 0xDB, 0xE8 }, .oplen = 2,
	} } },
	{ "fucomip", 1, (struct x64LookupActualIns[]) { {
		.args = { ST, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FUCOMIP ST, ST(i)", .orig_opcode = "DF E8 +i",
		.desc = "Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack.",
		.opcode = { 0xDF, 0xE8 }, .oplen = 2,
	} } },
	{ "fcos", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FCOS", .orig_opcode = "D9 FF",
		.desc = "Replace ST(0) with its cosine.",
		.opcode = { 0xD9, 0xFF }, .oplen = 2,
	} } },
	{ "fdecstp", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FDECSTP", .orig_opcode = "D9 F6",
		.desc = "Decrement TOP field in FPU status word.",
		.opcode = { 0xD9, 0xF6 }, .oplen = 2,
	} } },
	{ "fdiv", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FDIV m32fp", .orig_opcode = "D8 /6",
		.desc = "Divide ST(0) by m32fp and store result in ST(0).",
		.opcode = { 0xD8 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FDIV m64fp", .orig_opcode = "DC /6",
		.desc = "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.",
		.opcode = { 0xDC }, .oplen = 1,
	}, {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FDIV ST(0), ST(i)", .orig_opcode = "D8 F0 +i",
		.desc = "Divide ST(0) by ST(i) and store result in ST(0).",
		.opcode = { 0xD8, 0xF0 }, .oplen = 2,
	}, {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FDIV ST(i), ST(0)", .orig_opcode = "DC F0 +i",
		.desc = "Divide ST(i) by ST(0) and store result in ST(i).",
		.opcode = { 0xDC, 0xF0 }, .oplen = 2,
	} } },
	{ "fdivp", 2, (struct x64LookupActualIns[]) { {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FDIVP ST(i), ST(0)", .orig_opcode = "DE F0 +i",
		.desc = "Divide ST(i) by ST(0), store result in ST(i), and pop the register stack.",
		.opcode = { 0xDE, 0xF0 }, .oplen = 2,
	}, {
		.orig_ins = "FDIVP", .orig_opcode = "DE F1",
		.desc = "Divide ST(1) by ST(0), store result in ST(1), and pop the register stack.",
		.opcode = { 0xDE, 0xF1 }, .oplen = 2,
	} } },
	{ "fidiv", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FIDIV m32int", .orig_opcode = "DA /6",
		.desc = "Divide ST(0) by m32int and store result in ST(0).",
		.opcode = { 0xDA }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FIDIV m16int", .orig_opcode = "DE /6",
		.desc = "Divide ST(0) by m64int and store result in ST(0).",
		.opcode = { 0xDE }, .oplen = 1,
	} } },
	{ "fdivr", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FDIVR m32fp", .orig_opcode = "D8 /7",
		.desc = "Divide m32fp by ST(0) and store result in ST(0).",
		.opcode = { 0xD8 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FDIVR m64fp", .orig_opcode = "DC /7",
		.desc = "Divide m64fp by ST(0) and store result in ST(0).",
		.opcode = { 0xDC }, .oplen = 1,
	}, {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FDIVR ST(0), ST(i)", .orig_opcode = "D8 F8 +i",
		.desc = "Divide ST(i) by ST(0) and store result in ST(0).",
		.opcode = { 0xD8, 0xF8 }, .oplen = 2,
	}, {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FDIVR ST(i), ST(0)", .orig_opcode = "DC F8 +i",
		.desc = "Divide ST(0) by ST(i) and store result in ST(i).",
		.opcode = { 0xDC, 0xF8 }, .oplen = 2,
	} } },
	{ "fdivrp", 2, (struct x64LookupActualIns[]) { {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FDIVRP ST(i), ST(0)", .orig_opcode = "DE F8 +i",
		.desc = "Divide ST(0) by ST(i), store result in ST(i), and pop the register stack.",
		.opcode = { 0xDE, 0xF8 }, .oplen = 2,
	}, {
		.orig_ins = "FDIVRP", .orig_opcode = "DE F9",
		.desc = "Divide ST(0) by ST(1), store result in ST(1), and pop the register stack.",
		.opcode = { 0xDE, 0xF9 }, .oplen = 2,
	} } },
	{ "fidivr", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FIDIVR m32int", .orig_opcode = "DA /7",
		.desc = "Divide m32int by ST(0) and store result in ST(0).",
		.opcode = { 0xDA }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FIDIVR m16int", .orig_opcode = "DE /7",
		.desc = "Divide m16int by ST(0) and store result in ST(0).",
		.opcode = { 0xDE }, .oplen = 1,
	} } },
	{ "ffree", 1, (struct x64LookupActualIns[]) { {
		.args = { ST }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "FFREE ST(i)", .orig_opcode = "DD C0 +i",
		.desc = "Sets tag for ST(i) to empty.",
		.opcode = { 0xDD, 0xC0 }, .oplen = 2,
	} } },
	{ "ficom", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FICOM m16int", .orig_opcode = "DE /2",
		.desc = "Compare ST(0) with m16int.",
		.opcode = { 0xDE }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FICOM m32int", .orig_opcode = "DA /2",
		.desc = "Compare ST(0) with m32int.",
		.opcode = { 0xDA }, .oplen = 1,
	} } },
	{ "ficomp", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FICOMP m16int", .orig_opcode = "DE /3",
		.desc = "Compare ST(0) with m16int and pop stack register.",
		.opcode = { 0xDE }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FICOMP m32int", .orig_opcode = "DA /3",
		.desc = "Compare ST(0) with m32int and pop stack register.",
		.opcode = { 0xDA }, .oplen = 1,
	} } },
	{ "fild", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FILD m16int", .orig_opcode = "DF /0",
		.desc = "Push m16int onto the FPU register stack.",
		.opcode = { 0xDF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FILD m32int", .orig_opcode = "DB /0",
		.desc = "Push m32int onto the FPU register stack.",
		.opcode = { 0xDB }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FILD m64int", .orig_opcode = "DF /5",
		.desc = "Push m64int onto the FPU register stack.",
		.opcode = { 0xDF }, .oplen = 1,
	} } },
	{ "fincstp", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FINCSTP", .orig_opcode = "D9 F7",
		.desc = "Increment the TOP field in the FPU status register.",
		.opcode = { 0xD9, 0xF7 }, .oplen = 2,
	} } },
	{ "finit", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FINIT", .orig_opcode = "9B DB E3",
		.desc = "Initialize FPU after checking for pending unmasked floating-point exceptions.",
		.prefixes = 0x9B, .opcode = { 0xDB, 0xE3 }, .oplen = 2,
	} } },
	{ "fninit", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FNINIT", .orig_opcode = "DB E3",
		.desc = "Initialize FPU without checking for pending unmasked floating-point exceptions.",
		.opcode = { 0xDB, 0xE3 }, .oplen = 2,
	} } },
	{ "fist", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FIST m16int", .orig_opcode = "DF /2",
		.desc = "Store ST(0) in m16int.",
		.opcode = { 0xDF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FIST m32int", .orig_opcode = "DB /2",
		.desc = "Store ST(0) in m32int.",
		.opcode = { 0xDB }, .oplen = 1,
	} } },
	{ "fistp", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FISTP m16int", .orig_opcode = "DF /3",
		.desc = "Store ST(0) in m16int and pop register stack.",
		.opcode = { 0xDF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FISTP m32int", .orig_opcode = "DB /3",
		.desc = "Store ST(0) in m32int and pop register stack.",
		.opcode = { 0xDB }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FISTP m64int", .orig_opcode = "DF /7",
		.desc = "Store ST(0) in m64int and pop register stack.",
		.opcode = { 0xDF }, .oplen = 1,
	} } },
	{ "fisttp", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FISTTP m16int", .orig_opcode = "DF /1",
		.desc = "Store ST(0) in m16int with truncation.",
		.opcode = { 0xDF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FISTTP m32int", .orig_opcode = "DB /1",
		.desc = "Store ST(0) in m32int with truncation.",
		.opcode = { 0xDB }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FISTTP m64int", .orig_opcode = "DD /1",
		.desc = "Store ST(0) in m64int with truncation.",
		.opcode = { 0xDD }, .oplen = 1,
	} } },
	{ "fld", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FLD m32fp", .orig_opcode = "D9 /0",
		.desc = "Push m32fp onto the FPU register stack.",
		.opcode = { 0xD9 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FLD m64fp", .orig_opcode = "DD /0",
		.desc = "Push m64fp onto the FPU register stack.",
		.opcode = { 0xDD }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FLD m80fp", .orig_opcode = "DB /5",
		.desc = "Push m80fp onto the FPU register stack.",
		.opcode = { 0xDB }, .oplen = 1,
	}, {
		.args = { ST }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "FLD ST(i)", .orig_opcode = "D9 C0 +i",
		.desc = "Push ST(i) onto the FPU register stack.",
		.opcode = { 0xD9, 0xC0 }, .oplen = 2,
	} } },
	{ "fld1", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FLD1", .orig_opcode = "D9 E8",
		.desc = "Push +1.0 onto the FPU register stack.",
		.opcode = { 0xD9, 0xE8 }, .oplen = 2,
	} } },
	{ "fldl2t", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FLDL2T", .orig_opcode = "D9 E9",
		.desc = "Push log210 onto the FPU register stack.",
		.opcode = { 0xD9, 0xE9 }, .oplen = 2,
	} } },
	{ "fldl2e", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FLDL2E", .orig_opcode = "D9 EA",
		.desc = "Push log2e onto the FPU register stack.",
		.opcode = { 0xD9, 0xEA }, .oplen = 2,
	} } },
	{ "fldpi", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FLDPI", .orig_opcode = "D9 EB",
		.desc = "Push pi onto the FPU register stack.",
		.opcode = { 0xD9, 0xEB }, .oplen = 2,
	} } },
	{ "fldlg2", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FLDLG2", .orig_opcode = "D9 EC",
		.desc = "Push log102 onto the FPU register stack.",
		.opcode = { 0xD9, 0xEC }, .oplen = 2,
	} } },
	{ "fldln2", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FLDLN2", .orig_opcode = "D9 ED",
		.desc = "Push loge2 onto the FPU register stack.",
		.opcode = { 0xD9, 0xED }, .oplen = 2,
	} } },
	{ "fldz", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FLDZ", .orig_opcode = "D9 EE",
		.desc = "Push +0.0 onto the FPU register stack.",
		.opcode = { 0xD9, 0xEE }, .oplen = 2,
	} } },
	{ "fldcw", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FLDCW m2byte", .orig_opcode = "D9 /5",
		.desc = "Load FPU control word from m2byte.",
		.opcode = { 0xD9 }, .oplen = 1,
	} } },
	{ "fldenv", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FLDENV m28byte", .orig_opcode = "D9 /4",
		.desc = "Load FPU environment from m14byte or m28byte.",
		.opcode = { 0xD9 }, .oplen = 1,
	} } },
	{ "fmul", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FMUL m32fp", .orig_opcode = "D8 /1",
		.desc = "Multiply ST(0) by m32fp and store result in ST(0).",
		.opcode = { 0xD8 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FMUL m64fp", .orig_opcode = "DC /1",
		.desc = "Multiply ST(0) by m64fp and store result in ST(0).",
		.opcode = { 0xDC }, .oplen = 1,
	}, {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FMUL ST(0), ST(i)", .orig_opcode = "D8 C8 +i",
		.desc = "Multiply ST(0) by ST(i) and store result in ST(0).",
		.opcode = { 0xD8, 0xC8 }, .oplen = 2,
	}, {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FMUL ST(i), ST(0)", .orig_opcode = "DC C8 +i",
		.desc = "Multiply ST(i) by ST(0) and store result in ST(i).",
		.opcode = { 0xDC, 0xC8 }, .oplen = 2,
	} } },
	{ "fmulp", 2, (struct x64LookupActualIns[]) { {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FMULP ST(i), ST(0)", .orig_opcode = "DE C8 +i",
		.desc = "Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack.",
		.opcode = { 0xDE, 0xC8 }, .oplen = 2,
	}, {
		.orig_ins = "FMULP", .orig_opcode = "DE C9",
		.desc = "Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack.",
		.opcode = { 0xDE, 0xC9 }, .oplen = 2,
	} } },
	{ "fimul", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FIMUL m32int", .orig_opcode = "DA /1",
		.desc = "Multiply ST(0) by m32int and store result in ST(0).",
		.opcode = { 0xDA }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FIMUL m16int", .orig_opcode = "DE /1",
		.desc = "Multiply ST(0) by m16int and store result in ST(0).",
		.opcode = { 0xDE }, .oplen = 1,
	} } },
	{ "fnop", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FNOP", .orig_opcode = "D9 D0",
		.desc = "No operation is performed.",
		.opcode = { 0xD9, 0xD0 }, .oplen = 2,
	} } },
	{ "fpatan", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FPATAN", .orig_opcode = "D9 F3",
		.desc = "Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack.",
		.opcode = { 0xD9, 0xF3 }, .oplen = 2,
	} } },
	{ "fprem", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FPREM", .orig_opcode = "D9 F8",
		.desc = "Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1).",
		.opcode = { 0xD9, 0xF8 }, .oplen = 2,
	} } },
	{ "fprem1", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FPREM1", .orig_opcode = "D9 F5",
		.desc = "Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1).",
		.opcode = { 0xD9, 0xF5 }, .oplen = 2,
	} } },
	{ "fptan", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FPTAN", .orig_opcode = "D9 F2",
		.desc = "Replace ST(0) with its tangent and push 1 onto the FPU stack.",
		.opcode = { 0xD9, 0xF2 }, .oplen = 2,
	} } },
	{ "frndint", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FRNDINT", .orig_opcode = "D9 FC",
		.desc = "Round ST(0) to an integer.",
		.opcode = { 0xD9, 0xFC }, .oplen = 2,
	} } },
	{ "frstor", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FRSTOR m108byte", .orig_opcode = "DD /4",
		.desc = "Load FPU state from m94byte or m108byte.",
		.opcode = { 0xDD }, .oplen = 1,
	} } },
	{ "fsave", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSAVE m108byte", .orig_opcode = "9B DD /6",
		.desc = "Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.",
		.prefixes = 0x9B, .opcode = { 0xDD }, .oplen = 1,
	} } },
	{ "fnsave", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FNSAVE m108byte", .orig_opcode = "DD /6",
		.desc = "Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.",
		.opcode = { 0xDD }, .oplen = 1,
	} } },
	{ "fscale", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FSCALE", .orig_opcode = "D9 FD",
		.desc = "Scale ST(0) by ST(1).",
		.opcode = { 0xD9, 0xFD }, .oplen = 2,
	} } },
	{ "fsin", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FSIN", .orig_opcode = "D9 FE",
		.desc = "Replace ST(0) with its sine.",
		.opcode = { 0xD9, 0xFE }, .oplen = 2,
	} } },
	{ "fsincos", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FSINCOS", .orig_opcode = "D9 FB",
		.desc = "Compute the sine and cosine of ST(0); replace ST(0) with the sine, and push the cosine onto the register stack.",
		.opcode = { 0xD9, 0xFB }, .oplen = 2,
	} } },
	{ "fsqrt", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FSQRT", .orig_opcode = "D9 FA",
		.desc = "Computes square root of ST(0) and stores the result in ST(0).",
		.opcode = { 0xD9, 0xFA }, .oplen = 2,
	} } },
	{ "fst", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FST m32fp", .orig_opcode = "D9 /2",
		.desc = "Copy ST(0) to m32fp.",
		.opcode = { 0xD9 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FST m64fp", .orig_opcode = "DD /2",
		.desc = "Copy ST(0) to m64fp.",
		.opcode = { 0xDD }, .oplen = 1,
	}, {
		.args = { ST }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "FST ST(i)", .orig_opcode = "DD D0 +i",
		.desc = "Copy ST(0) to ST(i).",
		.opcode = { 0xDD, 0xD0 }, .oplen = 2,
	} } },
	{ "fstp", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSTP m32fp", .orig_opcode = "D9 /3",
		.desc = "Copy ST(0) to m32fp and pop register stack.",
		.opcode = { 0xD9 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSTP m64fp", .orig_opcode = "DD /3",
		.desc = "Copy ST(0) to m64fp and pop register stack.",
		.opcode = { 0xDD }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSTP m80fp", .orig_opcode = "DB /7",
		.desc = "Copy ST(0) to m80fp and pop register stack.",
		.opcode = { 0xDB }, .oplen = 1,
	}, {
		.args = { ST }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "FSTP ST(i)", .orig_opcode = "DD D8 +i",
		.desc = "Copy ST(0) to ST(i) and pop register stack.",
		.opcode = { 0xDD, 0xD8 }, .oplen = 2,
	} } },
	{ "fstcw", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSTCW m2byte", .orig_opcode = "9B D9 /7",
		.desc = "Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions.",
		.prefixes = 0x9B, .opcode = { 0xD9 }, .oplen = 1,
	} } },
	{ "fnstcw", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FNSTCW m2byte", .orig_opcode = "D9 /7",
		.desc = "Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions.",
		.opcode = { 0xD9 }, .oplen = 1,
	} } },
	{ "fstenv", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSTENV m28byte", .orig_opcode = "9B D9 /6",
		.desc = "Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.",
		.prefixes = 0x9B, .opcode = { 0xD9 }, .oplen = 1,
	} } },
	{ "fnstenv", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FNSTENV m28byte", .orig_opcode = "D9 /6",
		.desc = "Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.",
		.opcode = { 0xD9 }, .oplen = 1,
	} } },
	{ "fstsw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSTSW m2byte", .orig_opcode = "9B DD /7",
		.desc = "Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions.",
		.prefixes = 0x9B, .opcode = { 0xDD }, .oplen = 1,
	}, {
		.args = { AX }, .arglen = 1,
		.orig_ins = "FSTSW AX", .orig_opcode = "9B DF E0",
		.desc = "Store FPU status word in AX register after checking for pending unmasked floating-point exceptions.",
		.prefixes = 0x9B, .opcode = { 0xDF, 0xE0 }, .oplen = 2,
	} } },
	{ "fnstsw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FNSTSW m2byte", .orig_opcode = "DD /7",
		.desc = "Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions.",
		.opcode = { 0xDD }, .oplen = 1,
	}, {
		.args = { AX }, .arglen = 1,
		.orig_ins = "FNSTSW AX", .orig_opcode = "DF E0",
		.desc = "Store FPU status word in AX register without checking for pending unmasked floating-point exceptions.",
		.opcode = { 0xDF, 0xE0 }, .oplen = 2,
	} } },
	{ "fsub", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSUB m32fp", .orig_opcode = "D8 /4",
		.desc = "Subtract m32fp from ST(0) and store result in ST(0).",
		.opcode = { 0xD8 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSUB m64fp", .orig_opcode = "DC /4",
		.desc = "Subtract m64fp from ST(0) and store result in ST(0).",
		.opcode = { 0xDC }, .oplen = 1,
	}, {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FSUB ST(0), ST(i)", .orig_opcode = "D8 E0 +i",
		.desc = "Subtract ST(i) from ST(0) and store result in ST(0).",
		.opcode = { 0xD8, 0xE0 }, .oplen = 2,
	}, {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FSUB ST(i), ST(0)", .orig_opcode = "DC E0 +i",
		.desc = "Subtract ST(0) from ST(i) and store result in ST(i).",
		.opcode = { 0xDC, 0xE0 }, .oplen = 2,
	} } },
	{ "fsubp", 2, (struct x64LookupActualIns[]) { {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FSUBP ST(i), ST(0)", .orig_opcode = "DE E0 +i",
		.desc = "Subtract ST(0) from ST(i), store result in ST(i), and pop register stack.",
		.opcode = { 0xDE, 0xE0 }, .oplen = 2,
	}, {
		.orig_ins = "FSUBP", .orig_opcode = "DE E1",
		.desc = "Subtract ST(0) from ST(1), store result in ST(1), and pop register stack.",
		.opcode = { 0xDE, 0xE1 }, .oplen = 2,
	} } },
	{ "fisub", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FISUB m32int", .orig_opcode = "DA /4",
		.desc = "Subtract m32int from ST(0) and store result in ST(0).",
		.opcode = { 0xDA }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FISUB m16int", .orig_opcode = "DE /4",
		.desc = "Subtract m16int from ST(0) and store result in ST(0).",
		.opcode = { 0xDE }, .oplen = 1,
	} } },
	{ "fsubr", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSUBR m32fp", .orig_opcode = "D8 /5",
		.desc = "Subtract ST(0) from m32fp and store result in ST(0).",
		.opcode = { 0xD8 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FSUBR m64fp", .orig_opcode = "DC /5",
		.desc = "Subtract ST(0) from m64fp and store result in ST(0).",
		.opcode = { 0xDC }, .oplen = 1,
	}, {
		.args = { ST_0, ST }, .arglen = 2, .reg_operand = 2,
		.orig_ins = "FSUBR ST(0), ST(i)", .orig_opcode = "D8 E8 +i",
		.desc = "Subtract ST(0) from ST(i) and store result in ST(0).",
		.opcode = { 0xD8, 0xE8 }, .oplen = 2,
	}, {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FSUBR ST(i), ST(0)", .orig_opcode = "DC E8 +i",
		.desc = "Subtract ST(i) from ST(0) and store result in ST(i).",
		.opcode = { 0xDC, 0xE8 }, .oplen = 2,
	} } },
	{ "fsubrp", 2, (struct x64LookupActualIns[]) { {
		.args = { ST, ST_0 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "FSUBRP ST(i), ST(0)", .orig_opcode = "DE E8 +i",
		.desc = "Subtract ST(i) from ST(0), store result in ST(i), and pop register stack.",
		.opcode = { 0xDE, 0xE8 }, .oplen = 2,
	}, {
		.orig_ins = "FSUBRP", .orig_opcode = "DE E9",
		.desc = "Subtract ST(1) from ST(0), store result in ST(1), and pop register stack.",
		.opcode = { 0xDE, 0xE9 }, .oplen = 2,
	} } },
	{ "fisubr", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FISUBR m32int", .orig_opcode = "DA /5",
		.desc = "Subtract ST(0) from m32int and store result in ST(0).",
		.opcode = { 0xDA }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M128 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FISUBR m16int", .orig_opcode = "DE /5",
		.desc = "Subtract ST(0) from m16int and store result in ST(0).",
		.opcode = { 0xDE }, .oplen = 1,
	} } },
	{ "ftst", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FTST", .orig_opcode = "D9 E4",
		.desc = "Compare ST(0) with 0.0.",
		.opcode = { 0xD9, 0xE4 }, .oplen = 2,
	} } },
	{ "fucom", 2, (struct x64LookupActualIns[]) { {
		.args = { ST }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "FUCOM ST(i)", .orig_opcode = "DD E0 +i",
		.desc = "Compare ST(0) with ST(i).",
		.opcode = { 0xDD, 0xE0 }, .oplen = 2,
	}, {
		.orig_ins = "FUCOM", .orig_opcode = "DD E1",
		.desc = "Compare ST(0) with ST(1).",
		.opcode = { 0xDD, 0xE1 }, .oplen = 2,
	} } },
	{ "fucomp", 2, (struct x64LookupActualIns[]) { {
		.args = { ST }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "FUCOMP ST(i)", .orig_opcode = "DD E8 +i",
		.desc = "Compare ST(0) with ST(i) and pop register stack.",
		.opcode = { 0xDD, 0xE8 }, .oplen = 2,
	}, {
		.orig_ins = "FUCOMP", .orig_opcode = "DD E9",
		.desc = "Compare ST(0) with ST(1) and pop register stack.",
		.opcode = { 0xDD, 0xE9 }, .oplen = 2,
	} } },
	{ "fucompp", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FUCOMPP", .orig_opcode = "DA E9",
		.desc = "Compare ST(0) with ST(1) and pop register stack twice.",
		.opcode = { 0xDA, 0xE9 }, .oplen = 2,
	} } },
	{ "fxam", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FXAM", .orig_opcode = "D9 E5",
		.desc = "Classify value or number in ST(0).",
		.opcode = { 0xD9, 0xE5 }, .oplen = 2,
	} } },
	{ "fxch", 2, (struct x64LookupActualIns[]) { {
		.args = { ST }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "FXCH ST(i)", .orig_opcode = "D9 C8 +i",
		.desc = "Exchange the contents of ST(0) and ST(i).",
		.opcode = { 0xD9, 0xC8 }, .oplen = 2,
	}, {
		.orig_ins = "FXCH", .orig_opcode = "D9 C9",
		.desc = "Exchange the contents of ST(0) and ST(1).",
		.opcode = { 0xD9, 0xC9 }, .oplen = 2,
	} } },
	{ "fxrstor", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M512 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FXRSTOR m512byte", .orig_opcode = "0F AE /1",
		.desc = "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "fxrstor64", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { M512 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FXRSTOR64 m512byte", .orig_opcode = "REX.W+ 0F AE /1",
		.desc = "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "fxsave", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M512 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FXSAVE m512byte", .orig_opcode = "0F AE /0",
		.desc = "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "fxsave64", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { M512 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "FXSAVE64 m512byte", .orig_opcode = "REX.W+ 0F AE /0",
		.desc = "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "fxtract", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FXTRACT", .orig_opcode = "D9 F4",
		.desc = "Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack.",
		.opcode = { 0xD9, 0xF4 }, .oplen = 2,
	} } },
	{ "fyl2x", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FYL2X", .orig_opcode = "D9 F1",
		.desc = "Replace ST(1) with (ST(1) * log2ST(0)) and pop the register stack.",
		.opcode = { 0xD9, 0xF1 }, .oplen = 2,
	} } },
	{ "fyl2xp1", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FYL2XP1", .orig_opcode = "D9 F9",
		.desc = "Replace ST(1) with ST(1) * log2(ST(0) + 1.0) and pop the register stack.",
		.opcode = { 0xD9, 0xF9 }, .oplen = 2,
	} } },
	{ "haddpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "HADDPD xmm1, xmm2/m128", .orig_opcode = "66 0F 7C /r",
		.desc = "Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x7C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "HADDPD xmm1, xmm2/m128", .orig_opcode = "66 0F 7C /r",
		.desc = "Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x7C }, .oplen = 2,
	} } },
	{ "haddps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "HADDPS xmm1, xmm2/m128", .orig_opcode = "F2 0F 7C /r",
		.desc = "Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x7C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "HADDPS xmm1, xmm2/m128", .orig_opcode = "F2 0F 7C /r",
		.desc = "Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x7C }, .oplen = 2,
	} } },
	{ "hlt", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "HLT", .orig_opcode = "F4",
		.desc = "Halt",
		.opcode = { 0xF4 }, .oplen = 1,
	} } },
	{ "hsubpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "HSUBPD xmm1, xmm2/m128", .orig_opcode = "66 0F 7D /r",
		.desc = "Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x7D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "HSUBPD xmm1, xmm2/m128", .orig_opcode = "66 0F 7D /r",
		.desc = "Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x7D }, .oplen = 2,
	} } },
	{ "hsubps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "HSUBPS xmm1, xmm2/m128", .orig_opcode = "F2 0F 7D /r",
		.desc = "Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x7D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "HSUBPS xmm1, xmm2/m128", .orig_opcode = "F2 0F 7D /r",
		.desc = "Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x7D }, .oplen = 2,
	} } },
	{ "idiv", 8, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IDIV r/m8", .orig_opcode = "F6 /7",
		.desc = "Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IDIV r/m8", .orig_opcode = "F6 /7",
		.desc = "Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IDIV r/m16", .orig_opcode = "F7 /7",
		.desc = "Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IDIV r/m16", .orig_opcode = "F7 /7",
		.desc = "Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IDIV r/m32", .orig_opcode = "F7 /7",
		.desc = "Signed divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IDIV r/m32", .orig_opcode = "F7 /7",
		.desc = "Signed divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IDIV r/m64", .orig_opcode = "REX.W+ F7 /7",
		.desc = "Signed divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IDIV r/m64", .orig_opcode = "REX.W+ F7 /7",
		.desc = "Signed divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.",
		.opcode = { 0xF7 }, .oplen = 1,
	} } },
	{ "imul", 26, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IMUL r/m8", .orig_opcode = "F6 /5",
		.desc = "AX= AL * r/m byte.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IMUL r/m8", .orig_opcode = "F6 /5",
		.desc = "AX= AL * r/m byte.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IMUL r/m16", .orig_opcode = "F7 /5",
		.desc = "DX:AX = AX * r/m word.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IMUL r/m16", .orig_opcode = "F7 /5",
		.desc = "DX:AX = AX * r/m word.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IMUL r/m32", .orig_opcode = "F7 /5",
		.desc = "EDX:EAX = EAX * r/m32.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IMUL r/m32", .orig_opcode = "F7 /5",
		.desc = "EDX:EAX = EAX * r/m32.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IMUL r/m64", .orig_opcode = "REX.W+ F7 /5",
		.desc = "RDX:RAX = RAX * r/m64.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "IMUL r/m64", .orig_opcode = "REX.W+ F7 /5",
		.desc = "RDX:RAX = RAX * r/m64.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r16, r/m16", .orig_opcode = "0F AF /r",
		.desc = "word register = word register * r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r16, r/m16", .orig_opcode = "0F AF /r",
		.desc = "word register = word register * r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r32, r/m32", .orig_opcode = "0F AF /r",
		.desc = "doubleword register = doubleword register *  r/m32.",
		.opcode = { 0x0F, 0xAF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r32, r/m32", .orig_opcode = "0F AF /r",
		.desc = "doubleword register = doubleword register *  r/m32.",
		.opcode = { 0x0F, 0xAF }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r64, r/m64", .orig_opcode = "REX.W+ 0F AF /r",
		.desc = "Quadword register = Quadword register *  r/m64.",
		.opcode = { 0x0F, 0xAF }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r64, r/m64", .orig_opcode = "REX.W+ 0F AF /r",
		.desc = "Quadword register = Quadword register *  r/m64.",
		.opcode = { 0x0F, 0xAF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r16, r/m16, imm8", .orig_opcode = "6B /r ib",
		.desc = "word register = r/m16 * sign-extended immediate byte.",
		.prefixes = 0x66, .opcode = { 0x6B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r16, r/m16, imm8", .orig_opcode = "6B /r ib",
		.desc = "word register = r/m16 * sign-extended immediate byte.",
		.prefixes = 0x66, .opcode = { 0x6B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r32, r/m32, imm8", .orig_opcode = "6B /r ib",
		.desc = "doubleword register = r/m32 * sign- extended immediate byte.",
		.opcode = { 0x6B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r32, r/m32, imm8", .orig_opcode = "6B /r ib",
		.desc = "doubleword register = r/m32 * sign- extended immediate byte.",
		.opcode = { 0x6B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r64, r/m64, imm8", .orig_opcode = "REX.W+ 6B /r ib",
		.desc = "Quadword register = r/m64 * sign-extended  immediate byte.",
		.opcode = { 0x6B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r64, r/m64, imm8", .orig_opcode = "REX.W+ 6B /r ib",
		.desc = "Quadword register = r/m64 * sign-extended  immediate byte.",
		.opcode = { 0x6B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16, IMM16 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r16, r/m16, imm16", .orig_opcode = "69 /r iw",
		.desc = "word register = r/m16 * immediate word.",
		.prefixes = 0x66, .opcode = { 0x69 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16, IMM16 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r16, r/m16, imm16", .orig_opcode = "69 /r iw",
		.desc = "word register = r/m16 * immediate word.",
		.prefixes = 0x66, .opcode = { 0x69 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32, IMM32 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r32, r/m32, imm32", .orig_opcode = "69 /r id",
		.desc = "doubleword register = r/m32 * immediate doubleword.",
		.opcode = { 0x69 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32, IMM32 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r32, r/m32, imm32", .orig_opcode = "69 /r id",
		.desc = "doubleword register = r/m32 * immediate doubleword.",
		.opcode = { 0x69 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64, IMM32 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r64, r/m64, imm32", .orig_opcode = "REX.W+ 69 /r id",
		.desc = "Quadword register = r/m64 * immediate doubleword.",
		.opcode = { 0x69 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64, IMM32 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "IMUL r64, r/m64, imm32", .orig_opcode = "REX.W+ 69 /r id",
		.desc = "Quadword register = r/m64 * immediate doubleword.",
		.opcode = { 0x69 }, .oplen = 1,
	} } },
	{ "in", 6, (struct x64LookupActualIns[]) { {
		.args = { AL, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "IN AL, imm8", .orig_opcode = "E4 ib",
		.desc = "Input byte from imm8 I/O port address into AL.",
		.opcode = { 0xE4 }, .oplen = 1,
	}, {
		.args = { AX, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "IN AX, imm8", .orig_opcode = "E5 ib",
		.desc = "Input word from imm8 I/O port address into AX.",
		.prefixes = 0x66, .opcode = { 0xE5 }, .oplen = 1,
	}, {
		.args = { EAX, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "IN EAX, imm8", .orig_opcode = "E5 ib",
		.desc = "Input dword from imm8 I/O port address into EAX.",
		.opcode = { 0xE5 }, .oplen = 1,
	}, {
		.args = { AL, DX }, .arglen = 2,
		.orig_ins = "IN AL,DX", .orig_opcode = "EC",
		.desc = "Input byte from I/O port in DX into AL.",
		.opcode = { 0xEC }, .oplen = 1,
	}, {
		.args = { AX, DX }, .arglen = 2,
		.orig_ins = "IN AX,DX", .orig_opcode = "ED",
		.desc = "Input word from I/O port in DX into AX.",
		.prefixes = 0x66, .opcode = { 0xED }, .oplen = 1,
	}, {
		.args = { EAX, DX }, .arglen = 2,
		.orig_ins = "IN EAX,DX", .orig_opcode = "ED",
		.desc = "Input doubleword from I/O port in DX into EAX.",
		.opcode = { 0xED }, .oplen = 1,
	} } },
	{ "inc", 8, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "INC r/m8", .orig_opcode = "FE /0",
		.desc = "Increment r/m byte by 1.",
		.opcode = { 0xFE }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "INC r/m8", .orig_opcode = "FE /0",
		.desc = "Increment r/m byte by 1.",
		.opcode = { 0xFE }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "INC r/m16", .orig_opcode = "FF /0",
		.desc = "Increment r/m word by 1.",
		.prefixes = 0x66, .opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "INC r/m16", .orig_opcode = "FF /0",
		.desc = "Increment r/m word by 1.",
		.prefixes = 0x66, .opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "INC r/m32", .orig_opcode = "FF /0",
		.desc = "Increment r/m doubleword by 1.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "INC r/m32", .orig_opcode = "FF /0",
		.desc = "Increment r/m doubleword by 1.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "INC r/m64", .orig_opcode = "REX.W+ FF /0",
		.desc = "Increment r/m quadword by 1.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "INC r/m64", .orig_opcode = "REX.W+ FF /0",
		.desc = "Increment r/m quadword by 1.",
		.opcode = { 0xFF }, .oplen = 1,
	} } },
	{ "ins", 3, (struct x64LookupActualIns[]) { {
		.args = { M8, DX }, .arglen = 2,
		.orig_ins = "INS m8, DX", .orig_opcode = "6C",
		.desc = "Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.",
		.opcode = { 0x6C }, .oplen = 1,
	}, {
		.args = { M128, DX }, .arglen = 2,
		.orig_ins = "INS m16, DX", .orig_opcode = "6D",
		.desc = "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.",
		.opcode = { 0x6D }, .oplen = 1,
	}, {
		.args = { M32, DX }, .arglen = 2,
		.orig_ins = "INS m32, DX", .orig_opcode = "6D",
		.desc = "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.",
		.opcode = { 0x6D }, .oplen = 1,
	} } },
	{ "insb", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "INSB", .orig_opcode = "6C",
		.desc = "Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.",
		.opcode = { 0x6C }, .oplen = 1,
	} } },
	{ "insw", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "INSW", .orig_opcode = "PREF.66+ 6D",
		.desc = "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.",
		.prefixes = 0x66, .opcode = { 0x6D }, .oplen = 1,
	} } },
	{ "insd", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "INSD", .orig_opcode = "6D",
		.desc = "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.",
		.opcode = { 0x6D }, .oplen = 1,
	} } },
	{ "insertps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "INSERTPS xmm1, xmm2/m32, imm8", .orig_opcode = "66 0F 3A 21 /r ib",
		.desc = "Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x21 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "INSERTPS xmm1, xmm2/m32, imm8", .orig_opcode = "66 0F 3A 21 /r ib",
		.desc = "Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x21 }, .oplen = 3,
	} } },
	{ "int3", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "INT3", .orig_opcode = "CC",
		.desc = "Interrupt 3-trap to debugger.",
		.opcode = { 0xCC }, .oplen = 1,
	} } },
	{ "int1", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "INT1", .orig_opcode = "F1",
		.desc = "Generate debug trap.",
		.opcode = { 0xF1 }, .oplen = 1,
	} } },
	{ "int", 1, (struct x64LookupActualIns[]) { {
		.args = { IMM8 }, .arglen = 1, .immediate = 1,
		.orig_ins = "INT imm8", .orig_opcode = "CD ib",
		.desc = "Interrupt vector number specified by immediate byte.",
		.opcode = { 0xCD }, .oplen = 1,
	} } },
	{ "invd", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "INVD", .orig_opcode = "0F 08",
		.desc = "Flush internal caches; initiate flushing of external caches.",
		.opcode = { 0x0F, 0x08 }, .oplen = 2,
	} } },
	{ "invlpg", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32 }, .arglen = 1,
		.orig_ins = "INVLPG m", .orig_opcode = "0F 01 /7",
		.desc = "Invalidate TLB Entry for page that contains m.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M16 }, .arglen = 1,
		.orig_ins = "INVLPG m", .orig_opcode = "0F 01 /7",
		.desc = "Invalidate TLB Entry for page that contains m.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M64 }, .arglen = 1,
		.orig_ins = "INVLPG m", .orig_opcode = "0F 01 /7",
		.desc = "Invalidate TLB Entry for page that contains m.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	} } },
	{ "invpcid", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "INVPCID r64, m128", .orig_opcode = "66 0F 38 82 /r",
		.desc = "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r64 and descriptor in m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x82 }, .oplen = 3,
	} } },
	{ "iret", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "IRET", .orig_opcode = "PREF.66+ CF",
		.desc = "Interrupt return (16-bit operand size).",
		.prefixes = 0x66, .opcode = { 0xCF }, .oplen = 1,
	} } },
	{ "iretd", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "IRETD", .orig_opcode = "CF",
		.desc = "Interrupt return (32-bit operand size).",
		.opcode = { 0xCF }, .oplen = 1,
	} } },
	{ "iretq", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, 
		.orig_ins = "IRETQ", .orig_opcode = "REX.W+ CF",
		.desc = "Interrupt return (64-bit operand size).",
		.opcode = { 0xCF }, .oplen = 1,
	} } },
	{ "ja", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JA rel8", .orig_opcode = "77 cb",
		.desc = "Jump short if above (CF=0 and ZF=0).",
		.opcode = { 0x77 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JA rel32", .orig_opcode = "0F 87 cd",
		.desc = "Jump near if above (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x87 }, .oplen = 2,
	} } },
	{ "jae", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JAE rel8", .orig_opcode = "73 cb",
		.desc = "Jump short if above or equal (CF=0).",
		.opcode = { 0x73 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JAE rel32", .orig_opcode = "0F 83 cd",
		.desc = "Jump near if above or equal (CF=0).",
		.opcode = { 0x0F, 0x83 }, .oplen = 2,
	} } },
	{ "jb", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JB rel8", .orig_opcode = "72 cb",
		.desc = "Jump short if below (CF=1).",
		.opcode = { 0x72 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JB rel32", .orig_opcode = "0F 82 cd",
		.desc = "Jump near if below (CF=1).",
		.opcode = { 0x0F, 0x82 }, .oplen = 2,
	} } },
	{ "jbe", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JBE rel8", .orig_opcode = "76 cb",
		.desc = "Jump short if below or equal (CF=1 or ZF=1).",
		.opcode = { 0x76 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JBE rel32", .orig_opcode = "0F 86 cd",
		.desc = "Jump near if below or equal (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x86 }, .oplen = 2,
	} } },
	{ "jc", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JC rel8", .orig_opcode = "72 cb",
		.desc = "Jump short if carry (CF=1).",
		.opcode = { 0x72 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JC rel32", .orig_opcode = "0F 82 cd",
		.desc = "Jump near if carry (CF=1).",
		.opcode = { 0x0F, 0x82 }, .oplen = 2,
	} } },
	{ "jecxz", 1, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JECXZ rel8", .orig_opcode = "E3 cb",
		.desc = "Jump short if ECX register is 0.",
		.opcode = { 0xE3 }, .oplen = 1,
	} } },
	{ "jrcxz", 1, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JRCXZ rel8", .orig_opcode = "E3 cb",
		.desc = "Jump short if RCX register is 0.",
		.opcode = { 0xE3 }, .oplen = 1,
	} } },
	{ "je", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JE rel8", .orig_opcode = "74 cb",
		.desc = "Jump short if equal (ZF=1).",
		.opcode = { 0x74 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JE rel32", .orig_opcode = "0F 84 cd",
		.desc = "Jump near if 0 (ZF=1).",
		.opcode = { 0x0F, 0x84 }, .oplen = 2,
	} } },
	{ "jg", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JG rel8", .orig_opcode = "7F cb",
		.desc = "Jump short if greater (ZF=0 and SF=OF).",
		.opcode = { 0x7F }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JG rel32", .orig_opcode = "0F 8F cd",
		.desc = "Jump near if greater (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x8F }, .oplen = 2,
	} } },
	{ "jge", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JGE rel8", .orig_opcode = "7D cb",
		.desc = "Jump short if greater or equal (SF=OF).",
		.opcode = { 0x7D }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JGE rel32", .orig_opcode = "0F 8D cd",
		.desc = "Jump near if greater or equal (SF=OF).",
		.opcode = { 0x0F, 0x8D }, .oplen = 2,
	} } },
	{ "jl", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JL rel8", .orig_opcode = "7C cb",
		.desc = "Jump short if less (SF!= OF).",
		.opcode = { 0x7C }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JL rel32", .orig_opcode = "0F 8C cd",
		.desc = "Jump near if less (SF!= OF).",
		.opcode = { 0x0F, 0x8C }, .oplen = 2,
	} } },
	{ "jle", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JLE rel8", .orig_opcode = "7E cb",
		.desc = "Jump short if less or equal (ZF=1 or SF!= OF).",
		.opcode = { 0x7E }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JLE rel32", .orig_opcode = "0F 8E cd",
		.desc = "Jump near if less or equal (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x8E }, .oplen = 2,
	} } },
	{ "jna", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNA rel8", .orig_opcode = "76 cb",
		.desc = "Jump short if not above (CF=1 or ZF=1).",
		.opcode = { 0x76 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNA rel32", .orig_opcode = "0F 86 cd",
		.desc = "Jump near if not above (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x86 }, .oplen = 2,
	} } },
	{ "jnae", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNAE rel8", .orig_opcode = "72 cb",
		.desc = "Jump short if not above or equal (CF=1).",
		.opcode = { 0x72 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNAE rel32", .orig_opcode = "0F 82 cd",
		.desc = "Jump near if not above or equal (CF=1).",
		.opcode = { 0x0F, 0x82 }, .oplen = 2,
	} } },
	{ "jnb", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNB rel8", .orig_opcode = "73 cb",
		.desc = "Jump short if not below (CF=0).",
		.opcode = { 0x73 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNB rel32", .orig_opcode = "0F 83 cd",
		.desc = "Jump near if not below (CF=0).",
		.opcode = { 0x0F, 0x83 }, .oplen = 2,
	} } },
	{ "jnbe", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNBE rel8", .orig_opcode = "77 cb",
		.desc = "Jump short if not below or equal (CF=0 and ZF=0).",
		.opcode = { 0x77 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNBE rel32", .orig_opcode = "0F 87 cd",
		.desc = "Jump near if not below or equal (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x87 }, .oplen = 2,
	} } },
	{ "jnc", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNC rel8", .orig_opcode = "73 cb",
		.desc = "Jump short if not carry (CF=0).",
		.opcode = { 0x73 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNC rel32", .orig_opcode = "0F 83 cd",
		.desc = "Jump near if not carry (CF=0).",
		.opcode = { 0x0F, 0x83 }, .oplen = 2,
	} } },
	{ "jne", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNE rel8", .orig_opcode = "75 cb",
		.desc = "Jump short if not equal (ZF=0).",
		.opcode = { 0x75 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNE rel32", .orig_opcode = "0F 85 cd",
		.desc = "Jump near if not equal (ZF=0).",
		.opcode = { 0x0F, 0x85 }, .oplen = 2,
	} } },
	{ "jng", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNG rel8", .orig_opcode = "7E cb",
		.desc = "Jump short if not greater (ZF=1 or SF!= OF).",
		.opcode = { 0x7E }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNG rel32", .orig_opcode = "0F 8E cd",
		.desc = "Jump near if not greater (ZF=1 or SF != OF).",
		.opcode = { 0x0F, 0x8E }, .oplen = 2,
	} } },
	{ "jnge", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNGE rel8", .orig_opcode = "7C cb",
		.desc = "Jump short if not greater or equal (SF!= OF).",
		.opcode = { 0x7C }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNGE rel32", .orig_opcode = "0F 8C cd",
		.desc = "Jump near if not greater or equal (SF != OF).",
		.opcode = { 0x0F, 0x8C }, .oplen = 2,
	} } },
	{ "jnl", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNL rel8", .orig_opcode = "7D cb",
		.desc = "Jump short if not less (SF=OF).",
		.opcode = { 0x7D }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNL rel32", .orig_opcode = "0F 8D cd",
		.desc = "Jump near if not less (SF=OF).",
		.opcode = { 0x0F, 0x8D }, .oplen = 2,
	} } },
	{ "jnle", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNLE rel8", .orig_opcode = "7F cb",
		.desc = "Jump short if not less or equal (ZF=0 and SF=OF).",
		.opcode = { 0x7F }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNLE rel32", .orig_opcode = "0F 8F cd",
		.desc = "Jump near if not less or equal (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x8F }, .oplen = 2,
	} } },
	{ "jno", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNO rel8", .orig_opcode = "71 cb",
		.desc = "Jump short if not overflow (OF=0).",
		.opcode = { 0x71 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNO rel32", .orig_opcode = "0F 81 cd",
		.desc = "Jump near if not overflow (OF=0).",
		.opcode = { 0x0F, 0x81 }, .oplen = 2,
	} } },
	{ "jnp", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNP rel8", .orig_opcode = "7B cb",
		.desc = "Jump short if not parity (PF=0).",
		.opcode = { 0x7B }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNP rel32", .orig_opcode = "0F 8B cd",
		.desc = "Jump near if not parity (PF=0).",
		.opcode = { 0x0F, 0x8B }, .oplen = 2,
	} } },
	{ "jns", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNS rel8", .orig_opcode = "79 cb",
		.desc = "Jump short if not sign (SF=0).",
		.opcode = { 0x79 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNS rel32", .orig_opcode = "0F 89 cd",
		.desc = "Jump near if not sign (SF=0).",
		.opcode = { 0x0F, 0x89 }, .oplen = 2,
	} } },
	{ "jnz", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNZ rel8", .orig_opcode = "75 cb",
		.desc = "Jump short if not zero (ZF=0).",
		.opcode = { 0x75 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JNZ rel32", .orig_opcode = "0F 85 cd",
		.desc = "Jump near if not zero (ZF=0).",
		.opcode = { 0x0F, 0x85 }, .oplen = 2,
	} } },
	{ "jo", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JO rel8", .orig_opcode = "70 cb",
		.desc = "Jump short if overflow (OF=1).",
		.opcode = { 0x70 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JO rel32", .orig_opcode = "0F 80 cd",
		.desc = "Jump near if overflow (OF=1).",
		.opcode = { 0x0F, 0x80 }, .oplen = 2,
	} } },
	{ "jp", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JP rel8", .orig_opcode = "7A cb",
		.desc = "Jump short if parity (PF=1).",
		.opcode = { 0x7A }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JP rel32", .orig_opcode = "0F 8A cd",
		.desc = "Jump near if parity (PF=1).",
		.opcode = { 0x0F, 0x8A }, .oplen = 2,
	} } },
	{ "jpe", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JPE rel8", .orig_opcode = "7A cb",
		.desc = "Jump short if parity even (PF=1).",
		.opcode = { 0x7A }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JPE rel32", .orig_opcode = "0F 8A cd",
		.desc = "Jump near if parity even (PF=1).",
		.opcode = { 0x0F, 0x8A }, .oplen = 2,
	} } },
	{ "jpo", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JPO rel8", .orig_opcode = "7B cb",
		.desc = "Jump short if parity odd (PF=0).",
		.opcode = { 0x7B }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JPO rel32", .orig_opcode = "0F 8B cd",
		.desc = "Jump near if parity odd (PF=0).",
		.opcode = { 0x0F, 0x8B }, .oplen = 2,
	} } },
	{ "js", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JS rel8", .orig_opcode = "78 cb",
		.desc = "Jump short if sign (SF=1).",
		.opcode = { 0x78 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JS rel32", .orig_opcode = "0F 88 cd",
		.desc = "Jump near if sign (SF=1).",
		.opcode = { 0x0F, 0x88 }, .oplen = 2,
	} } },
	{ "jz", 2, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JZ rel8", .orig_opcode = "74 cb",
		.desc = "Jump short if zero (ZF = 1).",
		.opcode = { 0x74 }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JZ rel32", .orig_opcode = "0F 84 cd",
		.desc = "Jump near if 0 (ZF=1).",
		.opcode = { 0x0F, 0x84 }, .oplen = 2,
	} } },
	{ "jmp", 6, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JMP rel8", .orig_opcode = "EB cb",
		.desc = "Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits",
		.opcode = { 0xEB }, .oplen = 1,
	}, {
		.args = { REL32 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JMP rel32", .orig_opcode = "E9 cd",
		.desc = "Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits",
		.opcode = { 0xE9 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "JMP r/m64", .orig_opcode = "FF /4",
		.desc = "Jump near, absolute indirect, RIP = 64-Bit offset from register or memory",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "JMP r/m64", .orig_opcode = "FF /4",
		.desc = "Jump near, absolute indirect, RIP = 64-Bit offset from register or memory",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M128 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JMP m16:32", .orig_opcode = "FF /5",
		.desc = "Jump far, absolute indirect, address given in m16:32.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M128 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "JMP m16:64", .orig_opcode = "REX.W+ FF /5",
		.desc = "Jump far, absolute indirect, address given in m16:64.",
		.opcode = { 0xFF }, .oplen = 1,
	} } },
	{ "lahf", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "LAHF", .orig_opcode = "9F",
		.desc = "Load: AH = EFLAGS(SF:ZF:0:AF:0:PF:1:CF).",
		.opcode = { 0x9F }, .oplen = 1,
	} } },
	{ "lar", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LAR r16, r16/m16", .orig_opcode = "0F 02 /r",
		.desc = "r16 = access rights referenced by r16/m16",
		.prefixes = 0x66, .opcode = { 0x0F, 0x02 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LAR r16, r16/m16", .orig_opcode = "0F 02 /r",
		.desc = "r16 = access rights referenced by r16/m16",
		.prefixes = 0x66, .opcode = { 0x0F, 0x02 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LAR r32, r32/m16", .orig_opcode = "0F 02 /r",
		.desc = "reg = access rights referenced by r32/m16",
		.opcode = { 0x0F, 0x02 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LAR r32, r32/m16", .orig_opcode = "0F 02 /r",
		.desc = "reg = access rights referenced by r32/m16",
		.opcode = { 0x0F, 0x02 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LAR r64, r32/m16", .orig_opcode = "REX.W+ 0F 02 /r",
		.desc = "reg = access rights referenced by r32/m16",
		.opcode = { 0x0F, 0x02 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LAR r64, r32/m16", .orig_opcode = "REX.W+ 0F 02 /r",
		.desc = "reg = access rights referenced by r32/m16",
		.opcode = { 0x0F, 0x02 }, .oplen = 2,
	} } },
	{ "lddqu", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LDDQU xmm1, m128", .orig_opcode = "F2 0F F0 /r",
		.desc = "Load unaligned data from mem and return double quadword in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0xF0 }, .oplen = 2,
	} } },
	{ "ldmxcsr", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "LDMXCSR m32", .orig_opcode = "0F AE /2",
		.desc = "Load MXCSR register from m32.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "lss", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LSS r16, m16:16", .orig_opcode = "0F B2 /r",
		.desc = "Load SS:r16 with far pointer from memory.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xB2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LSS r32, m16:32", .orig_opcode = "0F B2 /r",
		.desc = "Load SS:r32 with far pointer from memory.",
		.opcode = { 0x0F, 0xB2 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LSS r64, m16:64", .orig_opcode = "REX.W+ 0F B2 /r",
		.desc = "Load SS:r64 with far pointer from memory.",
		.opcode = { 0x0F, 0xB2 }, .oplen = 2,
	} } },
	{ "lfs", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LFS r16, m16:16", .orig_opcode = "0F B4 /r",
		.desc = "Load FS:r16 with far pointer from memory.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xB4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LFS r32, m16:32", .orig_opcode = "0F B4 /r",
		.desc = "Load FS:r32 with far pointer from memory.",
		.opcode = { 0x0F, 0xB4 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LFS r64, m16:64", .orig_opcode = "REX.W+ 0F B4 /r",
		.desc = "Load FS:r64 with far pointer from memory.",
		.opcode = { 0x0F, 0xB4 }, .oplen = 2,
	} } },
	{ "lgs", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LGS r16, m16:16", .orig_opcode = "0F B5 /r",
		.desc = "Load GS:r16 with far pointer from memory.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xB5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LGS r32, m16:32", .orig_opcode = "0F B5 /r",
		.desc = "Load GS:r32 with far pointer from memory.",
		.opcode = { 0x0F, 0xB5 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LGS r64, m16:64", .orig_opcode = "REX.W+ 0F B5 /r",
		.desc = "Load GS:r64 with far pointer from memory.",
		.opcode = { 0x0F, 0xB5 }, .oplen = 2,
	} } },
	{ "lea", 9, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LEA r16, m", .orig_opcode = "8D /r",
		.desc = "Store effective address for m in register r16.",
		.opcode = { 0x8D }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LEA r16, m", .orig_opcode = "8D /r",
		.desc = "Store effective address for m in register r16.",
		.opcode = { 0x8D }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LEA r16, m", .orig_opcode = "8D /r",
		.desc = "Store effective address for m in register r16.",
		.opcode = { 0x8D }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LEA r32, m", .orig_opcode = "8D /r",
		.desc = "Store effective address for m in register r32.",
		.opcode = { 0x8D }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LEA r32, m", .orig_opcode = "8D /r",
		.desc = "Store effective address for m in register r32.",
		.opcode = { 0x8D }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LEA r32, m", .orig_opcode = "8D /r",
		.desc = "Store effective address for m in register r32.",
		.opcode = { 0x8D }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LEA r64, m", .orig_opcode = "REX.W+ 8D /r",
		.desc = "Store effective address for m in register r64.",
		.opcode = { 0x8D }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LEA r64, m", .orig_opcode = "REX.W+ 8D /r",
		.desc = "Store effective address for m in register r64.",
		.opcode = { 0x8D }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LEA r64, m", .orig_opcode = "REX.W+ 8D /r",
		.desc = "Store effective address for m in register r64.",
		.opcode = { 0x8D }, .oplen = 1,
	} } },
	{ "leave", 2, (struct x64LookupActualIns[]) { {
		.args = { PREF66 }, .arglen = 1,
		.orig_ins = "LEAVE p66", .orig_opcode = "PREF.66+ C9",
		.desc = "Set SP to BP, then pop BP.",
		.prefixes = 0x66, .opcode = { 0xC9 }, .oplen = 1,
	}, {
		.orig_ins = "LEAVE", .orig_opcode = "C9",
		.desc = "Set RSP to RBP, then pop RBP.",
		.opcode = { 0xC9 }, .oplen = 1,
	} } },
	{ "lfence", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "LFENCE", .orig_opcode = "0F AE E8",
		.desc = "Serializes load operations.",
		.opcode = { 0x0F, 0xAE, 0xE8 }, .oplen = 3,
	} } },
	{ "lgdt", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M128 }, .arglen = 1,
		.orig_ins = "LGDT m16&64", .orig_opcode = "0F 01 /2",
		.desc = "Load m into GDTR.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	} } },
	{ "lidt", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M128 }, .arglen = 1,
		.orig_ins = "LIDT m16&64", .orig_opcode = "0F 01 /3",
		.desc = "Load m into IDTR.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	} } },
	{ "lldt", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M16 }, .arglen = 1,
		.orig_ins = "LLDT r/m16", .orig_opcode = "0F 00 /2",
		.desc = "Load segment selector r/m16 into LDTR.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x00 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R16 }, .arglen = 1,
		.orig_ins = "LLDT r/m16", .orig_opcode = "0F 00 /2",
		.desc = "Load segment selector r/m16 into LDTR.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x00 }, .oplen = 2,
	} } },
	{ "lmsw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M16 }, .arglen = 1,
		.orig_ins = "LMSW r/m16", .orig_opcode = "0F 01 /6",
		.desc = "Loads r/m16 in machine status word of CR0.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R16 }, .arglen = 1,
		.orig_ins = "LMSW r/m16", .orig_opcode = "0F 01 /6",
		.desc = "Loads r/m16 in machine status word of CR0.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x01 }, .oplen = 2,
	} } },
	{ "lock", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "LOCK", .orig_opcode = "F0",
		.desc = "Asserts LOCK# signal for duration of the accompanying instruction.",
		.opcode = { 0xF0 }, .oplen = 1,
	} } },
	{ "lods", 4, (struct x64LookupActualIns[]) { {
		.args = { M8 }, .arglen = 1,
		.orig_ins = "LODS m8", .orig_opcode = "AC",
		.desc = "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.",
		.opcode = { 0xAC }, .oplen = 1,
	}, {
		.args = { M128 }, .arglen = 1,
		.orig_ins = "LODS m16", .orig_opcode = "AD",
		.desc = "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.",
		.opcode = { 0xAD }, .oplen = 1,
	}, {
		.args = { M32 }, .arglen = 1,
		.orig_ins = "LODS m32", .orig_opcode = "AD",
		.desc = "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.",
		.opcode = { 0xAD }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { M64 }, .arglen = 1,
		.orig_ins = "LODS m64", .orig_opcode = "REX.W+ AD",
		.desc = "Load qword at address (R)SI into RAX.",
		.opcode = { 0xAD }, .oplen = 1,
	} } },
	{ "lodsb", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "LODSB", .orig_opcode = "AC",
		.desc = "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.",
		.opcode = { 0xAC }, .oplen = 1,
	} } },
	{ "lodsw", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "LODSW", .orig_opcode = "PREF.66+ AD",
		.desc = "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.",
		.prefixes = 0x66, .opcode = { 0xAD }, .oplen = 1,
	} } },
	{ "lodsd", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "LODSD", .orig_opcode = "AD",
		.desc = "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.",
		.opcode = { 0xAD }, .oplen = 1,
	} } },
	{ "lodsq", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, 
		.orig_ins = "LODSQ", .orig_opcode = "REX.W+ AD",
		.desc = "Load qword at address (R)SI into RAX.",
		.opcode = { 0xAD }, .oplen = 1,
	} } },
	{ "loop", 1, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "LOOP rel8", .orig_opcode = "E2 cb",
		.desc = "Decrement count; jump short if count != 0.",
		.opcode = { 0xE2 }, .oplen = 1,
	} } },
	{ "loope", 1, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "LOOPE rel8", .orig_opcode = "E0 cb",
		.desc = "Decrement count; jump short if count != 0 and  ZF = 1.",
		.opcode = { 0xE0 }, .oplen = 1,
	} } },
	{ "loopne", 1, (struct x64LookupActualIns[]) { {
		.args = { REL8 }, .arglen = 1, .rel_operand = 1,
		.orig_ins = "LOOPNE rel8", .orig_opcode = "E0 cb",
		.desc = "Decrement count; jump short if count != 0 and  ZF = 0.",
		.opcode = { 0xE0 }, .oplen = 1,
	} } },
	{ "lsl", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LSL r16, r16/m16", .orig_opcode = "0F 03 /r",
		.desc = "Load: r16 = segment limit, selector r16/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x03 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LSL r16, r16/m16", .orig_opcode = "0F 03 /r",
		.desc = "Load: r16 = segment limit, selector r16/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x03 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LSL r32, r32/m16", .orig_opcode = "0F 03 /r",
		.desc = "Load: r32 = segment limit, selector r32/m16.",
		.opcode = { 0x0F, 0x03 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LSL r32, r32/m16", .orig_opcode = "0F 03 /r",
		.desc = "Load: r32 = segment limit, selector r32/m16.",
		.opcode = { 0x0F, 0x03 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LSL r64, r32/m16", .orig_opcode = "REX.W+ 0F 03 /r",
		.desc = "Load: r64 = segment limit, selector r32/m16",
		.opcode = { 0x0F, 0x03 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LSL r64, r32/m16", .orig_opcode = "REX.W+ 0F 03 /r",
		.desc = "Load: r64 = segment limit, selector r32/m16",
		.opcode = { 0x0F, 0x03 }, .oplen = 2,
	} } },
	{ "ltr", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M16 }, .arglen = 1,
		.orig_ins = "LTR r/m16", .orig_opcode = "0F 00 /3",
		.desc = "Load r/m16 into task register.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x00 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R16 }, .arglen = 1,
		.orig_ins = "LTR r/m16", .orig_opcode = "0F 00 /3",
		.desc = "Load r/m16 into task register.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x00 }, .oplen = 2,
	} } },
	{ "lzcnt", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LZCNT r16, r/m16", .orig_opcode = "F3 0F BD /r",
		.desc = "Count the number of leading zero bits in r/m16, return result in r16",
		.prefixes = 0x66F3, .opcode = { 0x0F, 0xBD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LZCNT r16, r/m16", .orig_opcode = "F3 0F BD /r",
		.desc = "Count the number of leading zero bits in r/m16, return result in r16",
		.prefixes = 0x66F3, .opcode = { 0x0F, 0xBD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LZCNT r32, r/m32", .orig_opcode = "F3 0F BD /r",
		.desc = "Count the number of leading zero bits in r/m32, return result in r32",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xBD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LZCNT r32, r/m32", .orig_opcode = "F3 0F BD /r",
		.desc = "Count the number of leading zero bits in r/m32, return result in r32",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xBD }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LZCNT r64, r/m64", .orig_opcode = "REX.W+ F3 0F BD /r",
		.desc = "Count the number of leading zero bits in r/m64, return result in r64",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xBD }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "LZCNT r64, r/m64", .orig_opcode = "REX.W+ F3 0F BD /r",
		.desc = "Count the number of leading zero bits in r/m64, return result in r64",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xBD }, .oplen = 2,
	} } },
	{ "maskmovdqu", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MASKMOVDQU xmm1, xmm2", .orig_opcode = "66 0F F7 /r",
		.desc = "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF7 }, .oplen = 2,
	} } },
	{ "maskmovq", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MASKMOVQ mm1, mm2", .orig_opcode = "0F F7 /r",
		.desc = "Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI.",
		.opcode = { 0x0F, 0xF7 }, .oplen = 2,
	} } },
	{ "maxpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MAXPD xmm1, xmm2/m128", .orig_opcode = "66 0F 5F /r",
		.desc = "Return the maximum double-precision floating-point values between xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MAXPD xmm1, xmm2/m128", .orig_opcode = "66 0F 5F /r",
		.desc = "Return the maximum double-precision floating-point values between xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5F }, .oplen = 2,
	} } },
	{ "maxps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MAXPS xmm1, xmm2/m128", .orig_opcode = "0F 5F /r",
		.desc = "Return the maximum single-precision floating-point values between xmm2/m128 and xmm1.",
		.opcode = { 0x0F, 0x5F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MAXPS xmm1, xmm2/m128", .orig_opcode = "0F 5F /r",
		.desc = "Return the maximum single-precision floating-point values between xmm2/m128 and xmm1.",
		.opcode = { 0x0F, 0x5F }, .oplen = 2,
	} } },
	{ "maxsd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MAXSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 5F /r",
		.desc = "Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x5F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MAXSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 5F /r",
		.desc = "Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x5F }, .oplen = 2,
	} } },
	{ "maxss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MAXSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 5F /r",
		.desc = "Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MAXSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 5F /r",
		.desc = "Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5F }, .oplen = 2,
	} } },
	{ "mfence", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "MFENCE", .orig_opcode = "0F AE F0",
		.desc = "Serializes load and store operations.",
		.opcode = { 0x0F, 0xAE, 0xF0 }, .oplen = 3,
	} } },
	{ "minpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MINPD xmm1, xmm2/m128", .orig_opcode = "66 0F 5D /r",
		.desc = "Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MINPD xmm1, xmm2/m128", .orig_opcode = "66 0F 5D /r",
		.desc = "Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5D }, .oplen = 2,
	} } },
	{ "minps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MINPS xmm1, xmm2/m128", .orig_opcode = "0F 5D /r",
		.desc = "Return the minimum single-precision floating-point values between xmm2/m128 and xmm1.",
		.opcode = { 0x0F, 0x5D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MINPS xmm1, xmm2/m128", .orig_opcode = "0F 5D /r",
		.desc = "Return the minimum single-precision floating-point values between xmm2/m128 and xmm1.",
		.opcode = { 0x0F, 0x5D }, .oplen = 2,
	} } },
	{ "minsd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MINSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 5D /r",
		.desc = "Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x5D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MINSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 5D /r",
		.desc = "Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x5D }, .oplen = 2,
	} } },
	{ "minss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MINSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 5D /r",
		.desc = "Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MINSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 5D /r",
		.desc = "Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5D }, .oplen = 2,
	} } },
	{ "monitor", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "MONITOR", .orig_opcode = "0F 01 C8",
		.desc = "Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write-back memory caching type. The address is DS:EAX (DS:RAX in 64-bit mode).",
		.opcode = { 0x0F, 0x01, 0xC8 }, .oplen = 3,
	} } },
	{ "mov", 57, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m8, r8", .orig_opcode = "88 /r",
		.desc = "Move r8 to r/m8.",
		.opcode = { 0x88 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m8, r8", .orig_opcode = "88 /r",
		.desc = "Move r8 to r/m8.",
		.opcode = { 0x88 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m8, r8", .orig_opcode = "88 /r",
		.desc = "Move r8 to r/m8.",
		.opcode = { 0x88 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m8, r8", .orig_opcode = "88 /r",
		.desc = "Move r8 to r/m8.",
		.opcode = { 0x88 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m16, r16", .orig_opcode = "89 /r",
		.desc = "Move r16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x89 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m16, r16", .orig_opcode = "89 /r",
		.desc = "Move r16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0x89 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m32, r32", .orig_opcode = "89 /r",
		.desc = "Move r32 to r/m32.",
		.opcode = { 0x89 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m32, r32", .orig_opcode = "89 /r",
		.desc = "Move r32 to r/m32.",
		.opcode = { 0x89 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m64, r64", .orig_opcode = "REX.W+ 89 /r",
		.desc = "Move r64 to r/m64.",
		.opcode = { 0x89 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m64, r64", .orig_opcode = "REX.W+ 89 /r",
		.desc = "Move r64 to r/m64.",
		.opcode = { 0x89 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV r8, r/m8", .orig_opcode = "8A /r",
		.desc = "Move r/m8 to r8.",
		.opcode = { 0x8A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV r8, r/m8", .orig_opcode = "8A /r",
		.desc = "Move r/m8 to r8.",
		.opcode = { 0x8A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV r8, r/m8", .orig_opcode = "8A /r",
		.desc = "Move r/m8 to r8.",
		.opcode = { 0x8A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV r8, r/m8", .orig_opcode = "8A /r",
		.desc = "Move r/m8 to r8.",
		.opcode = { 0x8A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV r16, r/m16", .orig_opcode = "8B /r",
		.desc = "Move r/m16 to r16.",
		.prefixes = 0x66, .opcode = { 0x8B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV r16, r/m16", .orig_opcode = "8B /r",
		.desc = "Move r/m16 to r16.",
		.prefixes = 0x66, .opcode = { 0x8B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV r32, r/m32", .orig_opcode = "8B /r",
		.desc = "Move r/m32 to r32.",
		.opcode = { 0x8B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV r32, r/m32", .orig_opcode = "8B /r",
		.desc = "Move r/m32 to r32.",
		.opcode = { 0x8B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV r64, r/m64", .orig_opcode = "REX.W+ 8B /r",
		.desc = "Move r/m64 to r64.",
		.opcode = { 0x8B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV r64, r/m64", .orig_opcode = "REX.W+ 8B /r",
		.desc = "Move r/m64 to r64.",
		.opcode = { 0x8B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, SREG }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m16, Sreg", .orig_opcode = "8C /r",
		.desc = "Move segment register to r/m16.",
		.prefixes = 0x66, .opcode = { 0x8C }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, SREG }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m16, Sreg", .orig_opcode = "8C /r",
		.desc = "Move segment register to r/m16.",
		.prefixes = 0x66, .opcode = { 0x8C }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, SREG }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m64, Sreg", .orig_opcode = "REX.W+ 8C /r",
		.desc = "Move zero extended 16-bit segment register to r/m64.",
		.opcode = { 0x8C }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, SREG }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOV r/m64, Sreg", .orig_opcode = "REX.W+ 8C /r",
		.desc = "Move zero extended 16-bit segment register to r/m64.",
		.opcode = { 0x8C }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { SREG, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV Sreg, r/m16", .orig_opcode = "8E /r",
		.desc = "Move r/m16 to segment register.",
		.prefixes = 0x66, .opcode = { 0x8E }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { SREG, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV Sreg, r/m16", .orig_opcode = "8E /r",
		.desc = "Move r/m16 to segment register.",
		.opcode = { 0x8E }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { SREG, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV Sreg, r/m64", .orig_opcode = "REX.W+ 8E /r",
		.desc = "Move lower 16 bits of r/m64 to segment register.",
		.opcode = { 0x8E }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { SREG, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOV Sreg, r/m64", .orig_opcode = "REX.W+ 8E /r",
		.desc = "Move lower 16 bits of r/m64 to segment register.",
		.opcode = { 0x8E }, .oplen = 1,
	}, {
		.args = { AL, MOFFS8 }, .arglen = 2, .rel_operand = 2,
		.orig_ins = "MOV AL, moffs8", .orig_opcode = "A0",
		.desc = "Move byte at (seg:offset) to AL.",
		.opcode = { 0xA0 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { AL, MOFFS8, PREFREX_W }, .arglen = 3, .rel_operand = 2,
		.orig_ins = "MOV AL, moffs8, pw", .orig_opcode = "REX.W+ A0",
		.desc = "Move byte at (offset) to AL.",
		.opcode = { 0xA0 }, .oplen = 1,
	}, {
		.args = { AX, MOFFS16 }, .arglen = 2, .rel_operand = 2,
		.orig_ins = "MOV AX, moffs16", .orig_opcode = "A1",
		.desc = "Move word at (seg:offset) to AX.",
		.prefixes = 0x66, .opcode = { 0xA1 }, .oplen = 1,
	}, {
		.args = { EAX, MOFFS32 }, .arglen = 2, .rel_operand = 2,
		.orig_ins = "MOV EAX, moffs32", .orig_opcode = "A1",
		.desc = "Move doubleword at (seg:offset) to EAX.",
		.opcode = { 0xA1 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, MOFFS64 }, .arglen = 2, .rel_operand = 2,
		.orig_ins = "MOV RAX, moffs64", .orig_opcode = "REX.W+ A1",
		.desc = "Move quadword at (offset) to RAX.",
		.opcode = { 0xA1 }, .oplen = 1,
	}, {
		.args = { MOFFS8, AL }, .arglen = 2, .rel_operand = 2,
		.orig_ins = "MOV moffs8, AL", .orig_opcode = "A2",
		.desc = "Move AL to (seg:offset).",
		.opcode = { 0xA2 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { MOFFS8, AL, PREFREX_W }, .arglen = 3, .rel_operand = 2,
		.orig_ins = "MOV moffs8, AL, pw", .orig_opcode = "REX.W+ A2",
		.desc = "Move AL to (offset).",
		.opcode = { 0xA2 }, .oplen = 1,
	}, {
		.args = { MOFFS16, AX }, .arglen = 2, .rel_operand = 2,
		.orig_ins = "MOV moffs16, AX", .orig_opcode = "A3",
		.desc = "Move AX to (seg:offset).",
		.prefixes = 0x66, .opcode = { 0xA3 }, .oplen = 1,
	}, {
		.args = { MOFFS32, EAX }, .arglen = 2, .rel_operand = 2,
		.orig_ins = "MOV moffs32, EAX", .orig_opcode = "A3",
		.desc = "Move EAX to (seg:offset).",
		.opcode = { 0xA3 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { MOFFS64, RAX }, .arglen = 2, .rel_operand = 2,
		.orig_ins = "MOV moffs64, RAX", .orig_opcode = "REX.W+ A3",
		.desc = "Move RAX to (offset).",
		.opcode = { 0xA3 }, .oplen = 1,
	}, {
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .reg_operand = 1,
		.orig_ins = "MOV r8, imm8", .orig_opcode = "B0 +rb",
		.desc = "Move imm8 to r8.",
		.opcode = { 0xB0 }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { RH, IMM8 }, .arglen = 2, .immediate = 2, .reg_operand = 1,
		.orig_ins = "MOV r8, imm8", .orig_opcode = "B0 +rb",
		.desc = "Move imm8 to r8.",
		.opcode = { 0xB0 }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .reg_operand = 1,
		.orig_ins = "MOV r16, imm16", .orig_opcode = "B8 +rw",
		.desc = "Move imm16 to r16.",
		.prefixes = 0x66, .opcode = { 0xB8 }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .reg_operand = 1,
		.orig_ins = "MOV r32, imm32", .orig_opcode = "B8 +rd",
		.desc = "Move imm32 to r32.",
		.opcode = { 0xB8 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { R64, IMM64 }, .arglen = 2, .immediate = 2, .reg_operand = 1,
		.orig_ins = "MOV r64, imm64", .orig_opcode = "REX.W+ B8 +rd",
		.desc = "Move imm64 to r64.",
		.opcode = { 0xB8 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "MOV r/m8, imm8", .orig_opcode = "C6 /0",
		.desc = "Move imm8 to r/m8.",
		.opcode = { 0xC6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "MOV r/m8, imm8", .orig_opcode = "C6 /0",
		.desc = "Move imm8 to r/m8.",
		.opcode = { 0xC6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "MOV r/m16, imm16", .orig_opcode = "C7 /0",
		.desc = "Move imm16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0xC7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "MOV r/m16, imm16", .orig_opcode = "C7 /0",
		.desc = "Move imm16 to r/m16.",
		.prefixes = 0x66, .opcode = { 0xC7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "MOV r/m32, imm32", .orig_opcode = "C7 /0",
		.desc = "Move imm32 to r/m32.",
		.opcode = { 0xC7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "MOV r/m32, imm32", .orig_opcode = "C7 /0",
		.desc = "Move imm32 to r/m32.",
		.opcode = { 0xC7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { M64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "MOV r/m64, imm32", .orig_opcode = "REX.W+ C7 /0",
		.desc = "Move imm32 sign extended to 64-bits to r/m64.",
		.opcode = { 0xC7 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { R64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "MOV r/m64, imm32", .orig_opcode = "REX.W+ C7 /0",
		.desc = "Move imm32 sign extended to 64-bits to r/m64.",
		.opcode = { 0xC7 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, CR0_7 }, .arglen = 2,
		.orig_ins = "MOV r64, CR0-CR7", .orig_opcode = "0F 20 /r",
		.desc = "Move extended control register to r64.",
		.opcode = { 0x0F, 0x20 }, .oplen = 2,
	}, {
		.rex = 0x44, 
		.args = { R64, CR8 }, .arglen = 2,
		.orig_ins = "MOV r64, CR8", .orig_opcode = "REX.R+ 0F 20",
		.desc = "Move extended CR8 to r64.1",
		.opcode = { 0x0F, 0x20 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { CR0_7, R64 }, .arglen = 2,
		.orig_ins = "MOV CR0-CR7, r64", .orig_opcode = "0F 22 /r",
		.desc = "Move r64 to extended control register.",
		.opcode = { 0x0F, 0x22 }, .oplen = 2,
	}, {
		.rex = 0x44, 
		.args = { CR8, R64 }, .arglen = 2,
		.orig_ins = "MOV CR8, r64", .orig_opcode = "REX.R+ 0F 22",
		.desc = "Move r64 to extended CR8.1",
		.opcode = { 0x0F, 0x22 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, DREG }, .arglen = 2,
		.orig_ins = "MOV r64, DR0-DR7", .orig_opcode = "0F 21 /r",
		.desc = "Move extended debug register to r64.",
		.opcode = { 0x0F, 0x21 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { DREG, R64 }, .arglen = 2,
		.orig_ins = "MOV DR0-DR7, r64", .orig_opcode = "0F 23 /r",
		.desc = "Move r64 to extended debug register.",
		.opcode = { 0x0F, 0x23 }, .oplen = 2,
	} } },
	{ "movapd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVAPD xmm1, xmm2/m128", .orig_opcode = "66 0F 28 /r",
		.desc = "Move packed double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x28 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVAPD xmm1, xmm2/m128", .orig_opcode = "66 0F 28 /r",
		.desc = "Move packed double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x28 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVAPD xmm2/m128, xmm1", .orig_opcode = "66 0F 29 /r",
		.desc = "Move packed double-precision floating-point values from xmm1 to xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x29 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVAPD xmm2/m128, xmm1", .orig_opcode = "66 0F 29 /r",
		.desc = "Move packed double-precision floating-point values from xmm1 to xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x29 }, .oplen = 2,
		.preffered = true,
	} } },
	{ "movaps", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVAPS xmm1, xmm2/m128", .orig_opcode = "0F 28 /r",
		.desc = "Move packed single-precision floating-point values from xmm2/m128 to xmm1.",
		.opcode = { 0x0F, 0x28 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVAPS xmm1, xmm2/m128", .orig_opcode = "0F 28 /r",
		.desc = "Move packed single-precision floating-point values from xmm2/m128 to xmm1.",
		.opcode = { 0x0F, 0x28 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVAPS xmm2/m128, xmm1", .orig_opcode = "0F 29 /r",
		.desc = "Move packed single-precision floating-point values from xmm1 to xmm2/m128.",
		.opcode = { 0x0F, 0x29 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVAPS xmm2/m128, xmm1", .orig_opcode = "0F 29 /r",
		.desc = "Move packed single-precision floating-point values from xmm1 to xmm2/m128.",
		.opcode = { 0x0F, 0x29 }, .oplen = 2,
		.preffered = true,
	} } },
	{ "movbe", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVBE r16, m16", .orig_opcode = "0F 38 F0 /r",
		.desc = "Reverse byte order in m16 and move to r16",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xF0 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVBE r32, m32", .orig_opcode = "0F 38 F0 /r",
		.desc = "Reverse byte order in m32 and move to r32",
		.opcode = { 0x0F, 0x38, 0xF0 }, .oplen = 3,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVBE r64, m64", .orig_opcode = "REX.W+ 0F 38 F0 /r",
		.desc = "Reverse byte order in m64 and move to r64.",
		.opcode = { 0x0F, 0x38, 0xF0 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVBE m16, r16", .orig_opcode = "0F 38 F1 /r",
		.desc = "Reverse byte order in r16 and move to m16",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0xF1 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVBE m32, r32", .orig_opcode = "0F 38 F1 /r",
		.desc = "Reverse byte order in r32 and move to m32",
		.opcode = { 0x0F, 0x38, 0xF1 }, .oplen = 3,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVBE m64, r64", .orig_opcode = "REX.W+ 0F 38 F1 /r",
		.desc = "Reverse byte order in r64 and move to m64.",
		.opcode = { 0x0F, 0x38, 0xF1 }, .oplen = 3,
	} } },
	{ "movd", 8, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVD mm, r/m32", .orig_opcode = "0F 6E /r",
		.desc = "Move doubleword from r/m32 to mm.",
		.opcode = { 0x0F, 0x6E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVD mm, r/m32", .orig_opcode = "0F 6E /r",
		.desc = "Move doubleword from r/m32 to mm.",
		.opcode = { 0x0F, 0x6E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, MM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVD r/m32, mm", .orig_opcode = "0F 7E /r",
		.desc = "Move doubleword from mm to r/m32.",
		.opcode = { 0x0F, 0x7E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, MM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVD r/m32, mm", .orig_opcode = "0F 7E /r",
		.desc = "Move doubleword from mm to r/m32.",
		.opcode = { 0x0F, 0x7E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVD xmm, r/m32", .orig_opcode = "66 0F 6E /r",
		.desc = "Move doubleword from r/m32 to xmm.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVD xmm, r/m32", .orig_opcode = "66 0F 6E /r",
		.desc = "Move doubleword from r/m32 to xmm.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVD r/m32, xmm", .orig_opcode = "66 0F 7E /r",
		.desc = "Move doubleword from xmm register to r/m32.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x7E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVD r/m32, xmm", .orig_opcode = "66 0F 7E /r",
		.desc = "Move doubleword from xmm register to r/m32.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x7E }, .oplen = 2,
	} } },
	{ "movq", 16, (struct x64LookupActualIns[]) { {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVQ mm, r/m64", .orig_opcode = "REX.W+ 0F 6E /r",
		.desc = "Move quadword from r/m64 to mm.",
		.opcode = { 0x0F, 0x6E }, .oplen = 2,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { MM, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVQ mm, r/m64", .orig_opcode = "REX.W+ 0F 6E /r",
		.desc = "Move quadword from r/m64 to mm.",
		.opcode = { 0x0F, 0x6E }, .oplen = 2,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, MM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVQ r/m64, mm", .orig_opcode = "REX.W+ 0F 7E /r",
		.desc = "Move quadword from mm to r/m64.",
		.opcode = { 0x0F, 0x7E }, .oplen = 2,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, MM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVQ r/m64, mm", .orig_opcode = "REX.W+ 0F 7E /r",
		.desc = "Move quadword from mm to r/m64.",
		.opcode = { 0x0F, 0x7E }, .oplen = 2,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVQ xmm, r/m64", .orig_opcode = "66 REX.W+ 0F 6E /r",
		.desc = "Move quadword from r/m64 to xmm.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6E }, .oplen = 2,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { XMM, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVQ xmm, r/m64", .orig_opcode = "66 REX.W+ 0F 6E /r",
		.desc = "Move quadword from r/m64 to xmm.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6E }, .oplen = 2,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVQ r/m64, xmm", .orig_opcode = "66 REX.W+ 0F 7E /r",
		.desc = "Move quadword from xmm register to r/m64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x7E }, .oplen = 2,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVQ r/m64, xmm", .orig_opcode = "66 REX.W+ 0F 7E /r",
		.desc = "Move quadword from xmm register to r/m64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x7E }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVQ mm, mm/m64", .orig_opcode = "0F 6F /r",
		.desc = "Move quadword from mm/m64 to mm.",
		.opcode = { 0x0F, 0x6F }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVQ mm, mm/m64", .orig_opcode = "0F 6F /r",
		.desc = "Move quadword from mm/m64 to mm.",
		.opcode = { 0x0F, 0x6F }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M64, MM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVQ mm/m64, mm", .orig_opcode = "0F 7F /r",
		.desc = "Move quadword from mm to mm/m64.",
		.opcode = { 0x0F, 0x7F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVQ mm/m64, mm", .orig_opcode = "0F 7F /r",
		.desc = "Move quadword from mm to mm/m64.",
		.opcode = { 0x0F, 0x7F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVQ xmm1, xmm2/m64", .orig_opcode = "F3 0F 7E /r",
		.desc = "Move quadword from xmm2/mem64 to xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x7E }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVQ xmm1, xmm2/m64", .orig_opcode = "F3 0F 7E /r",
		.desc = "Move quadword from xmm2/mem64 to xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x7E }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M64, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVQ xmm2/m64, xmm1", .orig_opcode = "66 0F D6 /r",
		.desc = "Move quadword from xmm1 to xmm2/mem64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD6 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVQ xmm2/m64, xmm1", .orig_opcode = "66 0F D6 /r",
		.desc = "Move quadword from xmm1 to xmm2/mem64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD6 }, .oplen = 2,
	} } },
	{ "movddup", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVDDUP xmm1, xmm2/m64", .orig_opcode = "F2 0F 12 /r",
		.desc = "Move one double-precision floating-point value from the lower 64-bit operand in xmm2/m64 to xmm1 and duplicate.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x12 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVDDUP xmm1, xmm2/m64", .orig_opcode = "F2 0F 12 /r",
		.desc = "Move one double-precision floating-point value from the lower 64-bit operand in xmm2/m64 to xmm1 and duplicate.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x12 }, .oplen = 2,
	} } },
	{ "movdqa", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVDQA xmm1, xmm2/m128", .orig_opcode = "66 0F 6F /r",
		.desc = "Move aligned double quadword from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6F }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVDQA xmm1, xmm2/m128", .orig_opcode = "66 0F 6F /r",
		.desc = "Move aligned double quadword from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6F }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVDQA xmm2/m128, xmm1", .orig_opcode = "66 0F 7F /r",
		.desc = "Move aligned double quadword from xmm1 to xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x7F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVDQA xmm2/m128, xmm1", .orig_opcode = "66 0F 7F /r",
		.desc = "Move aligned double quadword from xmm1 to xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x7F }, .oplen = 2,
	} } },
	{ "movdqu", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVDQU xmm1, xmm2/m128", .orig_opcode = "F3 0F 6F /r",
		.desc = "Move unaligned double quadword from xmm2/m128 to xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x6F }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVDQU xmm1, xmm2/m128", .orig_opcode = "F3 0F 6F /r",
		.desc = "Move unaligned double quadword from xmm2/m128 to xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x6F }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVDQU xmm2/m128, xmm1", .orig_opcode = "F3 0F 7F /r",
		.desc = "Move unaligned double quadword from xmm1 to xmm2/m128.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x7F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVDQU xmm2/m128, xmm1", .orig_opcode = "F3 0F 7F /r",
		.desc = "Move unaligned double quadword from xmm1 to xmm2/m128.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x7F }, .oplen = 2,
	} } },
	{ "movdq2q", 1, (struct x64LookupActualIns[]) { {
		.args = { MM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVDQ2Q mm, xmm", .orig_opcode = "F2 0F D6",
		.desc = "Move low quadword from xmm to mmx register.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0xD6 }, .oplen = 2,
	} } },
	{ "movhlps", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVHLPS xmm1, xmm2", .orig_opcode = "0F 12 /r",
		.desc = "Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1.",
		.opcode = { 0x0F, 0x12 }, .oplen = 2,
	} } },
	{ "movhpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVHPD xmm, m64", .orig_opcode = "66 0F 16 /r",
		.desc = "Move double-precision floating-point value from m64 to high quadword of xmm.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x16 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M64, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVHPD m64, xmm", .orig_opcode = "66 0F 17 /r",
		.desc = "Move double-precision floating-point value from high quadword of xmm to m64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x17 }, .oplen = 2,
	} } },
	{ "movhps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVHPS xmm, m64", .orig_opcode = "0F 16 /r",
		.desc = "Move two packed single-precision floating-point values from m64 to high quadword of xmm.",
		.opcode = { 0x0F, 0x16 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M64, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVHPS m64, xmm", .orig_opcode = "0F 17 /r",
		.desc = "Move two packed single-precision floating-point values from high quadword of xmm to m64.",
		.opcode = { 0x0F, 0x17 }, .oplen = 2,
	} } },
	{ "movlhps", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVLHPS xmm1, xmm2", .orig_opcode = "0F 16 /r",
		.desc = "Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1.",
		.opcode = { 0x0F, 0x16 }, .oplen = 2,
	} } },
	{ "movlpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVLPD xmm, m64", .orig_opcode = "66 0F 12 /r",
		.desc = "Move double-precision floating-point value from m64 to low quadword of xmm register.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x12 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M64, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVLPD m64, xmm", .orig_opcode = "66 0F 13 /r",
		.desc = "Move double-precision floating-point nvalue from low quadword of xmm register to m64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x13 }, .oplen = 2,
	} } },
	{ "movlps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVLPS xmm, m64", .orig_opcode = "0F 12 /r",
		.desc = "Move two packed single-precision floating-point values from m64 to low quadword of xmm.",
		.opcode = { 0x0F, 0x12 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M64, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVLPS m64, xmm", .orig_opcode = "0F 13 /r",
		.desc = "Move two packed single-precision floating-point values from low quadword of xmm to m64.",
		.opcode = { 0x0F, 0x13 }, .oplen = 2,
	} } },
	{ "movmskpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVMSKPD reg, xmm", .orig_opcode = "66 0F 50 /r",
		.desc = "Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x50 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVMSKPD reg, xmm", .orig_opcode = "66 0F 50 /r",
		.desc = "Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x50 }, .oplen = 2,
	} } },
	{ "movmskps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVMSKPS reg, xmm", .orig_opcode = "0F 50 /r",
		.desc = "Extract 4-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.",
		.opcode = { 0x0F, 0x50 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVMSKPS reg, xmm", .orig_opcode = "0F 50 /r",
		.desc = "Extract 4-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.",
		.opcode = { 0x0F, 0x50 }, .oplen = 2,
	} } },
	{ "movntdqa", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVNTDQA xmm1, m128", .orig_opcode = "66 0F 38 2A /r",
		.desc = "Move double quadword from m128 to xmm using non-temporal hint if WC memory type.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x2A }, .oplen = 3,
	} } },
	{ "movntdq", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVNTDQ m128, xmm", .orig_opcode = "66 0F E7 /r",
		.desc = "Move double quadword from xmm to m128 using non-temporal hint.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE7 }, .oplen = 2,
	} } },
	{ "movnti", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVNTI m32, r32", .orig_opcode = "0F C3 /r",
		.desc = "Move doubleword from r32 to m32 using non-temporal hint.",
		.opcode = { 0x0F, 0xC3 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVNTI m64, r64", .orig_opcode = "REX.W+ 0F C3 /r",
		.desc = "Move quadword from r64 to m64 using non-temporal hint.",
		.opcode = { 0x0F, 0xC3 }, .oplen = 2,
	} } },
	{ "movntpd", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVNTPD m128, xmm", .orig_opcode = "66 0F 2B /r",
		.desc = "Move packed double-precision floating-point values from xmm to m128 using non-temporal hint.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2B }, .oplen = 2,
	} } },
	{ "movntps", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVNTPS m128, xmm", .orig_opcode = "0F 2B /r",
		.desc = "Move packed single-precision floating-point values from xmm to m128 using non-temporal hint.",
		.opcode = { 0x0F, 0x2B }, .oplen = 2,
	} } },
	{ "movntq", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { M64, MM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVNTQ m64, mm", .orig_opcode = "0F E7 /r",
		.desc = "Move quadword from mm to m64 using non-temporal hint.",
		.opcode = { 0x0F, 0xE7 }, .oplen = 2,
	} } },
	{ "movq2dq", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVQ2DQ xmm, mm", .orig_opcode = "F3 0F D6 /r",
		.desc = "Move quadword from mmx to low quadword of xmm.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xD6 }, .oplen = 2,
	} } },
	{ "movs", 4, (struct x64LookupActualIns[]) { {
		.args = { M8, M8 }, .arglen = 2,
		.orig_ins = "MOVS m8, m8", .orig_opcode = "A4",
		.desc = "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.",
		.opcode = { 0xA4 }, .oplen = 1,
	}, {
		.args = { M128, M128 }, .arglen = 2,
		.orig_ins = "MOVS m16, m16", .orig_opcode = "A5",
		.desc = "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.",
		.opcode = { 0xA5 }, .oplen = 1,
	}, {
		.args = { M32, M32 }, .arglen = 2,
		.orig_ins = "MOVS m32, m32", .orig_opcode = "A5",
		.desc = "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.",
		.opcode = { 0xA5 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { M64, M64 }, .arglen = 2,
		.orig_ins = "MOVS m64, m64", .orig_opcode = "REX.W+ A5",
		.desc = "Move qword from address (R|E)SI to (R|E)DI.",
		.opcode = { 0xA5 }, .oplen = 1,
	} } },
	{ "movsb", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "MOVSB", .orig_opcode = "A4",
		.desc = "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.",
		.opcode = { 0xA4 }, .oplen = 1,
	} } },
	{ "movsw", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "MOVSW", .orig_opcode = "PREF.66+ A5",
		.desc = "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.",
		.prefixes = 0x66, .opcode = { 0xA5 }, .oplen = 1,
	} } },
	{ "movsd", 5, (struct x64LookupActualIns[]) { {
		.orig_ins = "MOVSD", .orig_opcode = "A5",
		.desc = "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.",
		.opcode = { 0xA5 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 10 /r",
		.desc = "Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x10 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 10 /r",
		.desc = "Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x10 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M64, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVSD xmm2/m64, xmm1", .orig_opcode = "F2 0F 11 /r",
		.desc = "Move scalar double-precision floating-point value from xmm1 register to xmm2/m64.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x11 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVSD xmm2/m64, xmm1", .orig_opcode = "F2 0F 11 /r",
		.desc = "Move scalar double-precision floating-point value from xmm1 register to xmm2/m64.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x11 }, .oplen = 2,
	} } },
	{ "movsq", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, 
		.orig_ins = "MOVSQ", .orig_opcode = "REX.W+ A5",
		.desc = "Move qword from address (R|E)SI to (R|E)DI.",
		.opcode = { 0xA5 }, .oplen = 1,
	} } },
	{ "movshdup", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSHDUP xmm1, xmm2/m128", .orig_opcode = "F3 0F 16 /r",
		.desc = "Move two single-precision floating-point values from the higher 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the lower 32-bits of each qword.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x16 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSHDUP xmm1, xmm2/m128", .orig_opcode = "F3 0F 16 /r",
		.desc = "Move two single-precision floating-point values from the higher 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the lower 32-bits of each qword.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x16 }, .oplen = 2,
	} } },
	{ "movsldup", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSLDUP xmm1, xmm2/m128", .orig_opcode = "F3 0F 12 /r",
		.desc = "Move two single-precision floating-point values from the lower 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the higher 32-bits of each qword.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x12 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSLDUP xmm1, xmm2/m128", .orig_opcode = "F3 0F 12 /r",
		.desc = "Move two single-precision floating-point values from the lower 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the higher 32-bits of each qword.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x12 }, .oplen = 2,
	} } },
	{ "movss", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 10 /r",
		.desc = "Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x10 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 10 /r",
		.desc = "Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x10 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVSS xmm2/m32, xmm", .orig_opcode = "F3 0F 11 /r",
		.desc = "Move scalar single-precision floating-point value from xmm1 register to xmm2/m32.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x11 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVSS xmm2/m32, xmm", .orig_opcode = "F3 0F 11 /r",
		.desc = "Move scalar single-precision floating-point value from xmm1 register to xmm2/m32.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x11 }, .oplen = 2,
	} } },
	{ "movsx", 10, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSX r16, r/m8", .orig_opcode = "0F BE /r",
		.desc = "Move byte to word with sign-extension.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSX r16, r/m8", .orig_opcode = "0F BE /r",
		.desc = "Move byte to word with sign-extension.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xBE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSX r32, r/m8", .orig_opcode = "0F BE /r",
		.desc = "Move byte to doubleword with sign-extension.",
		.opcode = { 0x0F, 0xBE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSX r32, r/m8", .orig_opcode = "0F BE /r",
		.desc = "Move byte to doubleword with sign-extension.",
		.opcode = { 0x0F, 0xBE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSX r64, r/m8", .orig_opcode = "REX.W+ 0F BE /r",
		.desc = "Move byte to quadword with sign-extension.",
		.opcode = { 0x0F, 0xBE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSX r64, r/m8", .orig_opcode = "REX.W+ 0F BE /r",
		.desc = "Move byte to quadword with sign-extension.",
		.opcode = { 0x0F, 0xBE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSX r32, r/m16", .orig_opcode = "0F BF /r",
		.desc = "Move word to doubleword, with sign-extension.",
		.opcode = { 0x0F, 0xBF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSX r32, r/m16", .orig_opcode = "0F BF /r",
		.desc = "Move word to doubleword, with sign-extension.",
		.opcode = { 0x0F, 0xBF }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSX r64, r/m16", .orig_opcode = "REX.W+ 0F BF /r",
		.desc = "Move word to quadword with sign-extension.",
		.opcode = { 0x0F, 0xBF }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSX r64, r/m16", .orig_opcode = "REX.W+ 0F BF /r",
		.desc = "Move word to quadword with sign-extension.",
		.opcode = { 0x0F, 0xBF }, .oplen = 2,
	} } },
	{ "movsxd", 2, (struct x64LookupActualIns[]) { {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSXD r64, r/m32", .orig_opcode = "REX.W+ 63 /r",
		.desc = "Move doubleword to quadword with sign-extension.",
		.opcode = { 0x63 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVSXD r64, r/m32", .orig_opcode = "REX.W+ 63 /r",
		.desc = "Move doubleword to quadword with sign-extension.",
		.opcode = { 0x63 }, .oplen = 1,
	} } },
	{ "movupd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVUPD xmm1, xmm2/m128", .orig_opcode = "66 0F 10 /r",
		.desc = "Move packed double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x10 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVUPD xmm1, xmm2/m128", .orig_opcode = "66 0F 10 /r",
		.desc = "Move packed double-precision floating-point values from xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x10 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVUPD xmm2/m128, xmm", .orig_opcode = "66 0F 11 /r",
		.desc = "Move packed double-precision floating-point values from xmm1 to xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x11 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVUPD xmm2/m128, xmm", .orig_opcode = "66 0F 11 /r",
		.desc = "Move packed double-precision floating-point values from xmm1 to xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x11 }, .oplen = 2,
	} } },
	{ "movups", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVUPS xmm1, xmm2/m128", .orig_opcode = "0F 10 /r",
		.desc = "Move packed single-precision floating-point values from xmm2/m128 to xmm1.",
		.opcode = { 0x0F, 0x10 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVUPS xmm1, xmm2/m128", .orig_opcode = "0F 10 /r",
		.desc = "Move packed single-precision floating-point values from xmm2/m128 to xmm1.",
		.opcode = { 0x0F, 0x10 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVUPS xmm2/m128, xmm1", .orig_opcode = "0F 11 /r",
		.desc = "Move packed single-precision floating-point values from xmm1 to xmm2/m128.",
		.opcode = { 0x0F, 0x11 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "MOVUPS xmm2/m128, xmm1", .orig_opcode = "0F 11 /r",
		.desc = "Move packed single-precision floating-point values from xmm1 to xmm2/m128.",
		.opcode = { 0x0F, 0x11 }, .oplen = 2,
	} } },
	{ "movzx", 10, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVZX r16, r/m8", .orig_opcode = "0F B6 /r",
		.desc = "Move byte to word with zero-extension.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xB6 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVZX r16, r/m8", .orig_opcode = "0F B6 /r",
		.desc = "Move byte to word with zero-extension.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xB6 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVZX r32, r/m8", .orig_opcode = "0F B6 /r",
		.desc = "Move byte to doubleword, zero-extension.",
		.opcode = { 0x0F, 0xB6 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVZX r32, r/m8", .orig_opcode = "0F B6 /r",
		.desc = "Move byte to doubleword, zero-extension.",
		.opcode = { 0x0F, 0xB6 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVZX r64, r/m8", .orig_opcode = "REX.W+ 0F B6 /r",
		.desc = "Move byte to quadword, zero-extension.",
		.opcode = { 0x0F, 0xB6 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVZX r64, r/m8", .orig_opcode = "REX.W+ 0F B6 /r",
		.desc = "Move byte to quadword, zero-extension.",
		.opcode = { 0x0F, 0xB6 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVZX r32, r/m16", .orig_opcode = "0F B7 /r",
		.desc = "Move word to doubleword, zero-extension.",
		.opcode = { 0x0F, 0xB7 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVZX r32, r/m16", .orig_opcode = "0F B7 /r",
		.desc = "Move word to doubleword, zero-extension.",
		.opcode = { 0x0F, 0xB7 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVZX r64, r/m16", .orig_opcode = "REX.W+ 0F B7 /r",
		.desc = "Move word to quadword, zero-extension.",
		.opcode = { 0x0F, 0xB7 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MOVZX r64, r/m16", .orig_opcode = "REX.W+ 0F B7 /r",
		.desc = "Move word to quadword, zero-extension.",
		.opcode = { 0x0F, 0xB7 }, .oplen = 2,
	} } },
	{ "mpsadbw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MPSADBW xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 42 /r ib",
		.desc = "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x42 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MPSADBW xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 42 /r ib",
		.desc = "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x42 }, .oplen = 3,
	} } },
	{ "mul", 8, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "MUL r/m8", .orig_opcode = "F6 /4",
		.desc = "Unsigned multiply (AX = AL * r/m8).",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "MUL r/m8", .orig_opcode = "F6 /4",
		.desc = "Unsigned multiply (AX = AL * r/m8).",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "MUL r/m16", .orig_opcode = "F7 /4",
		.desc = "Unsigned multiply (DX:AX = AX * r/m16).",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "MUL r/m16", .orig_opcode = "F7 /4",
		.desc = "Unsigned multiply (DX:AX = AX * r/m16).",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "MUL r/m32", .orig_opcode = "F7 /4",
		.desc = "Unsigned multiply (EDX:EAX = EAX * r/m32).",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "MUL r/m32", .orig_opcode = "F7 /4",
		.desc = "Unsigned multiply (EDX:EAX = EAX * r/m32).",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "MUL r/m64", .orig_opcode = "REX.W+ F7 /4",
		.desc = "Unsigned multiply (RDX:RAX = RAX * r/m64.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "MUL r/m64", .orig_opcode = "REX.W+ F7 /4",
		.desc = "Unsigned multiply (RDX:RAX = RAX * r/m64.",
		.opcode = { 0xF7 }, .oplen = 1,
	} } },
	{ "mulpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MULPD xmm1, xmm2/m128", .orig_opcode = "66 0F 59 /r",
		.desc = "Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x59 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MULPD xmm1, xmm2/m128", .orig_opcode = "66 0F 59 /r",
		.desc = "Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x59 }, .oplen = 2,
	} } },
	{ "mulps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MULPS xmm1, xmm2/m128", .orig_opcode = "0F 59 /r",
		.desc = "Multiply packed single-precision floating-point values in xmm2/mem by xmm1.",
		.opcode = { 0x0F, 0x59 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MULPS xmm1, xmm2/m128", .orig_opcode = "0F 59 /r",
		.desc = "Multiply packed single-precision floating-point values in xmm2/mem by xmm1.",
		.opcode = { 0x0F, 0x59 }, .oplen = 2,
	} } },
	{ "mulsd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MULSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 59 /r",
		.desc = "Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x59 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MULSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 59 /r",
		.desc = "Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x59 }, .oplen = 2,
	} } },
	{ "mulss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MULSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 59 /r",
		.desc = "Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x59 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "MULSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 59 /r",
		.desc = "Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x59 }, .oplen = 2,
	} } },
	{ "mwait", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "MWAIT", .orig_opcode = "0F 01 C9",
		.desc = "A hint that allow the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events.",
		.opcode = { 0x0F, 0x01, 0xC9 }, .oplen = 3,
	} } },
	{ "neg", 8, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NEG r/m8", .orig_opcode = "F6 /3",
		.desc = "Two's complement negate r/m8.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NEG r/m8", .orig_opcode = "F6 /3",
		.desc = "Two's complement negate r/m8.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NEG r/m16", .orig_opcode = "F7 /3",
		.desc = "Two's complement negate r/m16.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NEG r/m16", .orig_opcode = "F7 /3",
		.desc = "Two's complement negate r/m16.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NEG r/m32", .orig_opcode = "F7 /3",
		.desc = "Two's complement negate r/m32.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NEG r/m32", .orig_opcode = "F7 /3",
		.desc = "Two's complement negate r/m32.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NEG r/m64", .orig_opcode = "REX.W+ F7 /3",
		.desc = "Two's complement negate r/m64.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NEG r/m64", .orig_opcode = "REX.W+ F7 /3",
		.desc = "Two's complement negate r/m64.",
		.opcode = { 0xF7 }, .oplen = 1,
	} } },
	{ "nop", 5, (struct x64LookupActualIns[]) { {
		.orig_ins = "NOP", .orig_opcode = "90",
		.desc = "One byte no-operation instruction.",
		.opcode = { 0x90 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOP r/m16", .orig_opcode = "0F 1F /0",
		.desc = "Multi-byte no-operation instruction.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x1F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOP r/m16", .orig_opcode = "0F 1F /0",
		.desc = "Multi-byte no-operation instruction.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x1F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOP r/m32", .orig_opcode = "0F 1F /0",
		.desc = "Multi-byte no-operation instruction.",
		.opcode = { 0x0F, 0x1F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOP r/m32", .orig_opcode = "0F 1F /0",
		.desc = "Multi-byte no-operation instruction.",
		.opcode = { 0x0F, 0x1F }, .oplen = 2,
	} } },
	{ "not", 8, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOT r/m8", .orig_opcode = "F6 /2",
		.desc = "Reverse each bit of r/m8.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOT r/m8", .orig_opcode = "F6 /2",
		.desc = "Reverse each bit of r/m8.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOT r/m16", .orig_opcode = "F7 /2",
		.desc = "Reverse each bit of r/m16.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOT r/m16", .orig_opcode = "F7 /2",
		.desc = "Reverse each bit of r/m16.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOT r/m32", .orig_opcode = "F7 /2",
		.desc = "Reverse each bit of r/m32.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOT r/m32", .orig_opcode = "F7 /2",
		.desc = "Reverse each bit of r/m32.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOT r/m64", .orig_opcode = "REX.W+ F7 /2",
		.desc = "Reverse each bit of r/m64.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "NOT r/m64", .orig_opcode = "REX.W+ F7 /2",
		.desc = "Reverse each bit of r/m64.",
		.opcode = { 0xF7 }, .oplen = 1,
	} } },
	{ "or", 38, (struct x64LookupActualIns[]) { {
		.args = { AL, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "OR AL, imm8", .orig_opcode = "0C ib",
		.desc = "AL OR imm8.",
		.opcode = { 0x0C }, .oplen = 1,
	}, {
		.args = { AX, IMM16 }, .arglen = 2, .immediate = 2,
		.orig_ins = "OR AX, imm16", .orig_opcode = "0D iw",
		.desc = "AX OR imm16.",
		.prefixes = 0x66, .opcode = { 0x0D }, .oplen = 1,
	}, {
		.args = { EAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "OR EAX, imm32", .orig_opcode = "0D id",
		.desc = "EAX OR imm32.",
		.opcode = { 0x0D }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "OR RAX, imm32", .orig_opcode = "REX.W+ 0D id",
		.desc = "RAX OR imm32 (sign-extended).",
		.opcode = { 0x0D }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m8, imm8", .orig_opcode = "80 /1 ib",
		.desc = "r/m8 OR imm8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m8, imm8", .orig_opcode = "80 /1 ib",
		.desc = "r/m8 OR imm8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m16, imm16", .orig_opcode = "81 /1 iw",
		.desc = "r/m16 OR imm16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m16, imm16", .orig_opcode = "81 /1 iw",
		.desc = "r/m16 OR imm16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m32, imm32", .orig_opcode = "81 /1 id",
		.desc = "r/m32 OR imm32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m32, imm32", .orig_opcode = "81 /1 id",
		.desc = "r/m32 OR imm32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { M64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m64, imm32", .orig_opcode = "REX.W+ 81 /1 id",
		.desc = "r/m64 OR imm32 (sign-extended).",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { R64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m64, imm32", .orig_opcode = "REX.W+ 81 /1 id",
		.desc = "r/m64 OR imm32 (sign-extended).",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m16, imm8", .orig_opcode = "83 /1 ib",
		.desc = "r/m16 OR imm8 (sign-extended).",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m16, imm8", .orig_opcode = "83 /1 ib",
		.desc = "r/m16 OR imm8 (sign-extended).",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m32, imm8", .orig_opcode = "83 /1 ib",
		.desc = "r/m32 OR imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m32, imm8", .orig_opcode = "83 /1 ib",
		.desc = "r/m32 OR imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m64, imm8", .orig_opcode = "REX.W+ 83 /1 ib",
		.desc = "r/m64 OR imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "OR r/m64, imm8", .orig_opcode = "REX.W+ 83 /1 ib",
		.desc = "r/m64 OR imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "OR r/m8, r8", .orig_opcode = "08 /r",
		.desc = "r/m8 OR r8.",
		.opcode = { 0x08 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "OR r/m8, r8", .orig_opcode = "08 /r",
		.desc = "r/m8 OR r8.",
		.opcode = { 0x08 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "OR r/m8, r8", .orig_opcode = "08 /r",
		.desc = "r/m8 OR r8.",
		.opcode = { 0x08 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "OR r/m8, r8", .orig_opcode = "08 /r",
		.desc = "r/m8 OR r8.",
		.opcode = { 0x08 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "OR r/m16, r16", .orig_opcode = "09 /r",
		.desc = "r/m16 OR r16.",
		.prefixes = 0x66, .opcode = { 0x09 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "OR r/m16, r16", .orig_opcode = "09 /r",
		.desc = "r/m16 OR r16.",
		.prefixes = 0x66, .opcode = { 0x09 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "OR r/m32, r32", .orig_opcode = "09 /r",
		.desc = "r/m32 OR r32.",
		.opcode = { 0x09 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "OR r/m32, r32", .orig_opcode = "09 /r",
		.desc = "r/m32 OR r32.",
		.opcode = { 0x09 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "OR r/m64, r64", .orig_opcode = "REX.W+ 09 /r",
		.desc = "r/m64 OR r64.",
		.opcode = { 0x09 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "OR r/m64, r64", .orig_opcode = "REX.W+ 09 /r",
		.desc = "r/m64 OR r64.",
		.opcode = { 0x09 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "OR r8, r/m8", .orig_opcode = "0A /r",
		.desc = "r8 OR r/m8.",
		.opcode = { 0x0A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "OR r8, r/m8", .orig_opcode = "0A /r",
		.desc = "r8 OR r/m8.",
		.opcode = { 0x0A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "OR r8, r/m8", .orig_opcode = "0A /r",
		.desc = "r8 OR r/m8.",
		.opcode = { 0x0A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "OR r8, r/m8", .orig_opcode = "0A /r",
		.desc = "r8 OR r/m8.",
		.opcode = { 0x0A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "OR r16, r/m16", .orig_opcode = "0B /r",
		.desc = "r16 OR r/m16.",
		.prefixes = 0x66, .opcode = { 0x0B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "OR r16, r/m16", .orig_opcode = "0B /r",
		.desc = "r16 OR r/m16.",
		.prefixes = 0x66, .opcode = { 0x0B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "OR r32, r/m32", .orig_opcode = "0B /r",
		.desc = "r32 OR r/m32.",
		.opcode = { 0x0B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "OR r32, r/m32", .orig_opcode = "0B /r",
		.desc = "r32 OR r/m32.",
		.opcode = { 0x0B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "OR r64, r/m64", .orig_opcode = "REX.W+ 0B /r",
		.desc = "r64 OR r/m64.",
		.opcode = { 0x0B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "OR r64, r/m64", .orig_opcode = "REX.W+ 0B /r",
		.desc = "r64 OR r/m64.",
		.opcode = { 0x0B }, .oplen = 1,
	} } },
	{ "orpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ORPD xmm1, xmm2/m128", .orig_opcode = "66 0F 56 /r",
		.desc = "Bitwise OR of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x56 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ORPD xmm1, xmm2/m128", .orig_opcode = "66 0F 56 /r",
		.desc = "Bitwise OR of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x56 }, .oplen = 2,
	} } },
	{ "orps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ORPS xmm1, xmm2/m128", .orig_opcode = "0F 56 /r",
		.desc = "Bitwise OR of xmm1 and xmm2/m128.",
		.opcode = { 0x0F, 0x56 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ORPS xmm1, xmm2/m128", .orig_opcode = "0F 56 /r",
		.desc = "Bitwise OR of xmm1 and xmm2/m128.",
		.opcode = { 0x0F, 0x56 }, .oplen = 2,
	} } },
	{ "out", 6, (struct x64LookupActualIns[]) { {
		.args = { IMM8, AL }, .arglen = 2, .immediate = 1,
		.orig_ins = "OUT imm8, AL", .orig_opcode = "E6 ib",
		.desc = "Output byte in AL to I/O port address imm8.",
		.opcode = { 0xE6 }, .oplen = 1,
	}, {
		.args = { IMM8, AX }, .arglen = 2, .immediate = 1,
		.orig_ins = "OUT imm8, AX", .orig_opcode = "E7 ib",
		.desc = "Output word in AX to I/O port address imm8.",
		.prefixes = 0x66, .opcode = { 0xE7 }, .oplen = 1,
	}, {
		.args = { IMM8, EAX }, .arglen = 2, .immediate = 1,
		.orig_ins = "OUT imm8, EAX", .orig_opcode = "E7 ib",
		.desc = "Output doubleword in EAX to I/O port address imm8.",
		.opcode = { 0xE7 }, .oplen = 1,
	}, {
		.args = { DX, AL }, .arglen = 2,
		.orig_ins = "OUT DX, AL", .orig_opcode = "EE",
		.desc = "Output byte in AL to I/O port address in DX.",
		.opcode = { 0xEE }, .oplen = 1,
	}, {
		.args = { DX, AX }, .arglen = 2,
		.orig_ins = "OUT DX, AX", .orig_opcode = "EF",
		.desc = "Output word in AX to I/O port address in DX.",
		.prefixes = 0x66, .opcode = { 0xEF }, .oplen = 1,
	}, {
		.args = { DX, EAX }, .arglen = 2,
		.orig_ins = "OUT DX, EAX", .orig_opcode = "EF",
		.desc = "Output doubleword in EAX to I/O port address in DX.",
		.opcode = { 0xEF }, .oplen = 1,
	} } },
	{ "outs", 3, (struct x64LookupActualIns[]) { {
		.args = { DX, M8 }, .arglen = 2,
		.orig_ins = "OUTS DX, m8", .orig_opcode = "6E",
		.desc = "Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.",
		.opcode = { 0x6E }, .oplen = 1,
	}, {
		.args = { DX, M128 }, .arglen = 2,
		.orig_ins = "OUTS DX, m16", .orig_opcode = "6F",
		.desc = "Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.",
		.opcode = { 0x6F }, .oplen = 1,
	}, {
		.args = { DX, M32 }, .arglen = 2,
		.orig_ins = "OUTS DX, m32", .orig_opcode = "6F",
		.desc = "Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.",
		.opcode = { 0x6F }, .oplen = 1,
	} } },
	{ "outsb", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "OUTSB", .orig_opcode = "6E",
		.desc = "Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.",
		.opcode = { 0x6E }, .oplen = 1,
	} } },
	{ "outsw", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "OUTSW", .orig_opcode = "PREF.66+ 6F",
		.desc = "Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.",
		.prefixes = 0x66, .opcode = { 0x6F }, .oplen = 1,
	} } },
	{ "outsd", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "OUTSD", .orig_opcode = "6F",
		.desc = "Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.",
		.opcode = { 0x6F }, .oplen = 1,
	} } },
	{ "pabsb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSB mm1, mm2/m64", .orig_opcode = "0F 38 1C /r",
		.desc = "Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1.",
		.opcode = { 0x0F, 0x38, 0x1C }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSB mm1, mm2/m64", .orig_opcode = "0F 38 1C /r",
		.desc = "Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1.",
		.opcode = { 0x0F, 0x38, 0x1C }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSB xmm1, xmm2/m128", .orig_opcode = "66 0F 38 1C /r",
		.desc = "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x1C }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSB xmm1, xmm2/m128", .orig_opcode = "66 0F 38 1C /r",
		.desc = "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x1C }, .oplen = 3,
	} } },
	{ "pabsw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSW mm1, mm2/m64", .orig_opcode = "0F 38 1D /r",
		.desc = "Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1.",
		.opcode = { 0x0F, 0x38, 0x1D }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSW mm1, mm2/m64", .orig_opcode = "0F 38 1D /r",
		.desc = "Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1.",
		.opcode = { 0x0F, 0x38, 0x1D }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 1D /r",
		.desc = "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x1D }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 1D /r",
		.desc = "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x1D }, .oplen = 3,
	} } },
	{ "pabsd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSD mm1, mm2/m64", .orig_opcode = "0F 38 1E /r",
		.desc = "Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1.",
		.opcode = { 0x0F, 0x38, 0x1E }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSD mm1, mm2/m64", .orig_opcode = "0F 38 1E /r",
		.desc = "Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1.",
		.opcode = { 0x0F, 0x38, 0x1E }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 1E /r",
		.desc = "Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x1E }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PABSD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 1E /r",
		.desc = "Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x1E }, .oplen = 3,
	} } },
	{ "packsswb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKSSWB mm1, mm2/m64", .orig_opcode = "0F 63 /r",
		.desc = "Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation.",
		.opcode = { 0x0F, 0x63 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKSSWB mm1, mm2/m64", .orig_opcode = "0F 63 /r",
		.desc = "Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation.",
		.opcode = { 0x0F, 0x63 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKSSWB xmm1, xmm2/m128", .orig_opcode = "66 0F 63 /r",
		.desc = "Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x63 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKSSWB xmm1, xmm2/m128", .orig_opcode = "66 0F 63 /r",
		.desc = "Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x63 }, .oplen = 2,
	} } },
	{ "packssdw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKSSDW mm1, mm2/m64", .orig_opcode = "0F 6B /r",
		.desc = "Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation.",
		.opcode = { 0x0F, 0x6B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKSSDW mm1, mm2/m64", .orig_opcode = "0F 6B /r",
		.desc = "Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation.",
		.opcode = { 0x0F, 0x6B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKSSDW xmm1, xmm2/m128", .orig_opcode = "66 0F 6B /r",
		.desc = "Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKSSDW xmm1, xmm2/m128", .orig_opcode = "66 0F 6B /r",
		.desc = "Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6B }, .oplen = 2,
	} } },
	{ "packusdw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKUSDW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 2B /r",
		.desc = "Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x2B }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKUSDW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 2B /r",
		.desc = "Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x2B }, .oplen = 3,
	} } },
	{ "packuswb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKUSWB mm, mm/m64", .orig_opcode = "0F 67 /r",
		.desc = "Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation.",
		.opcode = { 0x0F, 0x67 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKUSWB mm, mm/m64", .orig_opcode = "0F 67 /r",
		.desc = "Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation.",
		.opcode = { 0x0F, 0x67 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKUSWB xmm1, xmm2/m128", .orig_opcode = "66 0F 67 /r",
		.desc = "Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x67 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PACKUSWB xmm1, xmm2/m128", .orig_opcode = "66 0F 67 /r",
		.desc = "Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x67 }, .oplen = 2,
	} } },
	{ "paddb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDB mm, mm/m64", .orig_opcode = "0F FC /r",
		.desc = "Add packed byte integers from mm/m64 and mm.",
		.opcode = { 0x0F, 0xFC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDB mm, mm/m64", .orig_opcode = "0F FC /r",
		.desc = "Add packed byte integers from mm/m64 and mm.",
		.opcode = { 0x0F, 0xFC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDB xmm1, xmm2/m128", .orig_opcode = "66 0F FC /r",
		.desc = "Add packed byte integers from xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xFC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDB xmm1, xmm2/m128", .orig_opcode = "66 0F FC /r",
		.desc = "Add packed byte integers from xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xFC }, .oplen = 2,
	} } },
	{ "paddw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDW mm, mm/m64", .orig_opcode = "0F FD /r",
		.desc = "Add packed word integers from mm/m64 and mm.",
		.opcode = { 0x0F, 0xFD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDW mm, mm/m64", .orig_opcode = "0F FD /r",
		.desc = "Add packed word integers from mm/m64 and mm.",
		.opcode = { 0x0F, 0xFD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDW xmm1, xmm2/m128", .orig_opcode = "66 0F FD /r",
		.desc = "Add packed word integers from xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xFD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDW xmm1, xmm2/m128", .orig_opcode = "66 0F FD /r",
		.desc = "Add packed word integers from xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xFD }, .oplen = 2,
	} } },
	{ "paddd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDD mm, mm/m64", .orig_opcode = "0F FE /r",
		.desc = "Add packed doubleword integers from mm/m64 and mm.",
		.opcode = { 0x0F, 0xFE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDD mm, mm/m64", .orig_opcode = "0F FE /r",
		.desc = "Add packed doubleword integers from mm/m64 and mm.",
		.opcode = { 0x0F, 0xFE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDD xmm1, xmm2/m128", .orig_opcode = "66 0F FE /r",
		.desc = "Add packed doubleword integers from xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xFE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDD xmm1, xmm2/m128", .orig_opcode = "66 0F FE /r",
		.desc = "Add packed doubleword integers from xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xFE }, .oplen = 2,
	} } },
	{ "paddq", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDQ mm1, mm2/m64", .orig_opcode = "0F D4 /r",
		.desc = "Add quadword integer mm2/m64 to mm1.",
		.opcode = { 0x0F, 0xD4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDQ mm1, mm2/m64", .orig_opcode = "0F D4 /r",
		.desc = "Add quadword integer mm2/m64 to mm1.",
		.opcode = { 0x0F, 0xD4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDQ xmm1, xmm2/m128", .orig_opcode = "66 0F D4 /r",
		.desc = "Add packed quadword integers xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDQ xmm1, xmm2/m128", .orig_opcode = "66 0F D4 /r",
		.desc = "Add packed quadword integers xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD4 }, .oplen = 2,
	} } },
	{ "paddsb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDSB mm, mm/m64", .orig_opcode = "0F EC /r",
		.desc = "Add packed signed byte integers from mm/m64 and mm and saturate the results.",
		.opcode = { 0x0F, 0xEC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDSB mm, mm/m64", .orig_opcode = "0F EC /r",
		.desc = "Add packed signed byte integers from mm/m64 and mm and saturate the results.",
		.opcode = { 0x0F, 0xEC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDSB xmm1, xmm2/m128", .orig_opcode = "66 0F EC /r",
		.desc = "Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xEC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDSB xmm1, xmm2/m128", .orig_opcode = "66 0F EC /r",
		.desc = "Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xEC }, .oplen = 2,
	} } },
	{ "paddsw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDSW mm, mm/m64", .orig_opcode = "0F ED /r",
		.desc = "Add packed signed word integers from mm/m64 and mm and saturate the results.",
		.opcode = { 0x0F, 0xED }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDSW mm, mm/m64", .orig_opcode = "0F ED /r",
		.desc = "Add packed signed word integers from mm/m64 and mm and saturate the results.",
		.opcode = { 0x0F, 0xED }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDSW xmm1, xmm2/m128", .orig_opcode = "66 0F ED /r",
		.desc = "Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xED }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDSW xmm1, xmm2/m128", .orig_opcode = "66 0F ED /r",
		.desc = "Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xED }, .oplen = 2,
	} } },
	{ "paddusb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDUSB mm, mm/m64", .orig_opcode = "0F DC /r",
		.desc = "Add packed unsigned byte integers from mm/m64 and mm and saturate the results.",
		.opcode = { 0x0F, 0xDC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDUSB mm, mm/m64", .orig_opcode = "0F DC /r",
		.desc = "Add packed unsigned byte integers from mm/m64 and mm and saturate the results.",
		.opcode = { 0x0F, 0xDC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDUSB xmm1, xmm2/m128", .orig_opcode = "66 0F DC /r",
		.desc = "Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDUSB xmm1, xmm2/m128", .orig_opcode = "66 0F DC /r",
		.desc = "Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDC }, .oplen = 2,
	} } },
	{ "paddusw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDUSW mm, mm/m64", .orig_opcode = "0F DD /r",
		.desc = "Add packed unsigned word integers from mm/m64 and mm and saturate the results.",
		.opcode = { 0x0F, 0xDD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDUSW mm, mm/m64", .orig_opcode = "0F DD /r",
		.desc = "Add packed unsigned word integers from mm/m64 and mm and saturate the results.",
		.opcode = { 0x0F, 0xDD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDUSW xmm1, xmm2/m128", .orig_opcode = "66 0F DD /r",
		.desc = "Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDD }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PADDUSW xmm1, xmm2/m128", .orig_opcode = "66 0F DD /r",
		.desc = "Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDD }, .oplen = 2,
	} } },
	{ "palignr", 4, (struct x64LookupActualIns[]) { {
		.args = { MM, M64, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PALIGNR mm1, mm2/m64, imm8", .orig_opcode = "0F 3A 0F",
		.desc = "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1.",
		.opcode = { 0x0F, 0x3A, 0x0F }, .oplen = 3,
	}, {
		.args = { MM, MM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PALIGNR mm1, mm2/m64, imm8", .orig_opcode = "0F 3A 0F",
		.desc = "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1.",
		.opcode = { 0x0F, 0x3A, 0x0F }, .oplen = 3,
	}, {
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PALIGNR xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 0F",
		.desc = "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0F }, .oplen = 3,
	}, {
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PALIGNR xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 0F",
		.desc = "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0F }, .oplen = 3,
	} } },
	{ "pand", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAND mm, mm/m64", .orig_opcode = "0F DB /r",
		.desc = "Bitwise AND mm/m64 and mm.",
		.opcode = { 0x0F, 0xDB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAND mm, mm/m64", .orig_opcode = "0F DB /r",
		.desc = "Bitwise AND mm/m64 and mm.",
		.opcode = { 0x0F, 0xDB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAND xmm1, xmm2/m128", .orig_opcode = "66 0F DB /r",
		.desc = "Bitwise AND of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAND xmm1, xmm2/m128", .orig_opcode = "66 0F DB /r",
		.desc = "Bitwise AND of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDB }, .oplen = 2,
	} } },
	{ "pandn", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PANDN mm, mm/m64", .orig_opcode = "0F DF /r",
		.desc = "Bitwise AND NOT of mm/m64 and mm.",
		.opcode = { 0x0F, 0xDF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PANDN mm, mm/m64", .orig_opcode = "0F DF /r",
		.desc = "Bitwise AND NOT of mm/m64 and mm.",
		.opcode = { 0x0F, 0xDF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PANDN xmm1, xmm2/m128", .orig_opcode = "66 0F DF /r",
		.desc = "Bitwise AND NOT of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PANDN xmm1, xmm2/m128", .orig_opcode = "66 0F DF /r",
		.desc = "Bitwise AND NOT of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDF }, .oplen = 2,
	} } },
	{ "pause", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "PAUSE", .orig_opcode = "F3 90",
		.desc = "Gives hint to processor that improves performance of spin-wait loops.",
		.prefixes = 0xF3, .opcode = { 0x90 }, .oplen = 1,
	} } },
	{ "pavgb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAVGB mm1, mm2/m64", .orig_opcode = "0F E0 /r",
		.desc = "Average packed unsigned byte integers from mm2/m64 and mm1 with rounding.",
		.opcode = { 0x0F, 0xE0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAVGB mm1, mm2/m64", .orig_opcode = "0F E0 /r",
		.desc = "Average packed unsigned byte integers from mm2/m64 and mm1 with rounding.",
		.opcode = { 0x0F, 0xE0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAVGB xmm1, xmm2/m128", .orig_opcode = "66 0F E0 /r",
		.desc = "Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAVGB xmm1, xmm2/m128", .orig_opcode = "66 0F E0 /r",
		.desc = "Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE0 }, .oplen = 2,
	} } },
	{ "pavgw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAVGW mm1, mm2/m64", .orig_opcode = "0F E3 /r",
		.desc = "Average packed unsigned word integers from mm2/m64 and mm1 with rounding.",
		.opcode = { 0x0F, 0xE3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAVGW mm1, mm2/m64", .orig_opcode = "0F E3 /r",
		.desc = "Average packed unsigned word integers from mm2/m64 and mm1 with rounding.",
		.opcode = { 0x0F, 0xE3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAVGW xmm1, xmm2/m128", .orig_opcode = "66 0F E3 /r",
		.desc = "Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PAVGW xmm1, xmm2/m128", .orig_opcode = "66 0F E3 /r",
		.desc = "Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE3 }, .oplen = 2,
	} } },
	{ "pblendvb", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, XMM_0 }, .arglen = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PBLENDVB xmm1, xmm2/m128, <XMM0>", .orig_opcode = "66 0F 38 10 /r",
		.desc = "Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x10 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, XMM_0 }, .arglen = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PBLENDVB xmm1, xmm2/m128, <XMM0>", .orig_opcode = "66 0F 38 10 /r",
		.desc = "Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x10 }, .oplen = 3,
	} } },
	{ "pblendw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PBLENDW xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 0E /r ib",
		.desc = "Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0E }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PBLENDW xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 0E /r ib",
		.desc = "Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0E }, .oplen = 3,
	} } },
	{ "pclmulqdq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCLMULQDQ xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 44 /r ib",
		.desc = "Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x44 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCLMULQDQ xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 44 /r ib",
		.desc = "Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x44 }, .oplen = 3,
	} } },
	{ "pcmpeqb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQB mm, mm/m64", .orig_opcode = "0F 74 /r",
		.desc = "Compare packed bytes in mm/m64 and mm for equality.",
		.opcode = { 0x0F, 0x74 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQB mm, mm/m64", .orig_opcode = "0F 74 /r",
		.desc = "Compare packed bytes in mm/m64 and mm for equality.",
		.opcode = { 0x0F, 0x74 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQB xmm1, xmm2/m128", .orig_opcode = "66 0F 74 /r",
		.desc = "Compare packed bytes in xmm2/m128 and xmm1 for equality.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x74 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQB xmm1, xmm2/m128", .orig_opcode = "66 0F 74 /r",
		.desc = "Compare packed bytes in xmm2/m128 and xmm1 for equality.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x74 }, .oplen = 2,
	} } },
	{ "pcmpeqw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQW mm, mm/m64", .orig_opcode = "0F 75 /r",
		.desc = "Compare packed words in mm/m64 and mm for equality.",
		.opcode = { 0x0F, 0x75 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQW mm, mm/m64", .orig_opcode = "0F 75 /r",
		.desc = "Compare packed words in mm/m64 and mm for equality.",
		.opcode = { 0x0F, 0x75 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQW xmm1, xmm2/m128", .orig_opcode = "66 0F 75 /r",
		.desc = "Compare packed words in xmm2/m128 and xmm1 for equality.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x75 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQW xmm1, xmm2/m128", .orig_opcode = "66 0F 75 /r",
		.desc = "Compare packed words in xmm2/m128 and xmm1 for equality.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x75 }, .oplen = 2,
	} } },
	{ "pcmpeqd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQD mm, mm/m64", .orig_opcode = "0F 76 /r",
		.desc = "Compare packed doublewords in mm/m64 and mm for equality.",
		.opcode = { 0x0F, 0x76 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQD mm, mm/m64", .orig_opcode = "0F 76 /r",
		.desc = "Compare packed doublewords in mm/m64 and mm for equality.",
		.opcode = { 0x0F, 0x76 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQD xmm1, xmm2/m128", .orig_opcode = "66 0F 76 /r",
		.desc = "Compare packed doublewords in xmm2/m128 and xmm1 for equality.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x76 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQD xmm1, xmm2/m128", .orig_opcode = "66 0F 76 /r",
		.desc = "Compare packed doublewords in xmm2/m128 and xmm1 for equality.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x76 }, .oplen = 2,
	} } },
	{ "pcmpeqq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQQ xmm1, xmm2/m128", .orig_opcode = "66 0F 38 29 /r",
		.desc = "Compare packed qwords in xmm2/m128 and xmm1 for equality.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x29 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPEQQ xmm1, xmm2/m128", .orig_opcode = "66 0F 38 29 /r",
		.desc = "Compare packed qwords in xmm2/m128 and xmm1 for equality.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x29 }, .oplen = 3,
	} } },
	{ "pcmpestri", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPESTRI xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 61 /r",
		.desc = "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x61 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPESTRI xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 61 /r",
		.desc = "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x61 }, .oplen = 3,
	} } },
	{ "pcmpestrm", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPESTRM xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 60 /r",
		.desc = "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x60 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPESTRM xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 60 /r",
		.desc = "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x60 }, .oplen = 3,
	} } },
	{ "pcmpgtb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTB mm, mm/m64", .orig_opcode = "0F 64 /r",
		.desc = "Compare packed signed byte integers in mm and mm/m64 for greater than.",
		.opcode = { 0x0F, 0x64 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTB mm, mm/m64", .orig_opcode = "0F 64 /r",
		.desc = "Compare packed signed byte integers in mm and mm/m64 for greater than.",
		.opcode = { 0x0F, 0x64 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTB xmm1, xmm2/m128", .orig_opcode = "66 0F 64 /r",
		.desc = "Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x64 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTB xmm1, xmm2/m128", .orig_opcode = "66 0F 64 /r",
		.desc = "Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x64 }, .oplen = 2,
	} } },
	{ "pcmpgtw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTW mm, mm/m64", .orig_opcode = "0F 65 /r",
		.desc = "Compare packed signed word integers in mm and mm/m64 for greater than.",
		.opcode = { 0x0F, 0x65 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTW mm, mm/m64", .orig_opcode = "0F 65 /r",
		.desc = "Compare packed signed word integers in mm and mm/m64 for greater than.",
		.opcode = { 0x0F, 0x65 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTW xmm1, xmm2/m128", .orig_opcode = "66 0F 65 /r",
		.desc = "Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x65 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTW xmm1, xmm2/m128", .orig_opcode = "66 0F 65 /r",
		.desc = "Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x65 }, .oplen = 2,
	} } },
	{ "pcmpgtd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTD mm, mm/m64", .orig_opcode = "0F 66 /r",
		.desc = "Compare packed signed doubleword integers in mm and mm/m64 for greater than.",
		.opcode = { 0x0F, 0x66 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTD mm, mm/m64", .orig_opcode = "0F 66 /r",
		.desc = "Compare packed signed doubleword integers in mm and mm/m64 for greater than.",
		.opcode = { 0x0F, 0x66 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTD xmm1, xmm2/m128", .orig_opcode = "66 0F 66 /r",
		.desc = "Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x66 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTD xmm1, xmm2/m128", .orig_opcode = "66 0F 66 /r",
		.desc = "Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x66 }, .oplen = 2,
	} } },
	{ "pcmpgtq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTQ xmm1, xmm2/m128", .orig_opcode = "66 0F 38 37 /r",
		.desc = "Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x37 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPGTQ xmm1, xmm2/m128", .orig_opcode = "66 0F 38 37 /r",
		.desc = "Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x37 }, .oplen = 3,
	} } },
	{ "pcmpistri", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPISTRI xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 63 /r",
		.desc = "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x63 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPISTRI xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 63 /r",
		.desc = "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x63 }, .oplen = 3,
	} } },
	{ "pcmpistrm", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPISTRM xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 62 /r",
		.desc = "Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x62 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PCMPISTRM xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 62 /r",
		.desc = "Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x62 }, .oplen = 3,
	} } },
	{ "pextrb", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "PEXTRB reg/m8, xmm2, imm8", .orig_opcode = "66 0F 3A 14 /r ib",
		.desc = "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8. The upper bits of r32 or r64 are zeroed.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x14 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "PEXTRB reg/m8, xmm2, imm8", .orig_opcode = "66 0F 3A 14 /r ib",
		.desc = "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8. The upper bits of r32 or r64 are zeroed.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x14 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "PEXTRB reg/m8, xmm2, imm8", .orig_opcode = "66 0F 3A 14 /r ib",
		.desc = "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8. The upper bits of r32 or r64 are zeroed.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x14 }, .oplen = 3,
	} } },
	{ "pextrd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "PEXTRD r/m32, xmm2, imm8", .orig_opcode = "66 0F 3A 16 /r ib",
		.desc = "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x16 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "PEXTRD r/m32, xmm2, imm8", .orig_opcode = "66 0F 3A 16 /r ib",
		.desc = "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x16 }, .oplen = 3,
	} } },
	{ "pextrq", 2, (struct x64LookupActualIns[]) { {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "PEXTRQ r/m64, xmm2, imm8", .orig_opcode = "66 REX.W+ 0F 3A 16 /r ib",
		.desc = "Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x16 }, .oplen = 3,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "PEXTRQ r/m64, xmm2, imm8", .orig_opcode = "66 REX.W+ 0F 3A 16 /r ib",
		.desc = "Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x16 }, .oplen = 3,
	} } },
	{ "pextrw", 7, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, MM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PEXTRW reg, mm, imm8", .orig_opcode = "0F C5 /r ib",
		.desc = "Extract the word specified by imm8 from mm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.",
		.opcode = { 0x0F, 0xC5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, MM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PEXTRW reg, mm, imm8", .orig_opcode = "0F C5 /r ib",
		.desc = "Extract the word specified by imm8 from mm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.",
		.opcode = { 0x0F, 0xC5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PEXTRW reg, xmm, imm8", .orig_opcode = "66 0F C5 /r ib",
		.desc = "Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC5 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PEXTRW reg, xmm, imm8", .orig_opcode = "66 0F C5 /r ib",
		.desc = "Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC5 }, .oplen = 2,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "PEXTRW reg/m16, xmm, imm8", .orig_opcode = "66 0F 3A 15 /r ib",
		.desc = "Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x15 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M128, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "PEXTRW reg/m16, xmm, imm8", .orig_opcode = "66 0F 3A 15 /r ib",
		.desc = "Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x15 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "PEXTRW reg/m16, xmm, imm8", .orig_opcode = "66 0F 3A 15 /r ib",
		.desc = "Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x15 }, .oplen = 3,
	} } },
	{ "phaddw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDW mm1, mm2/m64", .orig_opcode = "0F 38 01 /r",
		.desc = "Add 16-bit integers horizontally, pack to MM1.",
		.opcode = { 0x0F, 0x38, 0x01 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDW mm1, mm2/m64", .orig_opcode = "0F 38 01 /r",
		.desc = "Add 16-bit integers horizontally, pack to MM1.",
		.opcode = { 0x0F, 0x38, 0x01 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 01 /r",
		.desc = "Add 16-bit integers horizontally, pack to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x01 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 01 /r",
		.desc = "Add 16-bit integers horizontally, pack to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x01 }, .oplen = 3,
	} } },
	{ "phaddd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDD mm1, mm2/m64", .orig_opcode = "0F 38 02 /r",
		.desc = "Add 32-bit integers horizontally, pack to MM1.",
		.opcode = { 0x0F, 0x38, 0x02 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDD mm1, mm2/m64", .orig_opcode = "0F 38 02 /r",
		.desc = "Add 32-bit integers horizontally, pack to MM1.",
		.opcode = { 0x0F, 0x38, 0x02 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 02 /r",
		.desc = "Add 32-bit integers horizontally, pack to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x02 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 02 /r",
		.desc = "Add 32-bit integers horizontally, pack to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x02 }, .oplen = 3,
	} } },
	{ "phaddsw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDSW mm1, mm2/m64", .orig_opcode = "0F 38 03 /r",
		.desc = "Add 16-bit signed integers horizontally, pack saturated integers to MM1.",
		.opcode = { 0x0F, 0x38, 0x03 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDSW mm1, mm2/m64", .orig_opcode = "0F 38 03 /r",
		.desc = "Add 16-bit signed integers horizontally, pack saturated integers to MM1.",
		.opcode = { 0x0F, 0x38, 0x03 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDSW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 03 /r",
		.desc = "Add 16-bit signed integers horizontally, pack saturated integers to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x03 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHADDSW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 03 /r",
		.desc = "Add 16-bit signed integers horizontally, pack saturated integers to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x03 }, .oplen = 3,
	} } },
	{ "phminposuw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHMINPOSUW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 41 /r",
		.desc = "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x41 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHMINPOSUW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 41 /r",
		.desc = "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x41 }, .oplen = 3,
	} } },
	{ "phsubw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBW mm1, mm2/m64", .orig_opcode = "0F 38 05 /r",
		.desc = "Subtract 16-bit signed integers horizontally, pack to MM1.",
		.opcode = { 0x0F, 0x38, 0x05 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBW mm1, mm2/m64", .orig_opcode = "0F 38 05 /r",
		.desc = "Subtract 16-bit signed integers horizontally, pack to MM1.",
		.opcode = { 0x0F, 0x38, 0x05 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 05 /r",
		.desc = "Subtract 16-bit signed integers horizontally, pack to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x05 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 05 /r",
		.desc = "Subtract 16-bit signed integers horizontally, pack to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x05 }, .oplen = 3,
	} } },
	{ "phsubd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBD mm1, mm2/m64", .orig_opcode = "0F 38 06 /r",
		.desc = "Subtract 32-bit signed integers horizontally, pack to MM1.",
		.opcode = { 0x0F, 0x38, 0x06 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBD mm1, mm2/m64", .orig_opcode = "0F 38 06 /r",
		.desc = "Subtract 32-bit signed integers horizontally, pack to MM1.",
		.opcode = { 0x0F, 0x38, 0x06 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 06 /r",
		.desc = "Subtract 32-bit signed integers horizontally, pack to XMM1",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x06 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 06 /r",
		.desc = "Subtract 32-bit signed integers horizontally, pack to XMM1",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x06 }, .oplen = 3,
	} } },
	{ "phsubsw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBSW mm1, mm2/m64", .orig_opcode = "0F 38 07 /r",
		.desc = "Subtract 16-bit signed integer horizontally, pack saturated integers to MM1.",
		.opcode = { 0x0F, 0x38, 0x07 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBSW mm1, mm2/m64", .orig_opcode = "0F 38 07 /r",
		.desc = "Subtract 16-bit signed integer horizontally, pack saturated integers to MM1.",
		.opcode = { 0x0F, 0x38, 0x07 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBSW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 07 /r",
		.desc = "Subtract 16-bit signed integer horizontally, pack saturated integers to XMM1",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x07 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PHSUBSW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 07 /r",
		.desc = "Subtract 16-bit signed integer horizontally, pack saturated integers to XMM1",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x07 }, .oplen = 3,
	} } },
	{ "pinsrb", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M8, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PINSRB xmm1, r32/m8, imm8", .orig_opcode = "66 0F 3A 20 /r ib",
		.desc = "Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x20 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, R32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PINSRB xmm1, r32/m8, imm8", .orig_opcode = "66 0F 3A 20 /r ib",
		.desc = "Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x20 }, .oplen = 3,
	} } },
	{ "pinsrd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PINSRD xmm1, r/m32, imm8", .orig_opcode = "66 0F 3A 22 /r ib",
		.desc = "Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x22 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, R32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PINSRD xmm1, r/m32, imm8", .orig_opcode = "66 0F 3A 22 /r ib",
		.desc = "Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x22 }, .oplen = 3,
	} } },
	{ "pinsrw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PINSRW mm, r32/m16, imm8", .orig_opcode = "0F C4 /r ib",
		.desc = "Insert the low word from r32 or from m16 into mm at the word position specified by imm8",
		.opcode = { 0x0F, 0xC4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, R32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PINSRW mm, r32/m16, imm8", .orig_opcode = "0F C4 /r ib",
		.desc = "Insert the low word from r32 or from m16 into mm at the word position specified by imm8",
		.opcode = { 0x0F, 0xC4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PINSRW xmm, r32/m16, imm8", .orig_opcode = "66 0F C4 /r ib",
		.desc = "Move the low word of r32 or from m16 into xmm at the word position specified by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, R32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PINSRW xmm, r32/m16, imm8", .orig_opcode = "66 0F C4 /r ib",
		.desc = "Move the low word of r32 or from m16 into xmm at the word position specified by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC4 }, .oplen = 2,
	} } },
	{ "pmaddubsw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMADDUBSW mm1, mm2/m64", .orig_opcode = "0F 38 04 /r",
		.desc = "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to MM1.",
		.opcode = { 0x0F, 0x38, 0x04 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMADDUBSW mm1, mm2/m64", .orig_opcode = "0F 38 04 /r",
		.desc = "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to MM1.",
		.opcode = { 0x0F, 0x38, 0x04 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMADDUBSW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 04 /r",
		.desc = "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x04 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMADDUBSW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 04 /r",
		.desc = "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x04 }, .oplen = 3,
	} } },
	{ "pmaddwd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMADDWD mm, mm/m64", .orig_opcode = "0F F5 /r",
		.desc = "Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm.",
		.opcode = { 0x0F, 0xF5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMADDWD mm, mm/m64", .orig_opcode = "0F F5 /r",
		.desc = "Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm.",
		.opcode = { 0x0F, 0xF5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMADDWD xmm1, xmm2/m128", .orig_opcode = "66 0F F5 /r",
		.desc = "Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMADDWD xmm1, xmm2/m128", .orig_opcode = "66 0F F5 /r",
		.desc = "Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF5 }, .oplen = 2,
	} } },
	{ "pmaxsb", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXSB xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3C /r",
		.desc = "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3C }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXSB xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3C /r",
		.desc = "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3C }, .oplen = 3,
	} } },
	{ "pmaxsd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXSD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3D /r",
		.desc = "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3D }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXSD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3D /r",
		.desc = "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3D }, .oplen = 3,
	} } },
	{ "pmaxsw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXSW mm1, mm2/m64", .orig_opcode = "0F EE /r",
		.desc = "Compare signed word integers in mm2/m64 and mm1 and return maximum values.",
		.opcode = { 0x0F, 0xEE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXSW mm1, mm2/m64", .orig_opcode = "0F EE /r",
		.desc = "Compare signed word integers in mm2/m64 and mm1 and return maximum values.",
		.opcode = { 0x0F, 0xEE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXSW xmm1, xmm2/m128", .orig_opcode = "66 0F EE /r",
		.desc = "Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xEE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXSW xmm1, xmm2/m128", .orig_opcode = "66 0F EE /r",
		.desc = "Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xEE }, .oplen = 2,
	} } },
	{ "pmaxub", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXUB mm1, mm2/m64", .orig_opcode = "0F DE /r",
		.desc = "Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values.",
		.opcode = { 0x0F, 0xDE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXUB mm1, mm2/m64", .orig_opcode = "0F DE /r",
		.desc = "Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values.",
		.opcode = { 0x0F, 0xDE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXUB xmm1, xmm2/m128", .orig_opcode = "66 0F DE /r",
		.desc = "Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXUB xmm1, xmm2/m128", .orig_opcode = "66 0F DE /r",
		.desc = "Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDE }, .oplen = 2,
	} } },
	{ "pmaxud", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXUD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3F /r",
		.desc = "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3F }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXUD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3F /r",
		.desc = "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3F }, .oplen = 3,
	} } },
	{ "pmaxuw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXUW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3E /r",
		.desc = "Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3E }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMAXUW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3E /r",
		.desc = "Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3E }, .oplen = 3,
	} } },
	{ "pminsb", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINSB xmm1, xmm2/m128", .orig_opcode = "66 0F 38 38 /r",
		.desc = "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x38 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINSB xmm1, xmm2/m128", .orig_opcode = "66 0F 38 38 /r",
		.desc = "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x38 }, .oplen = 3,
	} } },
	{ "pminsd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINSD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 39 /r",
		.desc = "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x39 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINSD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 39 /r",
		.desc = "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x39 }, .oplen = 3,
	} } },
	{ "pminsw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINSW mm1, mm2/m64", .orig_opcode = "0F EA /r",
		.desc = "Compare signed word integers in mm2/m64 and mm1 and return minimum values.",
		.opcode = { 0x0F, 0xEA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINSW mm1, mm2/m64", .orig_opcode = "0F EA /r",
		.desc = "Compare signed word integers in mm2/m64 and mm1 and return minimum values.",
		.opcode = { 0x0F, 0xEA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINSW xmm1, xmm2/m128", .orig_opcode = "66 0F EA /r",
		.desc = "Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xEA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINSW xmm1, xmm2/m128", .orig_opcode = "66 0F EA /r",
		.desc = "Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xEA }, .oplen = 2,
	} } },
	{ "pminub", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINUB mm1, mm2/m64", .orig_opcode = "0F DA /r",
		.desc = "Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values.",
		.opcode = { 0x0F, 0xDA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINUB mm1, mm2/m64", .orig_opcode = "0F DA /r",
		.desc = "Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values.",
		.opcode = { 0x0F, 0xDA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINUB xmm1, xmm2/m128", .orig_opcode = "66 0F DA /r",
		.desc = "Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINUB xmm1, xmm2/m128", .orig_opcode = "66 0F DA /r",
		.desc = "Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xDA }, .oplen = 2,
	} } },
	{ "pminud", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINUD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3B /r",
		.desc = "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3B }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINUD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3B /r",
		.desc = "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3B }, .oplen = 3,
	} } },
	{ "pminuw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINUW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3A /r",
		.desc = "Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3A }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMINUW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 3A /r",
		.desc = "Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x3A }, .oplen = 3,
	} } },
	{ "pmovmskb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVMSKB reg, mm", .orig_opcode = "0F D7 /r",
		.desc = "Move a byte mask of mm to reg. The upper bits of r32 or r64 are zeroed",
		.opcode = { 0x0F, 0xD7 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVMSKB reg, mm", .orig_opcode = "0F D7 /r",
		.desc = "Move a byte mask of mm to reg. The upper bits of r32 or r64 are zeroed",
		.opcode = { 0x0F, 0xD7 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVMSKB reg, xmm", .orig_opcode = "66 0F D7 /r",
		.desc = "Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD7 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R64, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVMSKB reg, xmm", .orig_opcode = "66 0F D7 /r",
		.desc = "Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD7 }, .oplen = 2,
	} } },
	{ "pmovsxbw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXBW xmm1, xmm2/m64", .orig_opcode = "66 0f 38 20 /r",
		.desc = "Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x20 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXBW xmm1, xmm2/m64", .orig_opcode = "66 0f 38 20 /r",
		.desc = "Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x20 }, .oplen = 2,
	} } },
	{ "pmovsxbd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXBD xmm1, xmm2/m32", .orig_opcode = "66 0f 38 21 /r",
		.desc = "Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x21 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXBD xmm1, xmm2/m32", .orig_opcode = "66 0f 38 21 /r",
		.desc = "Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x21 }, .oplen = 2,
	} } },
	{ "pmovsxbq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXBQ xmm1, xmm2/m16", .orig_opcode = "66 0f 38 22 /r",
		.desc = "Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x22 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXBQ xmm1, xmm2/m16", .orig_opcode = "66 0f 38 22 /r",
		.desc = "Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x22 }, .oplen = 2,
	} } },
	{ "pmovsxwd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXWD xmm1, xmm2/m64", .orig_opcode = "66 0f 38 23 /r",
		.desc = "Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x23 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXWD xmm1, xmm2/m64", .orig_opcode = "66 0f 38 23 /r",
		.desc = "Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x23 }, .oplen = 2,
	} } },
	{ "pmovsxwq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXWQ xmm1, xmm2/m32", .orig_opcode = "66 0f 38 24 /r",
		.desc = "Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x24 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXWQ xmm1, xmm2/m32", .orig_opcode = "66 0f 38 24 /r",
		.desc = "Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x24 }, .oplen = 2,
	} } },
	{ "pmovsxdq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXDQ xmm1, xmm2/m64", .orig_opcode = "66 0f 38 25 /r",
		.desc = "Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x25 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVSXDQ xmm1, xmm2/m64", .orig_opcode = "66 0f 38 25 /r",
		.desc = "Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x25 }, .oplen = 2,
	} } },
	{ "pmovzxbw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXBW xmm1, xmm2/m64", .orig_opcode = "66 0f 38 30 /r",
		.desc = "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x30 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXBW xmm1, xmm2/m64", .orig_opcode = "66 0f 38 30 /r",
		.desc = "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x30 }, .oplen = 2,
	} } },
	{ "pmovzxbd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXBD xmm1, xmm2/m32", .orig_opcode = "66 0f 38 31 /r",
		.desc = "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x31 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXBD xmm1, xmm2/m32", .orig_opcode = "66 0f 38 31 /r",
		.desc = "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x31 }, .oplen = 2,
	} } },
	{ "pmovzxbq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXBQ xmm1, xmm2/m16", .orig_opcode = "66 0f 38 32 /r",
		.desc = "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x32 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXBQ xmm1, xmm2/m16", .orig_opcode = "66 0f 38 32 /r",
		.desc = "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x32 }, .oplen = 2,
	} } },
	{ "pmovzxwd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXWD xmm1, xmm2/m64", .orig_opcode = "66 0f 38 33 /r",
		.desc = "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x33 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXWD xmm1, xmm2/m64", .orig_opcode = "66 0f 38 33 /r",
		.desc = "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x33 }, .oplen = 2,
	} } },
	{ "pmovzxwq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXWQ xmm1, xmm2/m32", .orig_opcode = "66 0f 38 34 /r",
		.desc = "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x34 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXWQ xmm1, xmm2/m32", .orig_opcode = "66 0f 38 34 /r",
		.desc = "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x34 }, .oplen = 2,
	} } },
	{ "pmovzxdq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXDQ xmm1, xmm2/m64", .orig_opcode = "66 0f 38 35 /r",
		.desc = "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x35 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMOVZXDQ xmm1, xmm2/m64", .orig_opcode = "66 0f 38 35 /r",
		.desc = "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x38, 0x35 }, .oplen = 2,
	} } },
	{ "pmuldq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULDQ xmm1, xmm2/m128", .orig_opcode = "66 0F 38 28 /r",
		.desc = "Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x28 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULDQ xmm1, xmm2/m128", .orig_opcode = "66 0F 38 28 /r",
		.desc = "Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x28 }, .oplen = 3,
	} } },
	{ "pmulhrsw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHRSW mm1, mm2/m64", .orig_opcode = "0F 38 0B /r",
		.desc = "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to MM1.",
		.opcode = { 0x0F, 0x38, 0x0B }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHRSW mm1, mm2/m64", .orig_opcode = "0F 38 0B /r",
		.desc = "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to MM1.",
		.opcode = { 0x0F, 0x38, 0x0B }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHRSW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 0B /r",
		.desc = "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x0B }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHRSW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 0B /r",
		.desc = "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to XMM1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x0B }, .oplen = 3,
	} } },
	{ "pmulhuw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHUW mm1, mm2/m64", .orig_opcode = "0F E4 /r",
		.desc = "Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.",
		.opcode = { 0x0F, 0xE4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHUW mm1, mm2/m64", .orig_opcode = "0F E4 /r",
		.desc = "Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.",
		.opcode = { 0x0F, 0xE4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHUW xmm1, xmm2/m128", .orig_opcode = "66 0F E4 /r",
		.desc = "Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHUW xmm1, xmm2/m128", .orig_opcode = "66 0F E4 /r",
		.desc = "Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE4 }, .oplen = 2,
	} } },
	{ "pmulhw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHW mm, mm/m64", .orig_opcode = "0F E5 /r",
		.desc = "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.",
		.opcode = { 0x0F, 0xE5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHW mm, mm/m64", .orig_opcode = "0F E5 /r",
		.desc = "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.",
		.opcode = { 0x0F, 0xE5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHW xmm1, xmm2/m128", .orig_opcode = "66 0F E5 /r",
		.desc = "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULHW xmm1, xmm2/m128", .orig_opcode = "66 0F E5 /r",
		.desc = "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE5 }, .oplen = 2,
	} } },
	{ "pmulld", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULLD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 40 /r",
		.desc = "Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x40 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULLD xmm1, xmm2/m128", .orig_opcode = "66 0F 38 40 /r",
		.desc = "Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x40 }, .oplen = 3,
	} } },
	{ "pmullw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULLW mm, mm/m64", .orig_opcode = "0F D5 /r",
		.desc = "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1.",
		.opcode = { 0x0F, 0xD5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULLW mm, mm/m64", .orig_opcode = "0F D5 /r",
		.desc = "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1.",
		.opcode = { 0x0F, 0xD5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULLW xmm1, xmm2/m128", .orig_opcode = "66 0F D5 /r",
		.desc = "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD5 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULLW xmm1, xmm2/m128", .orig_opcode = "66 0F D5 /r",
		.desc = "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD5 }, .oplen = 2,
	} } },
	{ "pmuludq", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULUDQ mm1, mm2/m64", .orig_opcode = "0F F4 /r",
		.desc = "Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1.",
		.opcode = { 0x0F, 0xF4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULUDQ mm1, mm2/m64", .orig_opcode = "0F F4 /r",
		.desc = "Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1.",
		.opcode = { 0x0F, 0xF4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULUDQ xmm1, xmm2/m128", .orig_opcode = "66 0F F4 /r",
		.desc = "Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF4 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PMULUDQ xmm1, xmm2/m128", .orig_opcode = "66 0F F4 /r",
		.desc = "Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF4 }, .oplen = 2,
	} } },
	{ "pop", 10, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "POP r/m16", .orig_opcode = "8F /0",
		.desc = "Pop top of stack into m16; increment stack pointer.",
		.prefixes = 0x66, .opcode = { 0x8F }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "POP r/m16", .orig_opcode = "8F /0",
		.desc = "Pop top of stack into m16; increment stack pointer.",
		.prefixes = 0x66, .opcode = { 0x8F }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "POP r/m64", .orig_opcode = "8F /0",
		.desc = "Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size.",
		.opcode = { 0x8F }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "POP r/m64", .orig_opcode = "8F /0",
		.desc = "Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size.",
		.opcode = { 0x8F }, .oplen = 1,
	}, {
		.args = { R16 }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "POP r16", .orig_opcode = "58 +rw",
		.desc = "Pop top of stack into r16; increment stack pointer.",
		.prefixes = 0x66, .opcode = { 0x58 }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { R64 }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "POP r64", .orig_opcode = "58 +rd",
		.desc = "Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size.",
		.opcode = { 0x58 }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { FS, PREF66 }, .arglen = 2,
		.orig_ins = "POP FS, p66", .orig_opcode = "PREF.66+ 0F A1",
		.desc = "Pop top of stack into FS; increment stack pointer by 16 bits.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xA1 }, .oplen = 2,
	}, {
		.args = { FS }, .arglen = 1,
		.orig_ins = "POP FS", .orig_opcode = "0F A1",
		.desc = "Pop top of stack into FS; increment stack pointer by 64 bits.",
		.opcode = { 0x0F, 0xA1 }, .oplen = 2,
	}, {
		.args = { GS, PREF66 }, .arglen = 2,
		.orig_ins = "POP GS, p66", .orig_opcode = "PREF.66+ 0F A9",
		.desc = "Pop top of stack into GS; increment stack pointer by 16 bits.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xA9 }, .oplen = 2,
	}, {
		.args = { GS }, .arglen = 1,
		.orig_ins = "POP GS", .orig_opcode = "0F A9",
		.desc = "Pop top of stack into GS; increment stack pointer by 64 bits.",
		.opcode = { 0x0F, 0xA9 }, .oplen = 2,
	} } },
	{ "popcnt", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "POPCNT r16, r/m16", .orig_opcode = "F3 0F B8 /r",
		.desc = "POPCNT on r/m16",
		.prefixes = 0x66F3, .opcode = { 0x0F, 0xB8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "POPCNT r16, r/m16", .orig_opcode = "F3 0F B8 /r",
		.desc = "POPCNT on r/m16",
		.prefixes = 0x66F3, .opcode = { 0x0F, 0xB8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "POPCNT r32, r/m32", .orig_opcode = "F3 0F B8 /r",
		.desc = "POPCNT on r/m32",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xB8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "POPCNT r32, r/m32", .orig_opcode = "F3 0F B8 /r",
		.desc = "POPCNT on r/m32",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xB8 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "POPCNT r64, r/m64", .orig_opcode = "F3 REX.W+ 0F B8 /r",
		.desc = "POPCNT on r/m64",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xB8 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "POPCNT r64, r/m64", .orig_opcode = "F3 REX.W+ 0F B8 /r",
		.desc = "POPCNT on r/m64",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xB8 }, .oplen = 2,
	} } },
	{ "popf", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "POPF", .orig_opcode = "66 9D",
		.desc = "Pop top of stack into lower 16 bits of EFLAGS.",
		.prefixes = 0x66, .opcode = { 0x9D }, .oplen = 1,
	} } },
	{ "popfq", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "POPFQ", .orig_opcode = "9D",
		.desc = "Pop top of stack and zero-extend into RFLAGS.",
		.opcode = { 0x9D }, .oplen = 1,
	} } },
	{ "por", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "POR mm, mm/m64", .orig_opcode = "0F EB /r",
		.desc = "Bitwise OR of mm/m64 and mm.",
		.opcode = { 0x0F, 0xEB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "POR mm, mm/m64", .orig_opcode = "0F EB /r",
		.desc = "Bitwise OR of mm/m64 and mm.",
		.opcode = { 0x0F, 0xEB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "POR xmm1, xmm2/m128", .orig_opcode = "66 0F EB /r",
		.desc = "Bitwise OR of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xEB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "POR xmm1, xmm2/m128", .orig_opcode = "66 0F EB /r",
		.desc = "Bitwise OR of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xEB }, .oplen = 2,
	} } },
	{ "prefetcht0", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "PREFETCHT0 m8", .orig_opcode = "0F 18 /1",
		.desc = "Move data from m8 closer to the processor using T0 hint.",
		.opcode = { 0x0F, 0x18 }, .oplen = 2,
	} } },
	{ "prefetcht1", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "PREFETCHT1 m8", .orig_opcode = "0F 18 /2",
		.desc = "Move data from m8 closer to the processor using T1 hint.",
		.opcode = { 0x0F, 0x18 }, .oplen = 2,
	} } },
	{ "prefetcht2", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "PREFETCHT2 m8", .orig_opcode = "0F 18 /3",
		.desc = "Move data from m8 closer to the processor using T2 hint.",
		.opcode = { 0x0F, 0x18 }, .oplen = 2,
	} } },
	{ "prefetchnta", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "PREFETCHNTA m8", .orig_opcode = "0F 18 /0",
		.desc = "Move data from m8 closer to the processor using NTA hint.",
		.opcode = { 0x0F, 0x18 }, .oplen = 2,
	} } },
	{ "psadbw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSADBW mm1, mm2/m64", .orig_opcode = "0F F6 /r",
		.desc = "Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result.",
		.opcode = { 0x0F, 0xF6 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSADBW mm1, mm2/m64", .orig_opcode = "0F F6 /r",
		.desc = "Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result.",
		.opcode = { 0x0F, 0xF6 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSADBW xmm1, xmm2/m128", .orig_opcode = "66 0F F6 /r",
		.desc = "Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF6 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSADBW xmm1, xmm2/m128", .orig_opcode = "66 0F F6 /r",
		.desc = "Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF6 }, .oplen = 2,
	} } },
	{ "pshufb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFB mm1, mm2/m64", .orig_opcode = "0F 38 00 /r",
		.desc = "Shuffle bytes in mm1 according to contents of mm2/m64.",
		.opcode = { 0x0F, 0x38, 0x00 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFB mm1, mm2/m64", .orig_opcode = "0F 38 00 /r",
		.desc = "Shuffle bytes in mm1 according to contents of mm2/m64.",
		.opcode = { 0x0F, 0x38, 0x00 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFB xmm1, xmm2/m128", .orig_opcode = "66 0F 38 00 /r",
		.desc = "Shuffle bytes in xmm1 according to contents of xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x00 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFB xmm1, xmm2/m128", .orig_opcode = "66 0F 38 00 /r",
		.desc = "Shuffle bytes in xmm1 according to contents of xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x00 }, .oplen = 3,
	} } },
	{ "pshufd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 70 /r ib",
		.desc = "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x70 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 70 /r ib",
		.desc = "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x70 }, .oplen = 2,
	} } },
	{ "pshufhw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFHW xmm1, xmm2/m128, imm8", .orig_opcode = "F3 0F 70 /r ib",
		.desc = "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x70 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFHW xmm1, xmm2/m128, imm8", .orig_opcode = "F3 0F 70 /r ib",
		.desc = "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x70 }, .oplen = 2,
	} } },
	{ "pshuflw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFLW xmm1, xmm2/m128, imm8", .orig_opcode = "F2 0F 70 /r ib",
		.desc = "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x70 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFLW xmm1, xmm2/m128, imm8", .orig_opcode = "F2 0F 70 /r ib",
		.desc = "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x70 }, .oplen = 2,
	} } },
	{ "pshufw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFW mm1, mm2/m64, imm8", .orig_opcode = "0F 70 /r ib",
		.desc = "Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1.",
		.opcode = { 0x0F, 0x70 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSHUFW mm1, mm2/m64, imm8", .orig_opcode = "0F 70 /r ib",
		.desc = "Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1.",
		.opcode = { 0x0F, 0x70 }, .oplen = 2,
	} } },
	{ "psignb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGNB mm1, mm2/m64", .orig_opcode = "0F 38 08 /r",
		.desc = "Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64",
		.opcode = { 0x0F, 0x38, 0x08 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGNB mm1, mm2/m64", .orig_opcode = "0F 38 08 /r",
		.desc = "Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64",
		.opcode = { 0x0F, 0x38, 0x08 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGNB xmm1, xmm2/m128", .orig_opcode = "66 0F 38 08 /r",
		.desc = "Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x08 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGNB xmm1, xmm2/m128", .orig_opcode = "66 0F 38 08 /r",
		.desc = "Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x08 }, .oplen = 3,
	} } },
	{ "psignw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGNW mm1, mm2/m64", .orig_opcode = "0F 38 09 /r",
		.desc = "Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128.",
		.opcode = { 0x0F, 0x38, 0x09 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGNW mm1, mm2/m64", .orig_opcode = "0F 38 09 /r",
		.desc = "Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128.",
		.opcode = { 0x0F, 0x38, 0x09 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGNW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 09 /r",
		.desc = "Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x09 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGNW xmm1, xmm2/m128", .orig_opcode = "66 0F 38 09 /r",
		.desc = "Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x09 }, .oplen = 3,
	} } },
	{ "psignd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGND mm1, mm2/m64", .orig_opcode = "0F 38 0A /r",
		.desc = "Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128.",
		.opcode = { 0x0F, 0x38, 0x0A }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGND mm1, mm2/m64", .orig_opcode = "0F 38 0A /r",
		.desc = "Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128.",
		.opcode = { 0x0F, 0x38, 0x0A }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGND xmm1, xmm2/m128", .orig_opcode = "66 0F 38 0A /r",
		.desc = "Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x0A }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSIGND xmm1, xmm2/m128", .orig_opcode = "66 0F 38 0A /r",
		.desc = "Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x0A }, .oplen = 3,
	} } },
	{ "pslldq", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { XMM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSLLDQ xmm1, imm8", .orig_opcode = "66 0F 73 /7 ib",
		.desc = "Shift xmm1 left by imm8 bytes while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x73 }, .oplen = 2,
	} } },
	{ "psllw", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLW mm, mm/m64", .orig_opcode = "0F F1 /r",
		.desc = "Shift words in mm left mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xF1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLW mm, mm/m64", .orig_opcode = "0F F1 /r",
		.desc = "Shift words in mm left mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xF1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLW xmm1, xmm2/m128", .orig_opcode = "66 0F F1 /r",
		.desc = "Shift words in xmm1 left by xmm2/m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLW xmm1, xmm2/m128", .orig_opcode = "66 0F F1 /r",
		.desc = "Shift words in xmm1 left by xmm2/m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { MM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSLLW mm1, imm8", .orig_opcode = "0F 71 /6 ib",
		.desc = "Shift words in mm left by imm8 while shifting in 0s.",
		.opcode = { 0x0F, 0x71 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { XMM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSLLW xmm1, imm8", .orig_opcode = "66 0F 71 /6 ib",
		.desc = "Shift words in xmm1 left by imm8 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x71 }, .oplen = 2,
		.preffered = true,
	} } },
	{ "pslld", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLD mm, mm/m64", .orig_opcode = "0F F2 /r",
		.desc = "Shift doublewords in mm left by mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xF2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLD mm, mm/m64", .orig_opcode = "0F F2 /r",
		.desc = "Shift doublewords in mm left by mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xF2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLD xmm1, xmm2/m128", .orig_opcode = "66 0F F2 /r",
		.desc = "Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLD xmm1, xmm2/m128", .orig_opcode = "66 0F F2 /r",
		.desc = "Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { MM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSLLD mm, imm8", .orig_opcode = "0F 72 /6 ib",
		.desc = "Shift doublewords in mm left by imm8 while shifting in 0s.",
		.opcode = { 0x0F, 0x72 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { XMM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSLLD xmm1, imm8", .orig_opcode = "66 0F 72 /6 ib",
		.desc = "Shift doublewords in xmm1 left by imm8 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x72 }, .oplen = 2,
	} } },
	{ "psllq", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLQ mm, mm/m64", .orig_opcode = "0F F3 /r",
		.desc = "Shift quadword in mm left by mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xF3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLQ mm, mm/m64", .orig_opcode = "0F F3 /r",
		.desc = "Shift quadword in mm left by mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xF3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLQ xmm1, xmm2/m128", .orig_opcode = "66 0F F3 /r",
		.desc = "Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSLLQ xmm1, xmm2/m128", .orig_opcode = "66 0F F3 /r",
		.desc = "Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { MM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSLLQ mm, imm8", .orig_opcode = "0F 73 /6 ib",
		.desc = "Shift quadword in mm left by imm8 while shifting in 0s.",
		.opcode = { 0x0F, 0x73 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { XMM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSLLQ xmm1, imm8", .orig_opcode = "66 0F 73 /6 ib",
		.desc = "Shift quadwords in xmm1 left by imm8 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x73 }, .oplen = 2,
	} } },
	{ "psraw", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRAW mm, mm/m64", .orig_opcode = "0F E1 /r",
		.desc = "Shift words in mm right by mm/m64 while shifting in sign bits.",
		.opcode = { 0x0F, 0xE1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRAW mm, mm/m64", .orig_opcode = "0F E1 /r",
		.desc = "Shift words in mm right by mm/m64 while shifting in sign bits.",
		.opcode = { 0x0F, 0xE1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRAW xmm1, xmm2/m128", .orig_opcode = "66 0F E1 /r",
		.desc = "Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRAW xmm1, xmm2/m128", .orig_opcode = "66 0F E1 /r",
		.desc = "Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { MM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRAW mm, imm8", .orig_opcode = "0F 71 /4 ib",
		.desc = "Shift words in mm right by imm8 while shifting in sign bits",
		.opcode = { 0x0F, 0x71 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { XMM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRAW xmm1, imm8", .orig_opcode = "66 0F 71 /4 ib",
		.desc = "Shift words in xmm1 right by imm8 while shifting in sign bits",
		.prefixes = 0x66, .opcode = { 0x0F, 0x71 }, .oplen = 2,
	} } },
	{ "psrad", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRAD mm, mm/m64", .orig_opcode = "0F E2 /r",
		.desc = "Shift doublewords in mm right by mm/m64 while shifting in sign bits.",
		.opcode = { 0x0F, 0xE2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRAD mm, mm/m64", .orig_opcode = "0F E2 /r",
		.desc = "Shift doublewords in mm right by mm/m64 while shifting in sign bits.",
		.opcode = { 0x0F, 0xE2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRAD xmm1, xmm2/m128", .orig_opcode = "66 0F E2 /r",
		.desc = "Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRAD xmm1, xmm2/m128", .orig_opcode = "66 0F E2 /r",
		.desc = "Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { MM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRAD mm, imm8", .orig_opcode = "0F 72 /4 ib",
		.desc = "Shift doublewords in mm right by imm8 while shifting in sign bits.",
		.opcode = { 0x0F, 0x72 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { XMM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRAD xmm1, imm8", .orig_opcode = "66 0F 72 /4 ib",
		.desc = "Shift doublewords in xmm1 right by imm8 while shifting in sign bits.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x72 }, .oplen = 2,
	} } },
	{ "psrldq", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { XMM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRLDQ xmm1, imm8", .orig_opcode = "66 0F 73 /3 ib",
		.desc = "Shift xmm1 right by imm8 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x73 }, .oplen = 2,
	} } },
	{ "psrlw", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLW mm, mm/m64", .orig_opcode = "0F D1 /r",
		.desc = "Shift words in mm right by amount specified in mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xD1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLW mm, mm/m64", .orig_opcode = "0F D1 /r",
		.desc = "Shift words in mm right by amount specified in mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xD1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLW xmm1, xmm2/m128", .orig_opcode = "66 0F D1 /r",
		.desc = "Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLW xmm1, xmm2/m128", .orig_opcode = "66 0F D1 /r",
		.desc = "Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { MM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRLW mm, imm8", .orig_opcode = "0F 71 /2 ib",
		.desc = "Shift words in mm right by imm8 while shifting in 0s.",
		.opcode = { 0x0F, 0x71 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { XMM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRLW xmm1, imm8", .orig_opcode = "66 0F 71 /2 ib",
		.desc = "Shift words in xmm1 right by imm8 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x71 }, .oplen = 2,
	} } },
	{ "psrld", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLD mm, mm/m64", .orig_opcode = "0F D2 /r",
		.desc = "Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xD2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLD mm, mm/m64", .orig_opcode = "0F D2 /r",
		.desc = "Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xD2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLD xmm1, xmm2/m128", .orig_opcode = "66 0F D2 /r",
		.desc = "Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLD xmm1, xmm2/m128", .orig_opcode = "66 0F D2 /r",
		.desc = "Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD2 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { MM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRLD mm, imm8", .orig_opcode = "0F 72 /2 ib",
		.desc = "Shift doublewords in mm right by imm8 while shifting in 0s.",
		.opcode = { 0x0F, 0x72 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { XMM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRLD xmm1, imm8", .orig_opcode = "66 0F 72 /2 ib",
		.desc = "Shift doublewords in xmm1 right by imm8 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x72 }, .oplen = 2,
	} } },
	{ "psrlq", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLQ mm, mm/m64", .orig_opcode = "0F D3 /r",
		.desc = "Shift mm right by amount specified in mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xD3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLQ mm, mm/m64", .orig_opcode = "0F D3 /r",
		.desc = "Shift mm right by amount specified in mm/m64 while shifting in 0s.",
		.opcode = { 0x0F, 0xD3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLQ xmm1, xmm2/m128", .orig_opcode = "66 0F D3 /r",
		.desc = "Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSRLQ xmm1, xmm2/m128", .orig_opcode = "66 0F D3 /r",
		.desc = "Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD3 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { MM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRLQ mm, imm8", .orig_opcode = "0F 73 /2 ib",
		.desc = "Shift mm right by imm8 while shifting in 0s.",
		.opcode = { 0x0F, 0x73 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { XMM, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "PSRLQ xmm1, imm8", .orig_opcode = "66 0F 73 /2 ib",
		.desc = "Shift quadwords in xmm1 right by imm8 while shifting in 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x73 }, .oplen = 2,
	} } },
	{ "psubb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBB mm, mm/m64", .orig_opcode = "0F F8 /r",
		.desc = "Subtract packed byte integers in mm/m64 from packed byte integers in mm.",
		.opcode = { 0x0F, 0xF8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBB mm, mm/m64", .orig_opcode = "0F F8 /r",
		.desc = "Subtract packed byte integers in mm/m64 from packed byte integers in mm.",
		.opcode = { 0x0F, 0xF8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBB xmm1, xmm2/m128", .orig_opcode = "66 0F F8 /r",
		.desc = "Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBB xmm1, xmm2/m128", .orig_opcode = "66 0F F8 /r",
		.desc = "Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF8 }, .oplen = 2,
	} } },
	{ "psubw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBW mm, mm/m64", .orig_opcode = "0F F9 /r",
		.desc = "Subtract packed word integers in mm/m64 from packed word integers in mm.",
		.opcode = { 0x0F, 0xF9 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBW mm, mm/m64", .orig_opcode = "0F F9 /r",
		.desc = "Subtract packed word integers in mm/m64 from packed word integers in mm.",
		.opcode = { 0x0F, 0xF9 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBW xmm1, xmm2/m128", .orig_opcode = "66 0F F9 /r",
		.desc = "Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF9 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBW xmm1, xmm2/m128", .orig_opcode = "66 0F F9 /r",
		.desc = "Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xF9 }, .oplen = 2,
	} } },
	{ "psubd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBD mm, mm/m64", .orig_opcode = "0F FA /r",
		.desc = "Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm.",
		.opcode = { 0x0F, 0xFA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBD mm, mm/m64", .orig_opcode = "0F FA /r",
		.desc = "Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm.",
		.opcode = { 0x0F, 0xFA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBD xmm1, xmm2/m128", .orig_opcode = "66 0F FA /r",
		.desc = "Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xFA }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBD xmm1, xmm2/m128", .orig_opcode = "66 0F FA /r",
		.desc = "Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xFA }, .oplen = 2,
	} } },
	{ "psubq", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBQ mm1, mm2/m64", .orig_opcode = "0F FB /r",
		.desc = "Subtract quadword integer in mm1 from mm2 /m64.",
		.opcode = { 0x0F, 0xFB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBQ mm1, mm2/m64", .orig_opcode = "0F FB /r",
		.desc = "Subtract quadword integer in mm1 from mm2 /m64.",
		.opcode = { 0x0F, 0xFB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBQ xmm1, xmm2/m128", .orig_opcode = "66 0F FB /r",
		.desc = "Subtract packed quadword integers in xmm1 from xmm2 /m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xFB }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBQ xmm1, xmm2/m128", .orig_opcode = "66 0F FB /r",
		.desc = "Subtract packed quadword integers in xmm1 from xmm2 /m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xFB }, .oplen = 2,
	} } },
	{ "psubsb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBSB mm, mm/m64", .orig_opcode = "0F E8 /r",
		.desc = "Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results.",
		.opcode = { 0x0F, 0xE8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBSB mm, mm/m64", .orig_opcode = "0F E8 /r",
		.desc = "Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results.",
		.opcode = { 0x0F, 0xE8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBSB xmm1, xmm2/m128", .orig_opcode = "66 0F E8 /r",
		.desc = "Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBSB xmm1, xmm2/m128", .orig_opcode = "66 0F E8 /r",
		.desc = "Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE8 }, .oplen = 2,
	} } },
	{ "psubsw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBSW mm, mm/m64", .orig_opcode = "0F E9 /r",
		.desc = "Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results.",
		.opcode = { 0x0F, 0xE9 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBSW mm, mm/m64", .orig_opcode = "0F E9 /r",
		.desc = "Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results.",
		.opcode = { 0x0F, 0xE9 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBSW xmm1, xmm2/m128", .orig_opcode = "66 0F E9 /r",
		.desc = "Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE9 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBSW xmm1, xmm2/m128", .orig_opcode = "66 0F E9 /r",
		.desc = "Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xE9 }, .oplen = 2,
	} } },
	{ "psubusb", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBUSB mm, mm/m64", .orig_opcode = "0F D8 /r",
		.desc = "Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result.",
		.opcode = { 0x0F, 0xD8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBUSB mm, mm/m64", .orig_opcode = "0F D8 /r",
		.desc = "Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result.",
		.opcode = { 0x0F, 0xD8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBUSB xmm1, xmm2/m128", .orig_opcode = "66 0F D8 /r",
		.desc = "Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD8 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBUSB xmm1, xmm2/m128", .orig_opcode = "66 0F D8 /r",
		.desc = "Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD8 }, .oplen = 2,
	} } },
	{ "psubusw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBUSW mm, mm/m64", .orig_opcode = "0F D9 /r",
		.desc = "Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result.",
		.opcode = { 0x0F, 0xD9 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBUSW mm, mm/m64", .orig_opcode = "0F D9 /r",
		.desc = "Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result.",
		.opcode = { 0x0F, 0xD9 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBUSW xmm1, xmm2/m128", .orig_opcode = "66 0F D9 /r",
		.desc = "Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD9 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PSUBUSW xmm1, xmm2/m128", .orig_opcode = "66 0F D9 /r",
		.desc = "Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xD9 }, .oplen = 2,
	} } },
	{ "ptest", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PTEST xmm1, xmm2/m128", .orig_opcode = "66 0F 38 17 /r",
		.desc = "Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x17 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PTEST xmm1, xmm2/m128", .orig_opcode = "66 0F 38 17 /r",
		.desc = "Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x38, 0x17 }, .oplen = 3,
	} } },
	{ "punpckhbw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHBW mm, mm/m64", .orig_opcode = "0F 68 /r",
		.desc = "Unpack and interleave high-order bytes from mm and mm/m64 into mm.",
		.opcode = { 0x0F, 0x68 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHBW mm, mm/m64", .orig_opcode = "0F 68 /r",
		.desc = "Unpack and interleave high-order bytes from mm and mm/m64 into mm.",
		.opcode = { 0x0F, 0x68 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHBW xmm1, xmm2/m128", .orig_opcode = "66 0F 68 /r",
		.desc = "Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x68 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHBW xmm1, xmm2/m128", .orig_opcode = "66 0F 68 /r",
		.desc = "Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x68 }, .oplen = 2,
	} } },
	{ "punpckhwd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHWD mm, mm/m64", .orig_opcode = "0F 69 /r",
		.desc = "Unpack and interleave high-order words from mm and mm/m64 into mm.",
		.opcode = { 0x0F, 0x69 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHWD mm, mm/m64", .orig_opcode = "0F 69 /r",
		.desc = "Unpack and interleave high-order words from mm and mm/m64 into mm.",
		.opcode = { 0x0F, 0x69 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHWD xmm1, xmm2/m128", .orig_opcode = "66 0F 69 /r",
		.desc = "Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x69 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHWD xmm1, xmm2/m128", .orig_opcode = "66 0F 69 /r",
		.desc = "Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x69 }, .oplen = 2,
	} } },
	{ "punpckhdq", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHDQ mm, mm/m64", .orig_opcode = "0F 6A /r",
		.desc = "Unpack and interleave high-order doublewords from mm and mm/m64 into mm.",
		.opcode = { 0x0F, 0x6A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHDQ mm, mm/m64", .orig_opcode = "0F 6A /r",
		.desc = "Unpack and interleave high-order doublewords from mm and mm/m64 into mm.",
		.opcode = { 0x0F, 0x6A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHDQ xmm1, xmm2/m128", .orig_opcode = "66 0F 6A /r",
		.desc = "Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHDQ xmm1, xmm2/m128", .orig_opcode = "66 0F 6A /r",
		.desc = "Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6A }, .oplen = 2,
	} } },
	{ "punpckhqdq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHQDQ xmm1, xmm2/m128", .orig_opcode = "66 0F 6D /r",
		.desc = "Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKHQDQ xmm1, xmm2/m128", .orig_opcode = "66 0F 6D /r",
		.desc = "Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6D }, .oplen = 2,
	} } },
	{ "punpcklbw", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLBW mm, mm/m32", .orig_opcode = "0F 60 /r",
		.desc = "Interleave low-order bytes from mm and mm/m32 into mm.",
		.opcode = { 0x0F, 0x60 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLBW mm, mm/m32", .orig_opcode = "0F 60 /r",
		.desc = "Interleave low-order bytes from mm and mm/m32 into mm.",
		.opcode = { 0x0F, 0x60 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLBW xmm1, xmm2/m128", .orig_opcode = "66 0F 60 /r",
		.desc = "Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x60 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLBW xmm1, xmm2/m128", .orig_opcode = "66 0F 60 /r",
		.desc = "Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x60 }, .oplen = 2,
	} } },
	{ "punpcklwd", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLWD mm, mm/m32", .orig_opcode = "0F 61 /r",
		.desc = "Interleave low-order words from mm and mm/m32 into mm.",
		.opcode = { 0x0F, 0x61 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLWD mm, mm/m32", .orig_opcode = "0F 61 /r",
		.desc = "Interleave low-order words from mm and mm/m32 into mm.",
		.opcode = { 0x0F, 0x61 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLWD xmm1, xmm2/m128", .orig_opcode = "66 0F 61 /r",
		.desc = "Interleave low-order words from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x61 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLWD xmm1, xmm2/m128", .orig_opcode = "66 0F 61 /r",
		.desc = "Interleave low-order words from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x61 }, .oplen = 2,
	} } },
	{ "punpckldq", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLDQ mm, mm/m32", .orig_opcode = "0F 62 /r",
		.desc = "Interleave low-order doublewords from mm and mm/m32 into mm.",
		.opcode = { 0x0F, 0x62 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLDQ mm, mm/m32", .orig_opcode = "0F 62 /r",
		.desc = "Interleave low-order doublewords from mm and mm/m32 into mm.",
		.opcode = { 0x0F, 0x62 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLDQ xmm1, xmm2/m128", .orig_opcode = "66 0F 62 /r",
		.desc = "Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x62 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLDQ xmm1, xmm2/m128", .orig_opcode = "66 0F 62 /r",
		.desc = "Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x62 }, .oplen = 2,
	} } },
	{ "punpcklqdq", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLQDQ xmm1, xmm2/m128", .orig_opcode = "66 0F 6C /r",
		.desc = "Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PUNPCKLQDQ xmm1, xmm2/m128", .orig_opcode = "66 0F 6C /r",
		.desc = "Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x6C }, .oplen = 2,
	} } },
	{ "push", 8, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "PUSH r/m16", .orig_opcode = "FF /6",
		.desc = "Push r/m16.",
		.prefixes = 0x66, .opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "PUSH r/m16", .orig_opcode = "FF /6",
		.desc = "Push r/m16.",
		.prefixes = 0x66, .opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "PUSH r/m64", .orig_opcode = "FF /6",
		.desc = "Push r/m64.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "PUSH r/m64", .orig_opcode = "FF /6",
		.desc = "Push r/m64.",
		.opcode = { 0xFF }, .oplen = 1,
	}, {
		.args = { R16 }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "PUSH r16", .orig_opcode = "50 +rw",
		.desc = "Push r16.",
		.prefixes = 0x66, .opcode = { 0x50 }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { R64 }, .arglen = 1, .reg_operand = 1,
		.orig_ins = "PUSH r64", .orig_opcode = "50 +rd",
		.desc = "Push r64.",
		.opcode = { 0x50 }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { FS }, .arglen = 1,
		.orig_ins = "PUSH FS", .orig_opcode = "0F A0",
		.desc = "Push FS.",
		.opcode = { 0x0F, 0xA0 }, .oplen = 2,
	}, {
		.args = { GS }, .arglen = 1,
		.orig_ins = "PUSH GS", .orig_opcode = "0F A8",
		.desc = "Push GS.",
		.opcode = { 0x0F, 0xA8 }, .oplen = 2,
	} } },
	{ "pushq", 3, (struct x64LookupActualIns[]) { {
		.args = { IMM8 }, .arglen = 1, .immediate = 1,
		.orig_ins = "PUSHQ imm8", .orig_opcode = "6A",
		.desc = "Push imm8 (sign-extended to 64-bits).",
		.opcode = { 0x6A }, .oplen = 1,
	}, {
		.args = { IMM16 }, .arglen = 1, .immediate = 1,
		.orig_ins = "PUSHQ imm16", .orig_opcode = "68",
		.desc = "Push imm16 (sign-extended to 64-bits).",
		.prefixes = 0x66, .opcode = { 0x68 }, .oplen = 1,
	}, {
		.args = { IMM32 }, .arglen = 1, .immediate = 1,
		.orig_ins = "PUSHQ imm32", .orig_opcode = "68",
		.desc = "Push imm32 (sign-extended to 64-bits).",
		.opcode = { 0x68 }, .oplen = 1,
	} } },
	{ "pushw", 2, (struct x64LookupActualIns[]) { {
		.args = { IMM8 }, .arglen = 1, .immediate = 1,
		.orig_ins = "PUSHW imm8", .orig_opcode = "66 6A",
		.desc = "Push imm8 (sign-extended to 16-bits).",
		.prefixes = 0x66, .opcode = { 0x6A }, .oplen = 1,
	}, {
		.args = { IMM16 }, .arglen = 1, .immediate = 1,
		.orig_ins = "PUSHW imm16", .orig_opcode = "66 68",
		.desc = "Push imm16 (sign-extended to 16-bits).",
		.prefixes = 0x66, .opcode = { 0x68 }, .oplen = 1,
	} } },
	{ "pushf", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "PUSHF", .orig_opcode = "66 9C",
		.desc = "Push lower 16 bits of EFLAGS.",
		.prefixes = 0x66, .opcode = { 0x9C }, .oplen = 1,
	} } },
	{ "pushfq", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "PUSHFQ", .orig_opcode = "9C",
		.desc = "Push RFLAGS.",
		.opcode = { 0x9C }, .oplen = 1,
	} } },
	{ "pxor", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PXOR mm, mm/m64", .orig_opcode = "0F EF /r",
		.desc = "Bitwise XOR of mm/m64 and mm.",
		.opcode = { 0x0F, 0xEF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { MM, MM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PXOR mm, mm/m64", .orig_opcode = "0F EF /r",
		.desc = "Bitwise XOR of mm/m64 and mm.",
		.opcode = { 0x0F, 0xEF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PXOR xmm1, xmm2/m128", .orig_opcode = "66 0F EF /r",
		.desc = "Bitwise XOR of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xEF }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "PXOR xmm1, xmm2/m128", .orig_opcode = "66 0F EF /r",
		.desc = "Bitwise XOR of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xEF }, .oplen = 2,
	} } },
	{ "rcl", 24, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m8, 1", .orig_opcode = "D0 /2",
		.desc = "Rotate 9 bits (CF, r/m8) left once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m8, 1", .orig_opcode = "D0 /2",
		.desc = "Rotate 9 bits (CF, r/m8) left once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m8, CL", .orig_opcode = "D2 /2",
		.desc = "Rotate 9 bits (CF, r/m8) left CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m8, CL", .orig_opcode = "D2 /2",
		.desc = "Rotate 9 bits (CF, r/m8) left CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m8, imm8", .orig_opcode = "C0 /2 ib",
		.desc = "Rotate 9 bits (CF, r/m8) left imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m8, imm8", .orig_opcode = "C0 /2 ib",
		.desc = "Rotate 9 bits (CF, r/m8) left imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m16, 1", .orig_opcode = "D1 /2",
		.desc = "Rotate 17 bits (CF, r/m16) left once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m16, 1", .orig_opcode = "D1 /2",
		.desc = "Rotate 17 bits (CF, r/m16) left once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m16, CL", .orig_opcode = "D3 /2",
		.desc = "Rotate 17 bits (CF, r/m16) left CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m16, CL", .orig_opcode = "D3 /2",
		.desc = "Rotate 17 bits (CF, r/m16) left CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m16, imm8", .orig_opcode = "C1 /2 ib",
		.desc = "Rotate 17 bits (CF, r/m16) left imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m16, imm8", .orig_opcode = "C1 /2 ib",
		.desc = "Rotate 17 bits (CF, r/m16) left imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m32, 1", .orig_opcode = "D1 /2",
		.desc = "Rotate 33 bits (CF, r/m32) left once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m32, 1", .orig_opcode = "D1 /2",
		.desc = "Rotate 33 bits (CF, r/m32) left once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { M64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m64, 1", .orig_opcode = "REX.W+ D1 /2",
		.desc = "Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { R64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m64, 1", .orig_opcode = "REX.W+ D1 /2",
		.desc = "Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m32, CL", .orig_opcode = "D3 /2",
		.desc = "Rotate 33 bits (CF, r/m32) left CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m32, CL", .orig_opcode = "D3 /2",
		.desc = "Rotate 33 bits (CF, r/m32) left CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { M64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m64, CL", .orig_opcode = "REX.W+ D3 /2",
		.desc = "Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { R64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m64, CL", .orig_opcode = "REX.W+ D3 /2",
		.desc = "Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m32, imm8", .orig_opcode = "C1 /2 ib",
		.desc = "Rotate 33 bits (CF, r/m32) left imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m32, imm8", .orig_opcode = "C1 /2 ib",
		.desc = "Rotate 33 bits (CF, r/m32) left imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m64, imm8", .orig_opcode = "REX.W+ C1 /2 ib",
		.desc = "Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCL r/m64, imm8", .orig_opcode = "REX.W+ C1 /2 ib",
		.desc = "Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.",
		.opcode = { 0xC1 }, .oplen = 1,
	} } },
	{ "rcr", 24, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m8, 1", .orig_opcode = "D0 /3",
		.desc = "Rotate 9 bits (CF, r/m8) right once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m8, 1", .orig_opcode = "D0 /3",
		.desc = "Rotate 9 bits (CF, r/m8) right once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m8, CL", .orig_opcode = "D2 /3",
		.desc = "Rotate 9 bits (CF, r/m8) right CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m8, CL", .orig_opcode = "D2 /3",
		.desc = "Rotate 9 bits (CF, r/m8) right CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m8, imm8", .orig_opcode = "C0 /3 ib",
		.desc = "Rotate 9 bits (CF, r/m8) right imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m8, imm8", .orig_opcode = "C0 /3 ib",
		.desc = "Rotate 9 bits (CF, r/m8) right imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m16, 1", .orig_opcode = "D1 /3",
		.desc = "Rotate 17 bits (CF, r/m16) right once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m16, 1", .orig_opcode = "D1 /3",
		.desc = "Rotate 17 bits (CF, r/m16) right once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m16, CL", .orig_opcode = "D3 /3",
		.desc = "Rotate 17 bits (CF, r/m16) right CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m16, CL", .orig_opcode = "D3 /3",
		.desc = "Rotate 17 bits (CF, r/m16) right CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m16, imm8", .orig_opcode = "C1 /3 ib",
		.desc = "Rotate 17 bits (CF, r/m16) right imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m16, imm8", .orig_opcode = "C1 /3 ib",
		.desc = "Rotate 17 bits (CF, r/m16) right imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m32, 1", .orig_opcode = "D1 /3",
		.desc = "Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m32, 1", .orig_opcode = "D1 /3",
		.desc = "Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { M64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m64, 1", .orig_opcode = "REX.W+ D1 /3",
		.desc = "Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { R64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m64, 1", .orig_opcode = "REX.W+ D1 /3",
		.desc = "Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m32, CL", .orig_opcode = "D3 /3",
		.desc = "Rotate 33 bits (CF, r/m32) right CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m32, CL", .orig_opcode = "D3 /3",
		.desc = "Rotate 33 bits (CF, r/m32) right CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { M64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m64, CL", .orig_opcode = "REX.W+ D3 /3",
		.desc = "Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { R64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m64, CL", .orig_opcode = "REX.W+ D3 /3",
		.desc = "Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m32, imm8", .orig_opcode = "C1 /3 ib",
		.desc = "Rotate 33 bits (CF, r/m32) right imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m32, imm8", .orig_opcode = "C1 /3 ib",
		.desc = "Rotate 33 bits (CF, r/m32) right imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m64, imm8", .orig_opcode = "REX.W+ C1 /3 ib",
		.desc = "Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "RCR r/m64, imm8", .orig_opcode = "REX.W+ C1 /3 ib",
		.desc = "Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.",
		.opcode = { 0xC1 }, .oplen = 1,
	} } },
	{ "rol", 24, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m8, 1", .orig_opcode = "D0 /0",
		.desc = "Rotate 8 bits r/m8 left once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m8, 1", .orig_opcode = "D0 /0",
		.desc = "Rotate 8 bits r/m8 left once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m8, CL", .orig_opcode = "D2 /0",
		.desc = "Rotate 8 bits r/m8 left CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m8, CL", .orig_opcode = "D2 /0",
		.desc = "Rotate 8 bits r/m8 left CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m8, imm8", .orig_opcode = "C0 /0 ib",
		.desc = "Rotate 8 bits r/m8 left imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m8, imm8", .orig_opcode = "C0 /0 ib",
		.desc = "Rotate 8 bits r/m8 left imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m16, 1", .orig_opcode = "D1 /0",
		.desc = "Rotate 16 bits r/m16 left once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m16, 1", .orig_opcode = "D1 /0",
		.desc = "Rotate 16 bits r/m16 left once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m16, CL", .orig_opcode = "D3 /0",
		.desc = "Rotate 16 bits r/m16 left CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m16, CL", .orig_opcode = "D3 /0",
		.desc = "Rotate 16 bits r/m16 left CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m16, imm8", .orig_opcode = "C1 /0 ib",
		.desc = "Rotate 16 bits r/m16 left imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m16, imm8", .orig_opcode = "C1 /0 ib",
		.desc = "Rotate 16 bits r/m16 left imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m32, 1", .orig_opcode = "D1 /0",
		.desc = "Rotate 32 bits r/m32 left once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m32, 1", .orig_opcode = "D1 /0",
		.desc = "Rotate 32 bits r/m32 left once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { M64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m64, 1", .orig_opcode = "REX.W+ D1 /0",
		.desc = "Rotate 64 bits r/m64 left once. Uses a 6 bit count.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { R64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m64, 1", .orig_opcode = "REX.W+ D1 /0",
		.desc = "Rotate 64 bits r/m64 left once. Uses a 6 bit count.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m32, CL", .orig_opcode = "D3 /0",
		.desc = "Rotate 32 bits r/m32 left CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m32, CL", .orig_opcode = "D3 /0",
		.desc = "Rotate 32 bits r/m32 left CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { M64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m64, CL", .orig_opcode = "REX.W+ D3 /0",
		.desc = "Rotate 64 bits r/m64 left CL times. Uses a 6 bit count.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { R64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m64, CL", .orig_opcode = "REX.W+ D3 /0",
		.desc = "Rotate 64 bits r/m64 left CL times. Uses a 6 bit count.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m32, imm8", .orig_opcode = "C1 /0 ib",
		.desc = "Rotate 32 bits r/m32 left imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m32, imm8", .orig_opcode = "C1 /0 ib",
		.desc = "Rotate 32 bits r/m32 left imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m64, imm8", .orig_opcode = "REX.W+ C1 /0 ib",
		.desc = "Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROL r/m64, imm8", .orig_opcode = "REX.W+ C1 /0 ib",
		.desc = "Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count.",
		.opcode = { 0xC1 }, .oplen = 1,
	} } },
	{ "ror", 24, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m8, 1", .orig_opcode = "D0 /1",
		.desc = "Rotate 8 bits r/m8 right once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m8, 1", .orig_opcode = "D0 /1",
		.desc = "Rotate 8 bits r/m8 right once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m8, CL", .orig_opcode = "D2 /1",
		.desc = "Rotate 8 bits r/m8 right CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m8, CL", .orig_opcode = "D2 /1",
		.desc = "Rotate 8 bits r/m8 right CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m8, imm8", .orig_opcode = "C0 /1 ib",
		.desc = "Rotate 8 bits r/m16 right imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m8, imm8", .orig_opcode = "C0 /1 ib",
		.desc = "Rotate 8 bits r/m16 right imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m16, 1", .orig_opcode = "D1 /1",
		.desc = "Rotate 16 bits r/m16 right once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m16, 1", .orig_opcode = "D1 /1",
		.desc = "Rotate 16 bits r/m16 right once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m16, CL", .orig_opcode = "D3 /1",
		.desc = "Rotate 16 bits r/m16 right CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m16, CL", .orig_opcode = "D3 /1",
		.desc = "Rotate 16 bits r/m16 right CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m16, imm8", .orig_opcode = "C1 /1 ib",
		.desc = "Rotate 16 bits r/m16 right imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m16, imm8", .orig_opcode = "C1 /1 ib",
		.desc = "Rotate 16 bits r/m16 right imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m32, 1", .orig_opcode = "D1 /1",
		.desc = "Rotate 32 bits r/m32 right once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m32, 1", .orig_opcode = "D1 /1",
		.desc = "Rotate 32 bits r/m32 right once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { M64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m64, 1", .orig_opcode = "REX.W+ D1 /1",
		.desc = "Rotate 64 bits r/m64 right once. Uses a 6 bit count.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { R64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m64, 1", .orig_opcode = "REX.W+ D1 /1",
		.desc = "Rotate 64 bits r/m64 right once. Uses a 6 bit count.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m32, CL", .orig_opcode = "D3 /1",
		.desc = "Rotate 32 bits r/m32 right CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m32, CL", .orig_opcode = "D3 /1",
		.desc = "Rotate 32 bits r/m32 right CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { M64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m64, CL", .orig_opcode = "REX.W+ D3 /1",
		.desc = "Rotate 64 bits r/m64 right CL times. Uses a 6 bit count.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { R64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m64, CL", .orig_opcode = "REX.W+ D3 /1",
		.desc = "Rotate 64 bits r/m64 right CL times. Uses a 6 bit count.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m32, imm8", .orig_opcode = "C1 /1 ib",
		.desc = "Rotate 32 bits r/m32 right imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m32, imm8", .orig_opcode = "C1 /1 ib",
		.desc = "Rotate 32 bits r/m32 right imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m64, imm8", .orig_opcode = "REX.W+ C1 /1 ib",
		.desc = "Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "ROR r/m64, imm8", .orig_opcode = "REX.W+ C1 /1 ib",
		.desc = "Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count.",
		.opcode = { 0xC1 }, .oplen = 1,
	} } },
	{ "rcpps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "RCPPS xmm1, xmm2/m128", .orig_opcode = "0F 53 /r",
		.desc = "Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.",
		.opcode = { 0x0F, 0x53 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "RCPPS xmm1, xmm2/m128", .orig_opcode = "0F 53 /r",
		.desc = "Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.",
		.opcode = { 0x0F, 0x53 }, .oplen = 2,
	} } },
	{ "rcpss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "RCPSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 53 /r",
		.desc = "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x53 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "RCPSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 53 /r",
		.desc = "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x53 }, .oplen = 2,
	} } },
	{ "rdfsbase", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "RDFSBASE r32", .orig_opcode = "F3 0F AE /0",
		.desc = "Load the 32-bit destination register with the FS base address.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "RDFSBASE r64", .orig_opcode = "REX.W+ F3 0F AE /0",
		.desc = "Load the 64-bit destination register with the FS base address.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "rdgsbase", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "RDGSBASE r32", .orig_opcode = "F3 0F AE /1",
		.desc = "Load the 32-bit destination register with the GS base address.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x8, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "RDGSBASE r64", .orig_opcode = "REX.W+ F3 0F AE /1",
		.desc = "Load the 64-bit destination register with the GS base address.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "rdmsr", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "RDMSR", .orig_opcode = "0F 32",
		.desc = "Read MSR specified by ECX into EDX:EAX.",
		.opcode = { 0x0F, 0x32 }, .oplen = 2,
	} } },
	{ "rdpmc", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "RDPMC", .orig_opcode = "0F 33",
		.desc = "Read performance-monitoring counter specified by ECX into EDX:EAX.",
		.opcode = { 0x0F, 0x33 }, .oplen = 2,
	} } },
	{ "rdrand", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "RDRAND r16", .orig_opcode = "0F C7 /6",
		.desc = "Read a 16-bit random number and store in the destination register.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC7 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "RDRAND r32", .orig_opcode = "0F C7 /6",
		.desc = "Read a 32-bit random number and store in the destination register.",
		.opcode = { 0x0F, 0xC7 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "RDRAND r64", .orig_opcode = "REX.W+ 0F C7 /6",
		.desc = "Read a 64-bit random number and store in the destination register.",
		.opcode = { 0x0F, 0xC7 }, .oplen = 2,
	} } },
	{ "rdtsc", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "RDTSC", .orig_opcode = "0F 31",
		.desc = "Read time-stamp counter into EDX:EAX.",
		.opcode = { 0x0F, 0x31 }, .oplen = 2,
	} } },
	{ "rdtscp", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "RDTSCP", .orig_opcode = "0F 01 F9",
		.desc = "Read 64-bit time-stamp counter and 32-bit IA32_TSC_AUX value into EDX:EAX and ECX.",
		.opcode = { 0x0F, 0x01, 0xF9 }, .oplen = 3,
	} } },
	{ "rep ins", 5, (struct x64LookupActualIns[]) { {
		.args = { M8, DX }, .arglen = 2,
		.orig_ins = "REP_INS m8, DX", .orig_opcode = "F3 6C",
		.desc = "Input (E)CX bytes from port DX into ES:[(E)DI].",
		.prefixes = 0xF3, .opcode = { 0x6C }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M8, DX }, .arglen = 2,
		.orig_ins = "REP_INS m8, DX", .orig_opcode = "F3 REX.W+ 6C",
		.desc = "Input RCX bytes from port DX into [RDI].",
		.prefixes = 0xF3, .opcode = { 0x6C }, .oplen = 1,
	}, {
		.args = { M128, DX }, .arglen = 2,
		.orig_ins = "REP_INS m16, DX", .orig_opcode = "F3 6D",
		.desc = "Input (E)CX words from port DX into ES:[(E)DI.]",
		.prefixes = 0xF3, .opcode = { 0x6D }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { M32, DX }, .arglen = 2,
		.orig_ins = "REP_INS m32, DX", .orig_opcode = "F3 6D",
		.desc = "Input (E)CX doublewords from port DX into ES:[(E)DI].",
		.prefixes = 0xF3, .opcode = { 0x6D }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M64, DX }, .arglen = 2,
		.orig_ins = "REP_INS m64, DX", .orig_opcode = "F3 REX.W+ 6D",
		.desc = "Input RCX default size from port DX into [RDI].",
		.prefixes = 0xF3, .opcode = { 0x6D }, .oplen = 1,
	} } },
	{ "rep movs", 5, (struct x64LookupActualIns[]) { {
		.args = { M8, M8 }, .arglen = 2,
		.orig_ins = "REP_MOVS m8, m8", .orig_opcode = "F3 A4",
		.desc = "Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI].",
		.prefixes = 0xF3, .opcode = { 0xA4 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M8, M8 }, .arglen = 2,
		.orig_ins = "REP_MOVS m8, m8", .orig_opcode = "F3 REX.W+ A4",
		.desc = "Move RCX bytes from [RSI] to [RDI].",
		.prefixes = 0xF3, .opcode = { 0xA4 }, .oplen = 1,
	}, {
		.args = { M128, M128 }, .arglen = 2,
		.orig_ins = "REP_MOVS m16, m16", .orig_opcode = "F3 A5",
		.desc = "Move (E)CX words from DS:[(E)SI] to ES:[(E)DI].",
		.prefixes = 0xF3, .opcode = { 0xA5 }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { M32, M32 }, .arglen = 2,
		.orig_ins = "REP_MOVS m32, m32", .orig_opcode = "F3 A5",
		.desc = "Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI].",
		.prefixes = 0xF3, .opcode = { 0xA5 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M64, M64 }, .arglen = 2,
		.orig_ins = "REP_MOVS m64, m64", .orig_opcode = "F3 REX.W+ A5",
		.desc = "Move RCX quadwords from [RSI] to [RDI].",
		.prefixes = 0xF3, .opcode = { 0xA5 }, .oplen = 1,
	} } },
	{ "rep outs", 5, (struct x64LookupActualIns[]) { {
		.args = { DX, M8 }, .arglen = 2,
		.orig_ins = "REP_OUTS DX, m8", .orig_opcode = "F3 6E",
		.desc = "Output (E)CX bytes from DS:[(E)SI] to port DX.",
		.prefixes = 0xF3, .opcode = { 0x6E }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { DX, M8 }, .arglen = 2,
		.orig_ins = "REP_OUTS DX, m8", .orig_opcode = "F3 REX.W+ 6E",
		.desc = "Output RCX bytes from [RSI] to port DX.",
		.prefixes = 0xF3, .opcode = { 0x6E }, .oplen = 1,
	}, {
		.args = { DX, M128 }, .arglen = 2,
		.orig_ins = "REP_OUTS DX, m16", .orig_opcode = "F3 6F",
		.desc = "Output (E)CX words from DS:[(E)SI] to port DX.",
		.prefixes = 0xF3, .opcode = { 0x6F }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { DX, M32 }, .arglen = 2,
		.orig_ins = "REP_OUTS DX, m32", .orig_opcode = "F3 6F",
		.desc = "Output (E)CX doublewords from DS:[(E)SI] to port DX.",
		.prefixes = 0xF3, .opcode = { 0x6F }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { DX, M64 }, .arglen = 2,
		.orig_ins = "REP_OUTS DX, m64", .orig_opcode = "F3 REX.W+ 6F",
		.desc = "Output RCX default size from [RSI] to port DX.",
		.prefixes = 0xF3, .opcode = { 0x6F }, .oplen = 1,
	} } },
	{ "rep lods", 5, (struct x64LookupActualIns[]) { {
		.args = { AL }, .arglen = 1,
		.orig_ins = "REP_LODS AL", .orig_opcode = "F3 AC",
		.desc = "Load (E)CX bytes from DS:[(E)SI] to AL.",
		.prefixes = 0xF3, .opcode = { 0xAC }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { AL }, .arglen = 1,
		.orig_ins = "REP_LODS AL", .orig_opcode = "F3 REX.W+ AC",
		.desc = "Load RCX bytes from [RSI] to AL.",
		.prefixes = 0xF3, .opcode = { 0xAC }, .oplen = 1,
	}, {
		.args = { AX }, .arglen = 1,
		.orig_ins = "REP_LODS AX", .orig_opcode = "F3 AD",
		.desc = "Load (E)CX words from DS:[(E)SI] to AX.",
		.prefixes = 0x66F3, .opcode = { 0xAD }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { EAX }, .arglen = 1,
		.orig_ins = "REP_LODS EAX", .orig_opcode = "F3 AD",
		.desc = "Load (E)CX doublewords from DS:[(E)SI] to EAX.",
		.prefixes = 0xF3, .opcode = { 0xAD }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { RAX }, .arglen = 1,
		.orig_ins = "REP_LODS RAX", .orig_opcode = "F3 REX.W+ AD",
		.desc = "Load RCX quadwords from [RSI] to RAX.",
		.prefixes = 0xF3, .opcode = { 0xAD }, .oplen = 1,
	} } },
	{ "rep stos", 5, (struct x64LookupActualIns[]) { {
		.args = { M8 }, .arglen = 1,
		.orig_ins = "REP_STOS m8", .orig_opcode = "F3 AA",
		.desc = "Fill (E)CX bytes at ES:[(E)DI] with AL.",
		.prefixes = 0xF3, .opcode = { 0xAA }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M8 }, .arglen = 1,
		.orig_ins = "REP_STOS m8", .orig_opcode = "F3 REX.W+ AA",
		.desc = "Fill RCX bytes at [RDI] with AL.",
		.prefixes = 0xF3, .opcode = { 0xAA }, .oplen = 1,
	}, {
		.args = { M128 }, .arglen = 1,
		.orig_ins = "REP_STOS m16", .orig_opcode = "F3 AB",
		.desc = "Fill (E)CX words at ES:[(E)DI] with AX.",
		.prefixes = 0xF3, .opcode = { 0xAB }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { M32 }, .arglen = 1,
		.orig_ins = "REP_STOS m32", .orig_opcode = "F3 AB",
		.desc = "Fill (E)CX doublewords at ES:[(E)DI] with EAX.",
		.prefixes = 0xF3, .opcode = { 0xAB }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M64 }, .arglen = 1,
		.orig_ins = "REP_STOS m64", .orig_opcode = "F3 REX.W+ AB",
		.desc = "Fill RCX quadwords at [RDI] with RAX.",
		.prefixes = 0xF3, .opcode = { 0xAB }, .oplen = 1,
	} } },
	{ "repe cmps", 5, (struct x64LookupActualIns[]) { {
		.args = { M8, M8 }, .arglen = 2,
		.orig_ins = "REPE_CMPS m8, m8", .orig_opcode = "F3 A6",
		.desc = "Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI].",
		.prefixes = 0xF3, .opcode = { 0xA6 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M8, M8 }, .arglen = 2,
		.orig_ins = "REPE_CMPS m8, m8", .orig_opcode = "F3 REX.W+ A6",
		.desc = "Find non-matching bytes in [RDI] and [RSI].",
		.prefixes = 0xF3, .opcode = { 0xA6 }, .oplen = 1,
	}, {
		.args = { M128, M128 }, .arglen = 2,
		.orig_ins = "REPE_CMPS m16, m16", .orig_opcode = "F3 A7",
		.desc = "Find nonmatching words in ES:[(E)DI] and DS:[(E)SI].",
		.prefixes = 0xF3, .opcode = { 0xA7 }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { M32, M32 }, .arglen = 2,
		.orig_ins = "REPE_CMPS m32, m32", .orig_opcode = "F3 A7",
		.desc = "Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI].",
		.prefixes = 0xF3, .opcode = { 0xA7 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M64, M64 }, .arglen = 2,
		.orig_ins = "REPE_CMPS m64, m64", .orig_opcode = "F3 REX.W+ A7",
		.desc = "Find non-matching quadwords in [RDI] and [RSI].",
		.prefixes = 0xF3, .opcode = { 0xA7 }, .oplen = 1,
	} } },
	{ "repe scas", 5, (struct x64LookupActualIns[]) { {
		.args = { M8 }, .arglen = 1,
		.orig_ins = "REPE_SCAS m8", .orig_opcode = "F3 AE",
		.desc = "Find non-AL byte starting at ES:[(E)DI].",
		.prefixes = 0xF3, .opcode = { 0xAE }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M8 }, .arglen = 1,
		.orig_ins = "REPE_SCAS m8", .orig_opcode = "F3 REX.W+ AE",
		.desc = "Find non-AL byte starting at [RDI].",
		.prefixes = 0xF3, .opcode = { 0xAE }, .oplen = 1,
	}, {
		.args = { M128 }, .arglen = 1,
		.orig_ins = "REPE_SCAS m16", .orig_opcode = "F3 AF",
		.desc = "Find non-AX word starting at ES:[(E)DI].",
		.prefixes = 0xF3, .opcode = { 0xAF }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { M32 }, .arglen = 1,
		.orig_ins = "REPE_SCAS m32", .orig_opcode = "F3 AF",
		.desc = "Find non-EAX doubleword starting at ES:[(E)DI].",
		.prefixes = 0xF3, .opcode = { 0xAF }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M64 }, .arglen = 1,
		.orig_ins = "REPE_SCAS m64", .orig_opcode = "F3 REX.W+ AF",
		.desc = "Find non-RAX quadword starting at [RDI].",
		.prefixes = 0xF3, .opcode = { 0xAF }, .oplen = 1,
	} } },
	{ "repne cmps", 5, (struct x64LookupActualIns[]) { {
		.args = { M8, M8 }, .arglen = 2,
		.orig_ins = "REPNE_CMPS m8, m8", .orig_opcode = "F2 A6",
		.desc = "Find matching bytes in ES:[(E)DI] and DS:[(E)SI].",
		.prefixes = 0xF2, .opcode = { 0xA6 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M8, M8 }, .arglen = 2,
		.orig_ins = "REPNE_CMPS m8, m8", .orig_opcode = "F2 REX.W+ A6",
		.desc = "Find matching bytes in [RDI] and [RSI].",
		.prefixes = 0xF2, .opcode = { 0xA6 }, .oplen = 1,
	}, {
		.args = { M128, M128 }, .arglen = 2,
		.orig_ins = "REPNE_CMPS m16, m16", .orig_opcode = "F2 A7",
		.desc = "Find matching words in ES:[(E)DI] and DS:[(E)SI].",
		.prefixes = 0xF2, .opcode = { 0xA7 }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { M32, M32 }, .arglen = 2,
		.orig_ins = "REPNE_CMPS m32, m32", .orig_opcode = "F2 A7",
		.desc = "Find matching doublewords in ES:[(E)DI] and DS:[(E)SI].",
		.prefixes = 0xF2, .opcode = { 0xA7 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M64, M64 }, .arglen = 2,
		.orig_ins = "REPNE_CMPS m64, m64", .orig_opcode = "F2 REX.W+ A7",
		.desc = "Find matching doublewords in [RDI] and [RSI].",
		.prefixes = 0xF2, .opcode = { 0xA7 }, .oplen = 1,
	} } },
	{ "repne scas", 5, (struct x64LookupActualIns[]) { {
		.args = { M8 }, .arglen = 1,
		.orig_ins = "REPNE_SCAS m8", .orig_opcode = "F2 AE",
		.desc = "Find AL, starting at ES:[(E)DI].",
		.prefixes = 0xF2, .opcode = { 0xAE }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M8 }, .arglen = 1,
		.orig_ins = "REPNE_SCAS m8", .orig_opcode = "F2 REX.W+ AE",
		.desc = "Find AL, starting at [RDI].",
		.prefixes = 0xF2, .opcode = { 0xAE }, .oplen = 1,
	}, {
		.args = { M128 }, .arglen = 1,
		.orig_ins = "REPNE_SCAS m16", .orig_opcode = "F2 AF",
		.desc = "Find AX, starting at ES:[(E)DI].",
		.prefixes = 0xF2, .opcode = { 0xAF }, .oplen = 1,
		.preffered = true,
	}, {
		.args = { M32 }, .arglen = 1,
		.orig_ins = "REPNE_SCAS m32", .orig_opcode = "F2 AF",
		.desc = "Find EAX, starting at ES:[(E)DI].",
		.prefixes = 0xF2, .opcode = { 0xAF }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, 
		.args = { M64 }, .arglen = 1,
		.orig_ins = "REPNE_SCAS m64", .orig_opcode = "F2 REX.W+ AF",
		.desc = "Find RAX, starting at [RDI].",
		.prefixes = 0xF2, .opcode = { 0xAF }, .oplen = 1,
	} } },
	{ "ret", 4, (struct x64LookupActualIns[]) { {
		.orig_ins = "RET", .orig_opcode = "C3",
		.desc = "Near return to calling procedure.",
		.opcode = { 0xC3 }, .oplen = 1,
	}, {
		.args = { FAR }, .arglen = 1,
		.orig_ins = "RET far", .orig_opcode = "CB",
		.desc = "Far return to calling procedure.",
		.opcode = { 0xCB }, .oplen = 1,
	}, {
		.args = { IMM16 }, .arglen = 1, .immediate = 1,
		.orig_ins = "RET imm16", .orig_opcode = "C2 iw",
		.desc = "Near return to calling procedure and pop imm16 bytes from stack.",
		.opcode = { 0xC2 }, .oplen = 1,
	}, {
		.args = { IMM16, FAR }, .arglen = 2, .immediate = 1,
		.orig_ins = "RET imm16, far", .orig_opcode = "CA iw",
		.desc = "Far return to calling procedure and pop imm16 bytes from stack.",
		.opcode = { 0xCA }, .oplen = 1,
	} } },
	{ "roundpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ROUNDPD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 09 /r ib",
		.desc = "Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x09 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ROUNDPD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 09 /r ib",
		.desc = "Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x09 }, .oplen = 3,
	} } },
	{ "roundps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ROUNDPS xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 08 /r ib",
		.desc = "Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x08 }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ROUNDPS xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F 3A 08 /r ib",
		.desc = "Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x08 }, .oplen = 3,
	} } },
	{ "roundsd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ROUNDSD xmm1, xmm2/m64, imm8", .orig_opcode = "66 0F 3A 0B /r ib",
		.desc = "Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0B }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ROUNDSD xmm1, xmm2/m64, imm8", .orig_opcode = "66 0F 3A 0B /r ib",
		.desc = "Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0B }, .oplen = 3,
	} } },
	{ "roundss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ROUNDSS xmm1, xmm2/m32, imm8", .orig_opcode = "66 0F 3A 0A /r ib",
		.desc = "Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0A }, .oplen = 3,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "ROUNDSS xmm1, xmm2/m32, imm8", .orig_opcode = "66 0F 3A 0A /r ib",
		.desc = "Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x3A, 0x0A }, .oplen = 3,
	} } },
	{ "rsqrtps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "RSQRTPS xmm1, xmm2/m128", .orig_opcode = "0F 52 /r",
		.desc = "Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.",
		.opcode = { 0x0F, 0x52 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "RSQRTPS xmm1, xmm2/m128", .orig_opcode = "0F 52 /r",
		.desc = "Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.",
		.opcode = { 0x0F, 0x52 }, .oplen = 2,
	} } },
	{ "rsqrtss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "RSQRTSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 52 /r",
		.desc = "Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x52 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "RSQRTSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 52 /r",
		.desc = "Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x52 }, .oplen = 2,
	} } },
	{ "sahf", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "SAHF", .orig_opcode = "9E",
		.desc = "Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register.",
		.opcode = { 0x9E }, .oplen = 1,
	} } },
	{ "sal", 24, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m8, 1", .orig_opcode = "D0 /4",
		.desc = "Multiply r/m8 by 2, once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m8, 1", .orig_opcode = "D0 /4",
		.desc = "Multiply r/m8 by 2, once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m8, CL", .orig_opcode = "D2 /4",
		.desc = "Multiply r/m8 by 2, CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m8, CL", .orig_opcode = "D2 /4",
		.desc = "Multiply r/m8 by 2, CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m8, imm8", .orig_opcode = "C0 /4 ib",
		.desc = "Multiply r/m8 by 2, imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m8, imm8", .orig_opcode = "C0 /4 ib",
		.desc = "Multiply r/m8 by 2, imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m16, 1", .orig_opcode = "D1 /4",
		.desc = "Multiply r/m16 by 2, once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m16, 1", .orig_opcode = "D1 /4",
		.desc = "Multiply r/m16 by 2, once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m16, CL", .orig_opcode = "D3 /4",
		.desc = "Multiply r/m16 by 2, CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m16, CL", .orig_opcode = "D3 /4",
		.desc = "Multiply r/m16 by 2, CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m16, imm8", .orig_opcode = "C1 /4 ib",
		.desc = "Multiply r/m16 by 2, imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m16, imm8", .orig_opcode = "C1 /4 ib",
		.desc = "Multiply r/m16 by 2, imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m32, 1", .orig_opcode = "D1 /4",
		.desc = "Multiply r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m32, 1", .orig_opcode = "D1 /4",
		.desc = "Multiply r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m64, 1", .orig_opcode = "REX.W+ D1 /4",
		.desc = "Multiply r/m64 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m64, 1", .orig_opcode = "REX.W+ D1 /4",
		.desc = "Multiply r/m64 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m32, CL", .orig_opcode = "D3 /4",
		.desc = "Multiply r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m32, CL", .orig_opcode = "D3 /4",
		.desc = "Multiply r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m64, CL", .orig_opcode = "REX.W+ D3 /4",
		.desc = "Multiply r/m64 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m64, CL", .orig_opcode = "REX.W+ D3 /4",
		.desc = "Multiply r/m64 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m32, imm8", .orig_opcode = "C1 /4 ib",
		.desc = "Multiply r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m32, imm8", .orig_opcode = "C1 /4 ib",
		.desc = "Multiply r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m64, imm8", .orig_opcode = "REX.W+ C1 /4 ib",
		.desc = "Multiply r/m64 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAL r/m64, imm8", .orig_opcode = "REX.W+ C1 /4 ib",
		.desc = "Multiply r/m64 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	} } },
	{ "sar", 24, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m8, 1", .orig_opcode = "D0 /7",
		.desc = "Signed divide r/m8 by 2, once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m8, 1", .orig_opcode = "D0 /7",
		.desc = "Signed divide r/m8 by 2, once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m8, CL", .orig_opcode = "D2 /7",
		.desc = "Signed divide r/m8 by 2, CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m8, CL", .orig_opcode = "D2 /7",
		.desc = "Signed divide r/m8 by 2, CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m8, imm8", .orig_opcode = "C0 /7 ib",
		.desc = "Signed divide r/m8 by 2, imm8 time.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m8, imm8", .orig_opcode = "C0 /7 ib",
		.desc = "Signed divide r/m8 by 2, imm8 time.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m16,1", .orig_opcode = "D1 /7",
		.desc = "Signed divide r/m16 by 2, once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m16,1", .orig_opcode = "D1 /7",
		.desc = "Signed divide r/m16 by 2, once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m16, CL", .orig_opcode = "D3 /7",
		.desc = "Signed divide r/m16 by 2, CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m16, CL", .orig_opcode = "D3 /7",
		.desc = "Signed divide r/m16 by 2, CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m16, imm8", .orig_opcode = "C1 /7 ib",
		.desc = "Signed divide r/m16 by 2, imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m16, imm8", .orig_opcode = "C1 /7 ib",
		.desc = "Signed divide r/m16 by 2, imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m32, 1", .orig_opcode = "D1 /7",
		.desc = "Signed divide r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m32, 1", .orig_opcode = "D1 /7",
		.desc = "Signed divide r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { M64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m64, 1", .orig_opcode = "REX.W+ D1 /7",
		.desc = "Signed divide r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { R64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m64, 1", .orig_opcode = "REX.W+ D1 /7",
		.desc = "Signed divide r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m32, CL", .orig_opcode = "D3 /7",
		.desc = "Signed divide r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m32, CL", .orig_opcode = "D3 /7",
		.desc = "Signed divide r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { M64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m64, CL", .orig_opcode = "REX.W+ D3 /7",
		.desc = "Signed divide r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { R64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m64, CL", .orig_opcode = "REX.W+ D3 /7",
		.desc = "Signed divide r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m32, imm8", .orig_opcode = "C1 /7 ib",
		.desc = "Signed divide r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x38, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m32, imm8", .orig_opcode = "C1 /7 ib",
		.desc = "Signed divide r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m64, imm8", .orig_opcode = "REX.W+ C1 /7 ib",
		.desc = "Signed divide r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x38, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SAR r/m64, imm8", .orig_opcode = "REX.W+ C1 /7 ib",
		.desc = "Signed divide r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	} } },
	{ "shl", 24, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m8, 1", .orig_opcode = "D0 /4",
		.desc = "Multiply r/m8 by 2, once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m8, 1", .orig_opcode = "D0 /4",
		.desc = "Multiply r/m8 by 2, once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m8, CL", .orig_opcode = "D2 /4",
		.desc = "Multiply r/m8 by 2, CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m8, CL", .orig_opcode = "D2 /4",
		.desc = "Multiply r/m8 by 2, CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m8, imm8", .orig_opcode = "C0 /4 ib",
		.desc = "Multiply r/m8 by 2, imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m8, imm8", .orig_opcode = "C0 /4 ib",
		.desc = "Multiply r/m8 by 2, imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m16,1", .orig_opcode = "D1 /4",
		.desc = "Multiply r/m16 by 2, once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m16,1", .orig_opcode = "D1 /4",
		.desc = "Multiply r/m16 by 2, once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m16, CL", .orig_opcode = "D3 /4",
		.desc = "Multiply r/m16 by 2, CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m16, CL", .orig_opcode = "D3 /4",
		.desc = "Multiply r/m16 by 2, CL times.",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m16, imm8", .orig_opcode = "C1 /4 ib",
		.desc = "Multiply r/m16 by 2, imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m16, imm8", .orig_opcode = "C1 /4 ib",
		.desc = "Multiply r/m16 by 2, imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m32,1", .orig_opcode = "D1 /4",
		.desc = "Multiply r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m32,1", .orig_opcode = "D1 /4",
		.desc = "Multiply r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m64,1", .orig_opcode = "REX.W+ D1 /4",
		.desc = "Multiply r/m64 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m64,1", .orig_opcode = "REX.W+ D1 /4",
		.desc = "Multiply r/m64 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m32, CL", .orig_opcode = "D3 /4",
		.desc = "Multiply r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m32, CL", .orig_opcode = "D3 /4",
		.desc = "Multiply r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m64, CL", .orig_opcode = "REX.W+ D3 /4",
		.desc = "Multiply r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m64, CL", .orig_opcode = "REX.W+ D3 /4",
		.desc = "Multiply r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m32, imm8", .orig_opcode = "C1 /4 ib",
		.desc = "Multiply r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m32, imm8", .orig_opcode = "C1 /4 ib",
		.desc = "Multiply r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m64, imm8", .orig_opcode = "REX.W+ C1 /4 ib",
		.desc = "Multiply r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHL r/m64, imm8", .orig_opcode = "REX.W+ C1 /4 ib",
		.desc = "Multiply r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	} } },
	{ "shr", 24, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m8,1", .orig_opcode = "D0 /5",
		.desc = "Unsigned divide r/m8 by 2, once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R8, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m8,1", .orig_opcode = "D0 /5",
		.desc = "Unsigned divide r/m8 by 2, once.",
		.opcode = { 0xD0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m8, CL", .orig_opcode = "D2 /5",
		.desc = "Unsigned divide r/m8 by 2, CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R8, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m8, CL", .orig_opcode = "D2 /5",
		.desc = "Unsigned divide r/m8 by 2, CL times.",
		.opcode = { 0xD2 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m8, imm8", .orig_opcode = "C0 /5 ib",
		.desc = "Unsigned divide r/m8 by 2, imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m8, imm8", .orig_opcode = "C0 /5 ib",
		.desc = "Unsigned divide r/m8 by 2, imm8 times.",
		.opcode = { 0xC0 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m16, 1", .orig_opcode = "D1 /5",
		.desc = "Unsigned divide r/m16 by 2, once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R16, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m16, 1", .orig_opcode = "D1 /5",
		.desc = "Unsigned divide r/m16 by 2, once.",
		.prefixes = 0x66, .opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m16, CL", .orig_opcode = "D3 /5",
		.desc = "Unsigned divide r/m16 by 2, CL times",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R16, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m16, CL", .orig_opcode = "D3 /5",
		.desc = "Unsigned divide r/m16 by 2, CL times",
		.prefixes = 0x66, .opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m16, imm8", .orig_opcode = "C1 /5 ib",
		.desc = "Unsigned divide r/m16 by 2, imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m16, imm8", .orig_opcode = "C1 /5 ib",
		.desc = "Unsigned divide r/m16 by 2, imm8 times.",
		.prefixes = 0x66, .opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m32, 1", .orig_opcode = "D1 /5",
		.desc = "Unsigned divide r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R32, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m32, 1", .orig_opcode = "D1 /5",
		.desc = "Unsigned divide r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m64, 1", .orig_opcode = "REX.W+ D1 /5",
		.desc = "Unsigned divide r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { R64, ONE }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m64, 1", .orig_opcode = "REX.W+ D1 /5",
		.desc = "Unsigned divide r/m32 by 2, once.",
		.opcode = { 0xD1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m32, CL", .orig_opcode = "D3 /5",
		.desc = "Unsigned divide r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R32, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m32, CL", .orig_opcode = "D3 /5",
		.desc = "Unsigned divide r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m64, CL", .orig_opcode = "REX.W+ D3 /5",
		.desc = "Unsigned divide r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { R64, CL }, .arglen = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m64, CL", .orig_opcode = "REX.W+ D3 /5",
		.desc = "Unsigned divide r/m32 by 2, CL times.",
		.opcode = { 0xD3 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m32, imm8", .orig_opcode = "C1 /5 ib",
		.desc = "Unsigned divide r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m32, imm8", .orig_opcode = "C1 /5 ib",
		.desc = "Unsigned divide r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m64, imm8", .orig_opcode = "REX.W+ C1 /5 ib",
		.desc = "Unsigned divide r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SHR r/m64, imm8", .orig_opcode = "REX.W+ C1 /5 ib",
		.desc = "Unsigned divide r/m32 by 2, imm8 times.",
		.opcode = { 0xC1 }, .oplen = 1,
	} } },
	{ "sbb", 38, (struct x64LookupActualIns[]) { {
		.args = { AL, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "SBB AL, imm8", .orig_opcode = "1C ib",
		.desc = "Subtract with borrow imm8 from AL.",
		.opcode = { 0x1C }, .oplen = 1,
	}, {
		.args = { AX, IMM16 }, .arglen = 2, .immediate = 2,
		.orig_ins = "SBB AX, imm16", .orig_opcode = "1D iw",
		.desc = "Subtract with borrow imm16 from AX.",
		.prefixes = 0x66, .opcode = { 0x1D }, .oplen = 1,
	}, {
		.args = { EAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "SBB EAX, imm32", .orig_opcode = "1D id",
		.desc = "Subtract with borrow imm32 from EAX.",
		.opcode = { 0x1D }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "SBB RAX, imm32", .orig_opcode = "REX.W+ 1D id",
		.desc = "Subtract with borrow sign-extended imm.32 to 64-bits from RAX.",
		.opcode = { 0x1D }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m8, imm8", .orig_opcode = "80 /3 ib",
		.desc = "Subtract with borrow imm8 from r/m8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m8, imm8", .orig_opcode = "80 /3 ib",
		.desc = "Subtract with borrow imm8 from r/m8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m16, imm16", .orig_opcode = "81 /3 iw",
		.desc = "Subtract with borrow imm16 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m16, imm16", .orig_opcode = "81 /3 iw",
		.desc = "Subtract with borrow imm16 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m32, imm32", .orig_opcode = "81 /3 id",
		.desc = "Subtract with borrow imm32 from r/m32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m32, imm32", .orig_opcode = "81 /3 id",
		.desc = "Subtract with borrow imm32 from r/m32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { M64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m64, imm32", .orig_opcode = "REX.W+ 81 /3 id",
		.desc = "Subtract with borrow sign-extended imm32 to 64-bits from r/m64.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { R64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m64, imm32", .orig_opcode = "REX.W+ 81 /3 id",
		.desc = "Subtract with borrow sign-extended imm32 to 64-bits from r/m64.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m16, imm8", .orig_opcode = "83 /3 ib",
		.desc = "Subtract with borrow sign-extended imm8 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m16, imm8", .orig_opcode = "83 /3 ib",
		.desc = "Subtract with borrow sign-extended imm8 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m32, imm8", .orig_opcode = "83 /3 ib",
		.desc = "Subtract with borrow sign-extended imm8 from r/m32.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m32, imm8", .orig_opcode = "83 /3 ib",
		.desc = "Subtract with borrow sign-extended imm8 from r/m32.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m64, imm8", .orig_opcode = "REX.W+ 83 /3 ib",
		.desc = "Subtract with borrow sign-extended imm8 from r/m64.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SBB r/m64, imm8", .orig_opcode = "REX.W+ 83 /3 ib",
		.desc = "Subtract with borrow sign-extended imm8 from r/m64.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SBB r/m8, r8", .orig_opcode = "18 /r",
		.desc = "Subtract with borrow r8 from r/m8.",
		.opcode = { 0x18 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SBB r/m8, r8", .orig_opcode = "18 /r",
		.desc = "Subtract with borrow r8 from r/m8.",
		.opcode = { 0x18 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SBB r/m8, r8", .orig_opcode = "18 /r",
		.desc = "Subtract with borrow r8 from r/m8.",
		.opcode = { 0x18 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SBB r/m8, r8", .orig_opcode = "18 /r",
		.desc = "Subtract with borrow r8 from r/m8.",
		.opcode = { 0x18 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SBB r/m16, r16", .orig_opcode = "19 /r",
		.desc = "Subtract with borrow r16 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x19 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SBB r/m16, r16", .orig_opcode = "19 /r",
		.desc = "Subtract with borrow r16 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x19 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SBB r/m32, r32", .orig_opcode = "19 /r",
		.desc = "Subtract with borrow r32 from r/m32.",
		.opcode = { 0x19 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SBB r/m32, r32", .orig_opcode = "19 /r",
		.desc = "Subtract with borrow r32 from r/m32.",
		.opcode = { 0x19 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SBB r/m64, r64", .orig_opcode = "REX.W+ 19 /r",
		.desc = "Subtract with borrow r64 from r/m64.",
		.opcode = { 0x19 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SBB r/m64, r64", .orig_opcode = "REX.W+ 19 /r",
		.desc = "Subtract with borrow r64 from r/m64.",
		.opcode = { 0x19 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SBB r8, r/m8", .orig_opcode = "1A /r",
		.desc = "Subtract with borrow r/m8 from r8.",
		.opcode = { 0x1A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SBB r8, r/m8", .orig_opcode = "1A /r",
		.desc = "Subtract with borrow r/m8 from r8.",
		.opcode = { 0x1A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SBB r8, r/m8", .orig_opcode = "1A /r",
		.desc = "Subtract with borrow r/m8 from r8.",
		.opcode = { 0x1A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SBB r8, r/m8", .orig_opcode = "1A /r",
		.desc = "Subtract with borrow r/m8 from r8.",
		.opcode = { 0x1A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SBB r16, r/m16", .orig_opcode = "1B /r",
		.desc = "Subtract with borrow r/m16 from r16.",
		.prefixes = 0x66, .opcode = { 0x1B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SBB r16, r/m16", .orig_opcode = "1B /r",
		.desc = "Subtract with borrow r/m16 from r16.",
		.prefixes = 0x66, .opcode = { 0x1B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SBB r32, r/m32", .orig_opcode = "1B /r",
		.desc = "Subtract with borrow r/m32 from r32.",
		.opcode = { 0x1B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SBB r32, r/m32", .orig_opcode = "1B /r",
		.desc = "Subtract with borrow r/m32 from r32.",
		.opcode = { 0x1B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SBB r64, r/m64", .orig_opcode = "REX.W+ 1B /r",
		.desc = "Subtract with borrow r/m64 from r64.",
		.opcode = { 0x1B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SBB r64, r/m64", .orig_opcode = "REX.W+ 1B /r",
		.desc = "Subtract with borrow r/m64 from r64.",
		.opcode = { 0x1B }, .oplen = 1,
	} } },
	{ "scas", 4, (struct x64LookupActualIns[]) { {
		.args = { M8 }, .arglen = 1,
		.orig_ins = "SCAS m8", .orig_opcode = "AE",
		.desc = "Compare AL with byte at ES:(E)DI or RDI, then set status flags.",
		.opcode = { 0xAE }, .oplen = 1,
	}, {
		.args = { M128 }, .arglen = 1,
		.orig_ins = "SCAS m16", .orig_opcode = "AF",
		.desc = "Compare AX with word at ES:(E)DI or RDI, then set status flags.",
		.opcode = { 0xAF }, .oplen = 1,
	}, {
		.args = { M32 }, .arglen = 1,
		.orig_ins = "SCAS m32", .orig_opcode = "AF",
		.desc = "Compare EAX with doubleword at ES(E)DI or RDI then set status flags.",
		.opcode = { 0xAF }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { M64 }, .arglen = 1,
		.orig_ins = "SCAS m64", .orig_opcode = "REX.W+ AF",
		.desc = "Compare RAX with quadword at RDI or EDI then set status flags.",
		.opcode = { 0xAF }, .oplen = 1,
	} } },
	{ "scasb", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "SCASB", .orig_opcode = "AE",
		.desc = "Compare AL with byte at ES:(E)DI or RDI then set status flags.",
		.opcode = { 0xAE }, .oplen = 1,
	} } },
	{ "scasw", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "SCASW", .orig_opcode = "PREF.66+ AF",
		.desc = "Compare AX with word at ES:(E)DI or RDI then set status flags.",
		.prefixes = 0x66, .opcode = { 0xAF }, .oplen = 1,
	} } },
	{ "scasd", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "SCASD", .orig_opcode = "AF",
		.desc = "Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.",
		.opcode = { 0xAF }, .oplen = 1,
	} } },
	{ "scasq", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, 
		.orig_ins = "SCASQ", .orig_opcode = "REX.W+ AF",
		.desc = "Compare RAX with quadword at RDI or EDI then set status flags.",
		.opcode = { 0xAF }, .oplen = 1,
	} } },
	{ "seta", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETA r/m8", .orig_opcode = "0F 97 /0",
		.desc = "Set byte if above (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x97 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETA r/m8", .orig_opcode = "0F 97 /0",
		.desc = "Set byte if above (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x97 }, .oplen = 2,
	} } },
	{ "setae", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETAE r/m8", .orig_opcode = "0F 93 /0",
		.desc = "Set byte if above or equal (CF=0).",
		.opcode = { 0x0F, 0x93 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETAE r/m8", .orig_opcode = "0F 93 /0",
		.desc = "Set byte if above or equal (CF=0).",
		.opcode = { 0x0F, 0x93 }, .oplen = 2,
	} } },
	{ "setb", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETB r/m8", .orig_opcode = "0F 92 /0",
		.desc = "Set byte if below (CF=1).",
		.opcode = { 0x0F, 0x92 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETB r/m8", .orig_opcode = "0F 92 /0",
		.desc = "Set byte if below (CF=1).",
		.opcode = { 0x0F, 0x92 }, .oplen = 2,
	} } },
	{ "setbe", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETBE r/m8", .orig_opcode = "0F 96 /0",
		.desc = "Set byte if below or equal (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x96 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETBE r/m8", .orig_opcode = "0F 96 /0",
		.desc = "Set byte if below or equal (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x96 }, .oplen = 2,
	} } },
	{ "setc", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETC r/m8", .orig_opcode = "0F 92 /0",
		.desc = "Set byte if carry (CF=1).",
		.opcode = { 0x0F, 0x92 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETC r/m8", .orig_opcode = "0F 92 /0",
		.desc = "Set byte if carry (CF=1).",
		.opcode = { 0x0F, 0x92 }, .oplen = 2,
	} } },
	{ "sete", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETE r/m8", .orig_opcode = "0F 94 /0",
		.desc = "Set byte if equal (ZF=1).",
		.opcode = { 0x0F, 0x94 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETE r/m8", .orig_opcode = "0F 94 /0",
		.desc = "Set byte if equal (ZF=1).",
		.opcode = { 0x0F, 0x94 }, .oplen = 2,
	} } },
	{ "setg", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETG r/m8", .orig_opcode = "0F 9F /0",
		.desc = "Set byte if greater (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x9F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETG r/m8", .orig_opcode = "0F 9F /0",
		.desc = "Set byte if greater (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x9F }, .oplen = 2,
	} } },
	{ "setge", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETGE r/m8", .orig_opcode = "0F 9D /0",
		.desc = "Set byte if greater or equal (SF=OF).",
		.opcode = { 0x0F, 0x9D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETGE r/m8", .orig_opcode = "0F 9D /0",
		.desc = "Set byte if greater or equal (SF=OF).",
		.opcode = { 0x0F, 0x9D }, .oplen = 2,
	} } },
	{ "setl", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETL r/m8", .orig_opcode = "0F 9C /0",
		.desc = "Set byte if less (SF!= OF).",
		.opcode = { 0x0F, 0x9C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETL r/m8", .orig_opcode = "0F 9C /0",
		.desc = "Set byte if less (SF!= OF).",
		.opcode = { 0x0F, 0x9C }, .oplen = 2,
	} } },
	{ "setle", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETLE r/m8", .orig_opcode = "0F 9E /0",
		.desc = "Set byte if less or equal (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x9E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETLE r/m8", .orig_opcode = "0F 9E /0",
		.desc = "Set byte if less or equal (ZF=1 or SF!= OF).",
		.opcode = { 0x0F, 0x9E }, .oplen = 2,
	} } },
	{ "setna", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNA r/m8", .orig_opcode = "0F 96 /0",
		.desc = "Set byte if not above (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x96 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNA r/m8", .orig_opcode = "0F 96 /0",
		.desc = "Set byte if not above (CF=1 or ZF=1).",
		.opcode = { 0x0F, 0x96 }, .oplen = 2,
	} } },
	{ "setnae", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNAE r/m8", .orig_opcode = "0F 92 /0",
		.desc = "Set byte if not above or equal (CF=1).",
		.opcode = { 0x0F, 0x92 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNAE r/m8", .orig_opcode = "0F 92 /0",
		.desc = "Set byte if not above or equal (CF=1).",
		.opcode = { 0x0F, 0x92 }, .oplen = 2,
	} } },
	{ "setnb", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNB r/m8", .orig_opcode = "0F 93 /0",
		.desc = "Set byte if not below (CF=0).",
		.opcode = { 0x0F, 0x93 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNB r/m8", .orig_opcode = "0F 93 /0",
		.desc = "Set byte if not below (CF=0).",
		.opcode = { 0x0F, 0x93 }, .oplen = 2,
	} } },
	{ "setnbe", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNBE r/m8", .orig_opcode = "0F 97 /0",
		.desc = "Set byte if not below or equal (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x97 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNBE r/m8", .orig_opcode = "0F 97 /0",
		.desc = "Set byte if not below or equal (CF=0 and ZF=0).",
		.opcode = { 0x0F, 0x97 }, .oplen = 2,
	} } },
	{ "setnc", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNC r/m8", .orig_opcode = "0F 93 /0",
		.desc = "Set byte if not carry (CF=0).",
		.opcode = { 0x0F, 0x93 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNC r/m8", .orig_opcode = "0F 93 /0",
		.desc = "Set byte if not carry (CF=0).",
		.opcode = { 0x0F, 0x93 }, .oplen = 2,
	} } },
	{ "setne", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNE r/m8", .orig_opcode = "0F 95 /0",
		.desc = "Set byte if not equal (ZF=0).",
		.opcode = { 0x0F, 0x95 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNE r/m8", .orig_opcode = "0F 95 /0",
		.desc = "Set byte if not equal (ZF=0).",
		.opcode = { 0x0F, 0x95 }, .oplen = 2,
	} } },
	{ "setng", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNG r/m8", .orig_opcode = "0F 9E /0",
		.desc = "Set byte if not greater (ZF=1 or SF!= OF)",
		.opcode = { 0x0F, 0x9E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNG r/m8", .orig_opcode = "0F 9E /0",
		.desc = "Set byte if not greater (ZF=1 or SF!= OF)",
		.opcode = { 0x0F, 0x9E }, .oplen = 2,
	} } },
	{ "setnge", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNGE r/m8", .orig_opcode = "0F 9C /0",
		.desc = "Set byte if not greater or equal (SF!= OF).",
		.opcode = { 0x0F, 0x9C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNGE r/m8", .orig_opcode = "0F 9C /0",
		.desc = "Set byte if not greater or equal (SF!= OF).",
		.opcode = { 0x0F, 0x9C }, .oplen = 2,
	} } },
	{ "setnl", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNL r/m8", .orig_opcode = "0F 9D /0",
		.desc = "Set byte if not less (SF=OF).",
		.opcode = { 0x0F, 0x9D }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNL r/m8", .orig_opcode = "0F 9D /0",
		.desc = "Set byte if not less (SF=OF).",
		.opcode = { 0x0F, 0x9D }, .oplen = 2,
	} } },
	{ "setnle", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNLE r/m8", .orig_opcode = "0F 9F /0",
		.desc = "Set byte if not less or equal (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x9F }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNLE r/m8", .orig_opcode = "0F 9F /0",
		.desc = "Set byte if not less or equal (ZF=0 and SF=OF).",
		.opcode = { 0x0F, 0x9F }, .oplen = 2,
	} } },
	{ "setno", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNO r/m8", .orig_opcode = "0F 91 /0",
		.desc = "Set byte if not overflow (OF=0).",
		.opcode = { 0x0F, 0x91 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNO r/m8", .orig_opcode = "0F 91 /0",
		.desc = "Set byte if not overflow (OF=0).",
		.opcode = { 0x0F, 0x91 }, .oplen = 2,
	} } },
	{ "setnp", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNP r/m8", .orig_opcode = "0F 9B /0",
		.desc = "Set byte if not parity (PF=0).",
		.opcode = { 0x0F, 0x9B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNP r/m8", .orig_opcode = "0F 9B /0",
		.desc = "Set byte if not parity (PF=0).",
		.opcode = { 0x0F, 0x9B }, .oplen = 2,
	} } },
	{ "setns", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNS r/m8", .orig_opcode = "0F 99 /0",
		.desc = "Set byte if not sign (SF=0).",
		.opcode = { 0x0F, 0x99 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNS r/m8", .orig_opcode = "0F 99 /0",
		.desc = "Set byte if not sign (SF=0).",
		.opcode = { 0x0F, 0x99 }, .oplen = 2,
	} } },
	{ "setnz", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNZ r/m8", .orig_opcode = "0F 95 /0",
		.desc = "Set byte if not zero (ZF=0).",
		.opcode = { 0x0F, 0x95 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETNZ r/m8", .orig_opcode = "0F 95 /0",
		.desc = "Set byte if not zero (ZF=0).",
		.opcode = { 0x0F, 0x95 }, .oplen = 2,
	} } },
	{ "seto", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETO r/m8", .orig_opcode = "0F 90 /0",
		.desc = "Set byte if overflow (OF=1)",
		.opcode = { 0x0F, 0x90 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETO r/m8", .orig_opcode = "0F 90 /0",
		.desc = "Set byte if overflow (OF=1)",
		.opcode = { 0x0F, 0x90 }, .oplen = 2,
	} } },
	{ "setp", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETP r/m8", .orig_opcode = "0F 9A /0",
		.desc = "Set byte if parity (PF=1).",
		.opcode = { 0x0F, 0x9A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETP r/m8", .orig_opcode = "0F 9A /0",
		.desc = "Set byte if parity (PF=1).",
		.opcode = { 0x0F, 0x9A }, .oplen = 2,
	} } },
	{ "setpe", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETPE r/m8", .orig_opcode = "0F 9A /0",
		.desc = "Set byte if parity even (PF=1).",
		.opcode = { 0x0F, 0x9A }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETPE r/m8", .orig_opcode = "0F 9A /0",
		.desc = "Set byte if parity even (PF=1).",
		.opcode = { 0x0F, 0x9A }, .oplen = 2,
	} } },
	{ "setpo", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETPO r/m8", .orig_opcode = "0F 9B /0",
		.desc = "Set byte if parity odd (PF=0).",
		.opcode = { 0x0F, 0x9B }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETPO r/m8", .orig_opcode = "0F 9B /0",
		.desc = "Set byte if parity odd (PF=0).",
		.opcode = { 0x0F, 0x9B }, .oplen = 2,
	} } },
	{ "sets", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETS r/m8", .orig_opcode = "0F 98 /0",
		.desc = "Set byte if sign (SF=1).",
		.opcode = { 0x0F, 0x98 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETS r/m8", .orig_opcode = "0F 98 /0",
		.desc = "Set byte if sign (SF=1).",
		.opcode = { 0x0F, 0x98 }, .oplen = 2,
	} } },
	{ "setz", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETZ r/m8", .orig_opcode = "0F 94 /0",
		.desc = "Set byte if zero (ZF=1).",
		.opcode = { 0x0F, 0x94 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "SETZ r/m8", .orig_opcode = "0F 94 /0",
		.desc = "Set byte if zero (ZF=1).",
		.opcode = { 0x0F, 0x94 }, .oplen = 2,
	} } },
	{ "sfence", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "SFENCE", .orig_opcode = "0F AE F8",
		.desc = "Serializes store operations.",
		.opcode = { 0x0F, 0xAE, 0xF8 }, .oplen = 3,
	} } },
	{ "sgdt", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32 }, .arglen = 1,
		.orig_ins = "SGDT m", .orig_opcode = "0F 01 /0",
		.desc = "Store GDTR to m.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16 }, .arglen = 1,
		.orig_ins = "SGDT m", .orig_opcode = "0F 01 /0",
		.desc = "Store GDTR to m.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M64 }, .arglen = 1,
		.orig_ins = "SGDT m", .orig_opcode = "0F 01 /0",
		.desc = "Store GDTR to m.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	} } },
	{ "shld", 12, (struct x64LookupActualIns[]) { {
		.args = { M16, R16, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m16, r16, imm8", .orig_opcode = "0F A4",
		.desc = "Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xA4 }, .oplen = 2,
	}, {
		.args = { R16, R16, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m16, r16, imm8", .orig_opcode = "0F A4",
		.desc = "Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xA4 }, .oplen = 2,
	}, {
		.args = { M16, R16, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m16, r16, CL", .orig_opcode = "0F A5",
		.desc = "Shift r/m16 to left CL places while shifting bits from r16 in from the right.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xA5 }, .oplen = 2,
	}, {
		.args = { R16, R16, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m16, r16, CL", .orig_opcode = "0F A5",
		.desc = "Shift r/m16 to left CL places while shifting bits from r16 in from the right.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xA5 }, .oplen = 2,
	}, {
		.args = { M32, R32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m32, r32, imm8", .orig_opcode = "0F A4",
		.desc = "Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.",
		.opcode = { 0x0F, 0xA4 }, .oplen = 2,
	}, {
		.args = { R32, R32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m32, r32, imm8", .orig_opcode = "0F A4",
		.desc = "Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.",
		.opcode = { 0x0F, 0xA4 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { M64, R64, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m64, r64, imm8", .orig_opcode = "REX.W+ 0F A4",
		.desc = "Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.",
		.opcode = { 0x0F, 0xA4 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, R64, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m64, r64, imm8", .orig_opcode = "REX.W+ 0F A4",
		.desc = "Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.",
		.opcode = { 0x0F, 0xA4 }, .oplen = 2,
	}, {
		.args = { M32, R32, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m32, r32, CL", .orig_opcode = "0F A5",
		.desc = "Shift r/m32 to left CL places while shifting bits from r32 in from the right.",
		.opcode = { 0x0F, 0xA5 }, .oplen = 2,
	}, {
		.args = { R32, R32, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m32, r32, CL", .orig_opcode = "0F A5",
		.desc = "Shift r/m32 to left CL places while shifting bits from r32 in from the right.",
		.opcode = { 0x0F, 0xA5 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { M64, R64, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m64, r64, CL", .orig_opcode = "REX.W+ 0F A5",
		.desc = "Shift r/m64 to left CL places while shifting bits from r64 in from the right.",
		.opcode = { 0x0F, 0xA5 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, R64, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHLD r/m64, r64, CL", .orig_opcode = "REX.W+ 0F A5",
		.desc = "Shift r/m64 to left CL places while shifting bits from r64 in from the right.",
		.opcode = { 0x0F, 0xA5 }, .oplen = 2,
	} } },
	{ "shrd", 12, (struct x64LookupActualIns[]) { {
		.args = { M16, R16, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m16, r16, imm8", .orig_opcode = "0F AC",
		.desc = "Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAC }, .oplen = 2,
	}, {
		.args = { R16, R16, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m16, r16, imm8", .orig_opcode = "0F AC",
		.desc = "Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAC }, .oplen = 2,
	}, {
		.args = { M16, R16, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m16, r16, CL", .orig_opcode = "0F AD",
		.desc = "Shift r/m16 to right CL places while shifting bits from r16 in from the left.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAD }, .oplen = 2,
	}, {
		.args = { R16, R16, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m16, r16, CL", .orig_opcode = "0F AD",
		.desc = "Shift r/m16 to right CL places while shifting bits from r16 in from the left.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAD }, .oplen = 2,
	}, {
		.args = { M32, R32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m32, r32, imm8", .orig_opcode = "0F AC",
		.desc = "Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.",
		.opcode = { 0x0F, 0xAC }, .oplen = 2,
	}, {
		.args = { R32, R32, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m32, r32, imm8", .orig_opcode = "0F AC",
		.desc = "Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.",
		.opcode = { 0x0F, 0xAC }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { M64, R64, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m64, r64, imm8", .orig_opcode = "REX.W+ 0F AC",
		.desc = "Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.",
		.opcode = { 0x0F, 0xAC }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, R64, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m64, r64, imm8", .orig_opcode = "REX.W+ 0F AC",
		.desc = "Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.",
		.opcode = { 0x0F, 0xAC }, .oplen = 2,
	}, {
		.args = { M32, R32, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m32, r32, CL", .orig_opcode = "0F AD",
		.desc = "Shift r/m32 to right CL places while shifting bits from r32 in from the left.",
		.opcode = { 0x0F, 0xAD }, .oplen = 2,
	}, {
		.args = { R32, R32, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m32, r32, CL", .orig_opcode = "0F AD",
		.desc = "Shift r/m32 to right CL places while shifting bits from r32 in from the left.",
		.opcode = { 0x0F, 0xAD }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { M64, R64, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m64, r64, CL", .orig_opcode = "REX.W+ 0F AD",
		.desc = "Shift r/m64 to right CL places while shifting bits from r64 in from the left.",
		.opcode = { 0x0F, 0xAD }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { R64, R64, CL }, .arglen = 3, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SHRD r/m64, r64, CL", .orig_opcode = "REX.W+ 0F AD",
		.desc = "Shift r/m64 to right CL places while shifting bits from r64 in from the left.",
		.opcode = { 0x0F, 0xAD }, .oplen = 2,
	} } },
	{ "shufpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SHUFPD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F C6 /r ib",
		.desc = "Shuffle packed double-precision floating- point values selected by imm8 from xmm1 and xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC6 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SHUFPD xmm1, xmm2/m128, imm8", .orig_opcode = "66 0F C6 /r ib",
		.desc = "Shuffle packed double-precision floating- point values selected by imm8 from xmm1 and xmm2/m128 to xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC6 }, .oplen = 2,
	} } },
	{ "shufps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SHUFPS xmm1, xmm2/m128, imm8", .orig_opcode = "0F C6 /r ib",
		.desc = "Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.",
		.opcode = { 0x0F, 0xC6 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM, IMM8 }, .arglen = 3, .immediate = 3, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SHUFPS xmm1, xmm2/m128, imm8", .orig_opcode = "0F C6 /r ib",
		.desc = "Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.",
		.opcode = { 0x0F, 0xC6 }, .oplen = 2,
	} } },
	{ "sidt", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M32 }, .arglen = 1,
		.orig_ins = "SIDT m", .orig_opcode = "0F 01 /1",
		.desc = "Store IDTR to m.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M16 }, .arglen = 1,
		.orig_ins = "SIDT m", .orig_opcode = "0F 01 /1",
		.desc = "Store IDTR to m.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M64 }, .arglen = 1,
		.orig_ins = "SIDT m", .orig_opcode = "0F 01 /1",
		.desc = "Store IDTR to m.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	} } },
	{ "sldt", 4, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16 }, .arglen = 1,
		.orig_ins = "SLDT r/m16", .orig_opcode = "0F 00 /0",
		.desc = "Stores segment selector from LDTR in r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x00 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16 }, .arglen = 1,
		.orig_ins = "SLDT r/m16", .orig_opcode = "0F 00 /0",
		.desc = "Stores segment selector from LDTR in r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x00 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { M128 }, .arglen = 1,
		.orig_ins = "SLDT r64/m16", .orig_opcode = "REX.W+ 0F 00 /0",
		.desc = "Stores segment selector from LDTR in r64/m16.",
		.opcode = { 0x0F, 0x00 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { R64 }, .arglen = 1,
		.orig_ins = "SLDT r64/m16", .orig_opcode = "REX.W+ 0F 00 /0",
		.desc = "Stores segment selector from LDTR in r64/m16.",
		.opcode = { 0x0F, 0x00 }, .oplen = 2,
	} } },
	{ "smsw", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16 }, .arglen = 1,
		.orig_ins = "SMSW r/m16", .orig_opcode = "0F 01 /4",
		.desc = "Store machine status word to r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16 }, .arglen = 1,
		.orig_ins = "SMSW r/m16", .orig_opcode = "0F 01 /4",
		.desc = "Store machine status word to r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M128 }, .arglen = 1,
		.orig_ins = "SMSW r32/m16", .orig_opcode = "0F 01 /4",
		.desc = "Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R32 }, .arglen = 1,
		.orig_ins = "SMSW r32/m16", .orig_opcode = "0F 01 /4",
		.desc = "Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M128 }, .arglen = 1,
		.orig_ins = "SMSW r64/m16", .orig_opcode = "REX.W+ 0F 01 /4",
		.desc = "Store machine status word in low-order 16 bits of r64/m16; high-order 16 bits of r32 are undefined.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { R64 }, .arglen = 1,
		.orig_ins = "SMSW r64/m16", .orig_opcode = "REX.W+ 0F 01 /4",
		.desc = "Store machine status word in low-order 16 bits of r64/m16; high-order 16 bits of r32 are undefined.",
		.opcode = { 0x0F, 0x01 }, .oplen = 2,
	} } },
	{ "sqrtpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SQRTPD xmm1, xmm2/m128", .orig_opcode = "66 0F 51 /r",
		.desc = "Computes square roots of the packed double- precision floating-point values in xmm2/m128 and stores the results in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x51 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SQRTPD xmm1, xmm2/m128", .orig_opcode = "66 0F 51 /r",
		.desc = "Computes square roots of the packed double- precision floating-point values in xmm2/m128 and stores the results in xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x51 }, .oplen = 2,
	} } },
	{ "sqrtps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SQRTPS xmm1, xmm2/m128", .orig_opcode = "0F 51 /r",
		.desc = "Computes square roots of the packed single- precision floating-point values in xmm2/m128 and stores the results in xmm1.",
		.opcode = { 0x0F, 0x51 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SQRTPS xmm1, xmm2/m128", .orig_opcode = "0F 51 /r",
		.desc = "Computes square roots of the packed single- precision floating-point values in xmm2/m128 and stores the results in xmm1.",
		.opcode = { 0x0F, 0x51 }, .oplen = 2,
	} } },
	{ "sqrtsd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SQRTSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 51 /r",
		.desc = "Computes square root of the low double- precision floating-point value in xmm2/m64 and stores the results in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x51 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SQRTSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 51 /r",
		.desc = "Computes square root of the low double- precision floating-point value in xmm2/m64 and stores the results in xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x51 }, .oplen = 2,
	} } },
	{ "sqrtss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SQRTSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 51 /r",
		.desc = "Computes square root of the low single- precision floating-point value in xmm2/m32 and stores the results in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x51 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SQRTSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 51 /r",
		.desc = "Computes square root of the low single- precision floating-point value in xmm2/m32 and stores the results in xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x51 }, .oplen = 2,
	} } },
	{ "stc", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "STC", .orig_opcode = "F9",
		.desc = "Set CF flag.",
		.opcode = { 0xF9 }, .oplen = 1,
	} } },
	{ "std", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "STD", .orig_opcode = "FD",
		.desc = "Set DF flag.",
		.opcode = { 0xFD }, .oplen = 1,
	} } },
	{ "sti", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "STI", .orig_opcode = "FB",
		.desc = "Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction.",
		.opcode = { 0xFB }, .oplen = 1,
	} } },
	{ "stmxcsr", 1, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "STMXCSR m32", .orig_opcode = "0F AE /3",
		.desc = "Store contents of MXCSR register to m32.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "stos", 4, (struct x64LookupActualIns[]) { {
		.args = { M8 }, .arglen = 1,
		.orig_ins = "STOS m8", .orig_opcode = "AA",
		.desc = "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.",
		.opcode = { 0xAA }, .oplen = 1,
	}, {
		.args = { M128 }, .arglen = 1,
		.orig_ins = "STOS m16", .orig_opcode = "AB",
		.desc = "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.",
		.opcode = { 0xAB }, .oplen = 1,
	}, {
		.args = { M32 }, .arglen = 1,
		.orig_ins = "STOS m32", .orig_opcode = "AB",
		.desc = "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.",
		.opcode = { 0xAB }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { M64 }, .arglen = 1,
		.orig_ins = "STOS m64", .orig_opcode = "REX.W+ AB",
		.desc = "Store RAX at address RDI or EDI.",
		.opcode = { 0xAB }, .oplen = 1,
	} } },
	{ "stosb", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "STOSB", .orig_opcode = "AA",
		.desc = "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.",
		.opcode = { 0xAA }, .oplen = 1,
	} } },
	{ "stosw", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "STOSW", .orig_opcode = "PREF.66+ AB",
		.desc = "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.",
		.prefixes = 0x66, .opcode = { 0xAB }, .oplen = 1,
	} } },
	{ "stosd", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "STOSD", .orig_opcode = "AB",
		.desc = "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.",
		.opcode = { 0xAB }, .oplen = 1,
	} } },
	{ "stosq", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, 
		.orig_ins = "STOSQ", .orig_opcode = "REX.W+ AB",
		.desc = "Store RAX at address RDI or EDI.",
		.opcode = { 0xAB }, .oplen = 1,
	} } },
	{ "str", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x8, 
		.args = { M16 }, .arglen = 1,
		.orig_ins = "STR r/m16", .orig_opcode = "0F 00 /1",
		.desc = "Stores segment selector from TR in r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x00 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x8, 
		.args = { R16 }, .arglen = 1,
		.orig_ins = "STR r/m16", .orig_opcode = "0F 00 /1",
		.desc = "Stores segment selector from TR in r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x00 }, .oplen = 2,
	} } },
	{ "sub", 38, (struct x64LookupActualIns[]) { {
		.args = { AL, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "SUB AL, imm8", .orig_opcode = "2C ib",
		.desc = "Subtract imm8 from AL.",
		.opcode = { 0x2C }, .oplen = 1,
	}, {
		.args = { AX, IMM16 }, .arglen = 2, .immediate = 2,
		.orig_ins = "SUB AX, imm16", .orig_opcode = "2D iw",
		.desc = "Subtract imm16 from AX.",
		.prefixes = 0x66, .opcode = { 0x2D }, .oplen = 1,
	}, {
		.args = { EAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "SUB EAX, imm32", .orig_opcode = "2D id",
		.desc = "Subtract imm32 from EAX.",
		.opcode = { 0x2D }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "SUB RAX, imm32", .orig_opcode = "REX.W+ 2D id",
		.desc = "Subtract imm32 sign-extended to 64-bits from RAX.",
		.opcode = { 0x2D }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m8, imm8", .orig_opcode = "80 /5 ib",
		.desc = "Subtract imm8 from r/m8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m8, imm8", .orig_opcode = "80 /5 ib",
		.desc = "Subtract imm8 from r/m8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m16, imm16", .orig_opcode = "81 /5 iw",
		.desc = "Subtract imm16 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m16, imm16", .orig_opcode = "81 /5 iw",
		.desc = "Subtract imm16 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m32, imm32", .orig_opcode = "81 /5 id",
		.desc = "Subtract imm32 from r/m32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m32, imm32", .orig_opcode = "81 /5 id",
		.desc = "Subtract imm32 from r/m32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m64, imm32", .orig_opcode = "REX.W+ 81 /5 id",
		.desc = "Subtract imm32 sign-extended to 64-bits from r/m64.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { R64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m64, imm32", .orig_opcode = "REX.W+ 81 /5 id",
		.desc = "Subtract imm32 sign-extended to 64-bits from r/m64.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m16, imm8", .orig_opcode = "83 /5 ib",
		.desc = "Subtract sign-extended imm8 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m16, imm8", .orig_opcode = "83 /5 ib",
		.desc = "Subtract sign-extended imm8 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m32, imm8", .orig_opcode = "83 /5 ib",
		.desc = "Subtract sign-extended imm8 from r/m32.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m32, imm8", .orig_opcode = "83 /5 ib",
		.desc = "Subtract sign-extended imm8 from r/m32.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m64, imm8", .orig_opcode = "REX.W+ 83 /5 ib",
		.desc = "Subtract sign-extended imm8 from r/m64.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "SUB r/m64, imm8", .orig_opcode = "REX.W+ 83 /5 ib",
		.desc = "Subtract sign-extended imm8 from r/m64.",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SUB r/m8, r8", .orig_opcode = "28 /r",
		.desc = "Subtract r8 from r/m8.",
		.opcode = { 0x28 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SUB r/m8, r8", .orig_opcode = "28 /r",
		.desc = "Subtract r8 from r/m8.",
		.opcode = { 0x28 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SUB r/m8, r8", .orig_opcode = "28 /r",
		.desc = "Subtract r8 from r/m8.",
		.opcode = { 0x28 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SUB r/m8, r8", .orig_opcode = "28 /r",
		.desc = "Subtract r8 from r/m8.",
		.opcode = { 0x28 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SUB r/m16, r16", .orig_opcode = "29 /r",
		.desc = "Subtract r16 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x29 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SUB r/m16, r16", .orig_opcode = "29 /r",
		.desc = "Subtract r16 from r/m16.",
		.prefixes = 0x66, .opcode = { 0x29 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SUB r/m32, r32", .orig_opcode = "29 /r",
		.desc = "Subtract r32 from r/m32.",
		.opcode = { 0x29 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SUB r/m32, r32", .orig_opcode = "29 /r",
		.desc = "Subtract r32 from r/m32.",
		.opcode = { 0x29 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SUB r/m64, r64", .orig_opcode = "REX.W+ 29 /r",
		.desc = "Subtract r64 from r/m64.",
		.opcode = { 0x29 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "SUB r/m64, r64", .orig_opcode = "REX.W+ 29 /r",
		.desc = "Subtract r64 from r/m64.",
		.opcode = { 0x29 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUB r8, r/m8", .orig_opcode = "2A /r",
		.desc = "Subtract r/m8 from r8.",
		.opcode = { 0x2A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUB r8, r/m8", .orig_opcode = "2A /r",
		.desc = "Subtract r/m8 from r8.",
		.opcode = { 0x2A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUB r8, r/m8", .orig_opcode = "2A /r",
		.desc = "Subtract r/m8 from r8.",
		.opcode = { 0x2A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUB r8, r/m8", .orig_opcode = "2A /r",
		.desc = "Subtract r/m8 from r8.",
		.opcode = { 0x2A }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUB r16, r/m16", .orig_opcode = "2B /r",
		.desc = "Subtract r/m16 from r16.",
		.prefixes = 0x66, .opcode = { 0x2B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUB r16, r/m16", .orig_opcode = "2B /r",
		.desc = "Subtract r/m16 from r16.",
		.prefixes = 0x66, .opcode = { 0x2B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUB r32, r/m32", .orig_opcode = "2B /r",
		.desc = "Subtract r/m32 from r32.",
		.opcode = { 0x2B }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUB r32, r/m32", .orig_opcode = "2B /r",
		.desc = "Subtract r/m32 from r32.",
		.opcode = { 0x2B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUB r64, r/m64", .orig_opcode = "REX.W+ 2B /r",
		.desc = "Subtract r/m64 from r64.",
		.opcode = { 0x2B }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUB r64, r/m64", .orig_opcode = "REX.W+ 2B /r",
		.desc = "Subtract r/m64 from r64.",
		.opcode = { 0x2B }, .oplen = 1,
	} } },
	{ "subpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUBPD xmm1, xmm2/m128", .orig_opcode = "66 0F 5C /r",
		.desc = "Subtract packed double-precision floating- point values in xmm2/m128 from xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUBPD xmm1, xmm2/m128", .orig_opcode = "66 0F 5C /r",
		.desc = "Subtract packed double-precision floating- point values in xmm2/m128 from xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x5C }, .oplen = 2,
	} } },
	{ "subps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUBPS xmm1, xmm2/m128", .orig_opcode = "0F 5C /r",
		.desc = "Subtract packed single-precision floating-point values in xmm2/mem from xmm1.",
		.opcode = { 0x0F, 0x5C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUBPS xmm1, xmm2/m128", .orig_opcode = "0F 5C /r",
		.desc = "Subtract packed single-precision floating-point values in xmm2/mem from xmm1.",
		.opcode = { 0x0F, 0x5C }, .oplen = 2,
	} } },
	{ "subsd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUBSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 5C /r",
		.desc = "Subtracts the low double-precision floating- point values in xmm2/mem64 from xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x5C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUBSD xmm1, xmm2/m64", .orig_opcode = "F2 0F 5C /r",
		.desc = "Subtracts the low double-precision floating- point values in xmm2/mem64 from xmm1.",
		.prefixes = 0xF2, .opcode = { 0x0F, 0x5C }, .oplen = 2,
	} } },
	{ "subss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUBSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 5C /r",
		.desc = "Subtract the lower single-precision floating- point values in xmm2/m32 from xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5C }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "SUBSS xmm1, xmm2/m32", .orig_opcode = "F3 0F 5C /r",
		.desc = "Subtract the lower single-precision floating- point values in xmm2/m32 from xmm1.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0x5C }, .oplen = 2,
	} } },
	{ "swapgs", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "SWAPGS", .orig_opcode = "0F 01 F8",
		.desc = "Exchanges the current GS base register value with the value contained in MSR address C0000102H.",
		.opcode = { 0x0F, 0x01, 0xF8 }, .oplen = 3,
	} } },
	{ "syscall", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "SYSCALL", .orig_opcode = "0F 05",
		.desc = "Fast call to privilege level 0 system procedures.",
		.opcode = { 0x0F, 0x05 }, .oplen = 2,
	} } },
	{ "sysenter", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "SYSENTER", .orig_opcode = "0F 34",
		.desc = "Fast call to privilege level 0 system procedures.",
		.opcode = { 0x0F, 0x34 }, .oplen = 2,
	} } },
	{ "sysexit", 2, (struct x64LookupActualIns[]) { {
		.orig_ins = "SYSEXIT", .orig_opcode = "0F 35",
		.desc = "Fast return to privilege level 3 user code.",
		.opcode = { 0x0F, 0x35 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { PREFREX_W }, .arglen = 1,
		.orig_ins = "SYSEXIT pw", .orig_opcode = "REX.W+ 0F 35",
		.desc = "Fast return to 64-bit mode privilege level 3 user code.",
		.opcode = { 0x0F, 0x35 }, .oplen = 2,
	} } },
	{ "sysret", 2, (struct x64LookupActualIns[]) { {
		.orig_ins = "SYSRET", .orig_opcode = "0F 07",
		.desc = "Return to compatibility mode from fast system call",
		.opcode = { 0x0F, 0x07 }, .oplen = 2,
	}, {
		.rex = 0x48, 
		.args = { PREFREX_W }, .arglen = 1,
		.orig_ins = "SYSRET pw", .orig_opcode = "REX.W+ 0F 07",
		.desc = "Return to 64-bit mode from fast system call",
		.opcode = { 0x0F, 0x07 }, .oplen = 2,
	} } },
	{ "test", 22, (struct x64LookupActualIns[]) { {
		.args = { AL, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "TEST AL, imm8", .orig_opcode = "A8 ib",
		.desc = "AND imm8 with AL; set SF, ZF, PF according to result.",
		.opcode = { 0xA8 }, .oplen = 1,
	}, {
		.args = { AX, IMM16 }, .arglen = 2, .immediate = 2,
		.orig_ins = "TEST AX, imm16", .orig_opcode = "A9 iw",
		.desc = "AND imm16 with AX; set SF, ZF, PF according to result.",
		.prefixes = 0x66, .opcode = { 0xA9 }, .oplen = 1,
	}, {
		.args = { EAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "TEST EAX, imm32", .orig_opcode = "A9 id",
		.desc = "AND imm32 with EAX; set SF, ZF, PF according to result.",
		.opcode = { 0xA9 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "TEST RAX, imm32", .orig_opcode = "REX.W+ A9 id",
		.desc = "AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result.",
		.opcode = { 0xA9 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "TEST r/m8, imm8", .orig_opcode = "F6 /0 ib",
		.desc = "AND imm8 with r/m8; set SF, ZF, PF according to result.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "TEST r/m8, imm8", .orig_opcode = "F6 /0 ib",
		.desc = "AND imm8 with r/m8; set SF, ZF, PF according to result.",
		.opcode = { 0xF6 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "TEST r/m16, imm16", .orig_opcode = "F7 /0 iw",
		.desc = "AND imm16 with r/m16; set SF, ZF, PF according to result.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "TEST r/m16, imm16", .orig_opcode = "F7 /0 iw",
		.desc = "AND imm16 with r/m16; set SF, ZF, PF according to result.",
		.prefixes = 0x66, .opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { M32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "TEST r/m32, imm32", .orig_opcode = "F7 /0 id",
		.desc = "AND imm32 with r/m32; set SF, ZF, PF according to result.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x0, 
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "TEST r/m32, imm32", .orig_opcode = "F7 /0 id",
		.desc = "AND imm32 with r/m32; set SF, ZF, PF according to result.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { M64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "TEST r/m64, imm32", .orig_opcode = "REX.W+ F7 /0 id",
		.desc = "AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x0, 
		.args = { R64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "TEST r/m64, imm32", .orig_opcode = "REX.W+ F7 /0 id",
		.desc = "AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.",
		.opcode = { 0xF7 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "TEST r/m8, r8", .orig_opcode = "84 /r",
		.desc = "AND r8 with r/m8; set SF, ZF, PF according to result.",
		.opcode = { 0x84 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "TEST r/m8, r8", .orig_opcode = "84 /r",
		.desc = "AND r8 with r/m8; set SF, ZF, PF according to result.",
		.opcode = { 0x84 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "TEST r/m8, r8", .orig_opcode = "84 /r",
		.desc = "AND r8 with r/m8; set SF, ZF, PF according to result.",
		.opcode = { 0x84 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "TEST r/m8, r8", .orig_opcode = "84 /r",
		.desc = "AND r8 with r/m8; set SF, ZF, PF according to result.",
		.opcode = { 0x84 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "TEST r/m16, r16", .orig_opcode = "85 /r",
		.desc = "AND r16 with r/m16; set SF, ZF, PF according to result.",
		.prefixes = 0x66, .opcode = { 0x85 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "TEST r/m16, r16", .orig_opcode = "85 /r",
		.desc = "AND r16 with r/m16; set SF, ZF, PF according to result.",
		.prefixes = 0x66, .opcode = { 0x85 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "TEST r/m32, r32", .orig_opcode = "85 /r",
		.desc = "AND r32 with r/m32; set SF, ZF, PF according to result.",
		.opcode = { 0x85 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "TEST r/m32, r32", .orig_opcode = "85 /r",
		.desc = "AND r32 with r/m32; set SF, ZF, PF according to result.",
		.opcode = { 0x85 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "TEST r/m64, r64", .orig_opcode = "REX.W+ 85 /r",
		.desc = "AND r64 with r/m64; set SF, ZF, PF according to result.",
		.opcode = { 0x85 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "TEST r/m64, r64", .orig_opcode = "REX.W+ 85 /r",
		.desc = "AND r64 with r/m64; set SF, ZF, PF according to result.",
		.opcode = { 0x85 }, .oplen = 1,
	} } },
	{ "tzcnt", 6, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "TZCNT r16, r/m16", .orig_opcode = "F3 0F BC /r",
		.desc = "Count the number of trailing zero bits in r/m16, return result in r16.",
		.prefixes = 0x66F3, .opcode = { 0x0F, 0xBC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "TZCNT r16, r/m16", .orig_opcode = "F3 0F BC /r",
		.desc = "Count the number of trailing zero bits in r/m16, return result in r16.",
		.prefixes = 0x66F3, .opcode = { 0x0F, 0xBC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "TZCNT r32, r/m32", .orig_opcode = "F3 0F BC /r",
		.desc = "Count the number of trailing zero bits in r/m32, return result in r32.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xBC }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "TZCNT r32, r/m32", .orig_opcode = "F3 0F BC /r",
		.desc = "Count the number of trailing zero bits in r/m32, return result in r32.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xBC }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "TZCNT r64, r/m64", .orig_opcode = "REX.W+ F3 0F BC /r",
		.desc = "Count the number of trailing zero bits in r/m64, return result in r64.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xBC }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "TZCNT r64, r/m64", .orig_opcode = "REX.W+ F3 0F BC /r",
		.desc = "Count the number of trailing zero bits in r/m64, return result in r64.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xBC }, .oplen = 2,
	} } },
	{ "ucomisd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UCOMISD xmm1, xmm2/m64", .orig_opcode = "66 0F 2E /r",
		.desc = "Compares (unordered) the low double- precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UCOMISD xmm1, xmm2/m64", .orig_opcode = "66 0F 2E /r",
		.desc = "Compares (unordered) the low double- precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x2E }, .oplen = 2,
	} } },
	{ "ucomiss", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UCOMISS xmm1, xmm2/m32", .orig_opcode = "0F 2E /r",
		.desc = "Compare lower single-precision floating-point value in xmm1 register with lower single- precision floating-point value in xmm2/mem and set the status flags accordingly.",
		.opcode = { 0x0F, 0x2E }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UCOMISS xmm1, xmm2/m32", .orig_opcode = "0F 2E /r",
		.desc = "Compare lower single-precision floating-point value in xmm1 register with lower single- precision floating-point value in xmm2/mem and set the status flags accordingly.",
		.opcode = { 0x0F, 0x2E }, .oplen = 2,
	} } },
	{ "ud2", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "UD2", .orig_opcode = "0F 0B",
		.desc = "Raise invalid opcode exception.",
		.opcode = { 0x0F, 0x0B }, .oplen = 2,
	} } },
	{ "unpckhpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UNPCKHPD xmm1, xmm2/m128", .orig_opcode = "66 0F 15 /r",
		.desc = "Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x15 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UNPCKHPD xmm1, xmm2/m128", .orig_opcode = "66 0F 15 /r",
		.desc = "Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x15 }, .oplen = 2,
	} } },
	{ "unpckhps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UNPCKHPS xmm1, xmm2/m128", .orig_opcode = "0F 15 /r",
		.desc = "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.",
		.opcode = { 0x0F, 0x15 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UNPCKHPS xmm1, xmm2/m128", .orig_opcode = "0F 15 /r",
		.desc = "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.",
		.opcode = { 0x0F, 0x15 }, .oplen = 2,
	} } },
	{ "unpcklpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UNPCKLPD xmm1, xmm2/m128", .orig_opcode = "66 0F 14 /r",
		.desc = "Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x14 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UNPCKLPD xmm1, xmm2/m128", .orig_opcode = "66 0F 14 /r",
		.desc = "Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x14 }, .oplen = 2,
	} } },
	{ "unpcklps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UNPCKLPS xmm1, xmm2/m128", .orig_opcode = "0F 14 /r",
		.desc = "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.",
		.opcode = { 0x0F, 0x14 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "UNPCKLPS xmm1, xmm2/m128", .orig_opcode = "0F 14 /r",
		.desc = "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.",
		.opcode = { 0x0F, 0x14 }, .oplen = 2,
	} } },
	{ "verr", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "VERR r/m16", .orig_opcode = "0F 00 /4",
		.desc = "Set ZF=1 if segment specified with r/m16 can be read.",
		.opcode = { 0x0F, 0x00 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "VERR r/m16", .orig_opcode = "0F 00 /4",
		.desc = "Set ZF=1 if segment specified with r/m16 can be read.",
		.opcode = { 0x0F, 0x00 }, .oplen = 2,
	} } },
	{ "verw", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "VERW r/m16", .orig_opcode = "0F 00 /5",
		.desc = "Set ZF=1 if segment specified with r/m16 can be written.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x00 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { R16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "VERW r/m16", .orig_opcode = "0F 00 /5",
		.desc = "Set ZF=1 if segment specified with r/m16 can be written.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x00 }, .oplen = 2,
	} } },
	{ "wait", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "WAIT", .orig_opcode = "9B",
		.desc = "Check pending unmasked floating-point exceptions.",
		.prefixes = 0x9B, .opcode = {  }, .oplen = 0,
	} } },
	{ "fwait", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "FWAIT", .orig_opcode = "9B",
		.desc = "Check pending unmasked floating-point exceptions.",
		.prefixes = 0x9B, .opcode = {  }, .oplen = 0,
	} } },
	{ "wbinvd", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "WBINVD", .orig_opcode = "0F 09",
		.desc = "Write back and flush Internal caches; initiate writing-back and flushing of external caches.",
		.opcode = { 0x0F, 0x09 }, .oplen = 2,
	} } },
	{ "wrfsbase", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x10, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "WRFSBASE r32", .orig_opcode = "F3 0F AE /2",
		.desc = "Load the FS base address with the 32-bit value in the source register.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x10, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "WRFSBASE r64", .orig_opcode = "REX.W+ F3 0F AE /2",
		.desc = "Load the FS base address with the 64-bit value in the source register.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "wrgsbase", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x18, 
		.args = { R32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "WRGSBASE r32", .orig_opcode = "F3 0F AE /3",
		.desc = "Load the GS base address with the 32-bit value in the source register.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x18, 
		.args = { R64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "WRGSBASE r64", .orig_opcode = "REX.W+ F3 0F AE /3",
		.desc = "Load the GS base address with the 64-bit value in the source register.",
		.prefixes = 0xF3, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "wrmsr", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "WRMSR", .orig_opcode = "0F 30",
		.desc = "Write the value in EDX:EAX to MSR specified by ECX.",
		.opcode = { 0x0F, 0x30 }, .oplen = 2,
	} } },
	{ "xacquire", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "XACQUIRE", .orig_opcode = "F2",
		.desc = "A hint used with an \"XACQUIRE-enabled\" instruction to start lock elision on the instruction memory operand address.",
		.prefixes = 0xF2, .opcode = {  }, .oplen = 0,
	} } },
	{ "xrelease", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "XRELEASE", .orig_opcode = "F3",
		.desc = "A hint used with an \"XRELEASE-enabled\" instruction to end lock elision on the instruction memory operand address.",
		.prefixes = 0xF3, .opcode = {  }, .oplen = 0,
	} } },
	{ "xabort", 1, (struct x64LookupActualIns[]) { {
		.args = { IMM8 }, .arglen = 1, .immediate = 1,
		.orig_ins = "XABORT imm8", .orig_opcode = "C6 F8 ib",
		.desc = "Causes an RTM abort if in RTM execution",
		.opcode = { 0xC6, 0xF8 }, .oplen = 2,
	} } },
	{ "xadd", 10, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XADD r/m8, r8", .orig_opcode = "0F C0 /r",
		.desc = "Exchange r8 and r/m8; load sum into r/m8.",
		.opcode = { 0x0F, 0xC0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XADD r/m8, r8", .orig_opcode = "0F C0 /r",
		.desc = "Exchange r8 and r/m8; load sum into r/m8.",
		.opcode = { 0x0F, 0xC0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XADD r/m8, r8", .orig_opcode = "0F C0 /r",
		.desc = "Exchange r8 and r/m8; load sum into r/m8.",
		.opcode = { 0x0F, 0xC0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XADD r/m8, r8", .orig_opcode = "0F C0 /r",
		.desc = "Exchange r8 and r/m8; load sum into r/m8.",
		.opcode = { 0x0F, 0xC0 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XADD r/m16, r16", .orig_opcode = "0F C1 /r",
		.desc = "Exchange r16 and r/m16; load sum into r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XADD r/m16, r16", .orig_opcode = "0F C1 /r",
		.desc = "Exchange r16 and r/m16; load sum into r/m16.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xC1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XADD r/m32, r32", .orig_opcode = "0F C1 /r",
		.desc = "Exchange r32 and r/m32; load sum into r/m32.",
		.opcode = { 0x0F, 0xC1 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XADD r/m32, r32", .orig_opcode = "0F C1 /r",
		.desc = "Exchange r32 and r/m32; load sum into r/m32.",
		.opcode = { 0x0F, 0xC1 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XADD r/m64, r64", .orig_opcode = "REX.W+ 0F C1 /r",
		.desc = "Exchange r64 and r/m64; load sum into r/m64.",
		.opcode = { 0x0F, 0xC1 }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XADD r/m64, r64", .orig_opcode = "REX.W+ 0F C1 /r",
		.desc = "Exchange r64 and r/m64; load sum into r/m64.",
		.opcode = { 0x0F, 0xC1 }, .oplen = 2,
	} } },
	{ "xbegin", 1, (struct x64LookupActualIns[]) { {
		.args = { REL32 }, .arglen = 1,
		.orig_ins = "XBEGIN rel32", .orig_opcode = "C7 F8",
		.desc = "Specifies the start of an RTM region. Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.",
		.opcode = { 0xC7, 0xF8 }, .oplen = 2,
	} } },
	{ "xchg", 22, (struct x64LookupActualIns[]) { {
		.args = { AX, R16 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "XCHG AX, r16", .orig_opcode = "90 +rw",
		.desc = "Exchange r16 with AX.",
		.prefixes = 0x66, .opcode = { 0x90 }, .oplen = 1,
	}, {
		.args = { R16, AX }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "XCHG r16, AX", .orig_opcode = "90 +rw",
		.desc = "Exchange AX with r16.",
		.prefixes = 0x66, .opcode = { 0x90 }, .oplen = 1,
	}, {
		.args = { EAX, R32 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "XCHG EAX, r32", .orig_opcode = "90 +rd",
		.desc = "Exchange r32 with EAX.",
		.opcode = { 0x90 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, R64 }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "XCHG RAX, r64", .orig_opcode = "REX.W+ 90 +rd",
		.desc = "Exchange r64 with RAX.",
		.opcode = { 0x90 }, .oplen = 1,
	}, {
		.args = { R32, EAX }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "XCHG r32, EAX", .orig_opcode = "90 +rd",
		.desc = "Exchange EAX with r32.",
		.opcode = { 0x90 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { R64, RAX }, .arglen = 2, .reg_operand = 1,
		.orig_ins = "XCHG r64, RAX", .orig_opcode = "REX.W+ 90 +rd",
		.desc = "Exchange RAX with r64.",
		.opcode = { 0x90 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XCHG r/m8, r8", .orig_opcode = "86 /r",
		.desc = "Exchange r8 (byte register) with byte from r/m8.",
		.opcode = { 0x86 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XCHG r/m8, r8", .orig_opcode = "86 /r",
		.desc = "Exchange r8 (byte register) with byte from r/m8.",
		.opcode = { 0x86 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XCHG r8, r/m8", .orig_opcode = "86 /r",
		.desc = "Exchange byte from r/m8 with r8 (byte register).",
		.opcode = { 0x86 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XCHG r/m8, r8", .orig_opcode = "86 /r",
		.desc = "Exchange r8 (byte register) with byte from r/m8.",
		.opcode = { 0x86 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XCHG r8, r/m8", .orig_opcode = "86 /r",
		.desc = "Exchange byte from r/m8 with r8 (byte register).",
		.opcode = { 0x86 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XCHG r8, r/m8", .orig_opcode = "86 /r",
		.desc = "Exchange byte from r/m8 with r8 (byte register).",
		.opcode = { 0x86 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XCHG r8, r/m8", .orig_opcode = "86 /r",
		.desc = "Exchange byte from r/m8 with r8 (byte register).",
		.opcode = { 0x86 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XCHG r/m16, r16", .orig_opcode = "87 /r",
		.desc = "Exchange r16 with word from r/m16.",
		.prefixes = 0x66, .opcode = { 0x87 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XCHG r16, r/m16", .orig_opcode = "87 /r",
		.desc = "Exchange word from r/m16 with r16.",
		.prefixes = 0x66, .opcode = { 0x87 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XCHG r16, r/m16", .orig_opcode = "87 /r",
		.desc = "Exchange word from r/m16 with r16.",
		.prefixes = 0x66, .opcode = { 0x87 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XCHG r/m32, r32", .orig_opcode = "87 /r",
		.desc = "Exchange r32 with doubleword from r/m32.",
		.opcode = { 0x87 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XCHG r32, r/m32", .orig_opcode = "87 /r",
		.desc = "Exchange doubleword from r/m32 with r32.",
		.opcode = { 0x87 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XCHG r/m64, r64", .orig_opcode = "REX.W+ 87 /r",
		.desc = "Exchange r64 with quadword from r/m64.",
		.opcode = { 0x87 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XCHG r64, r/m64", .orig_opcode = "REX.W+ 87 /r",
		.desc = "Exchange quadword from r/m64 with r64.",
		.opcode = { 0x87 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XCHG r32, r/m32", .orig_opcode = "87 /r",
		.desc = "Exchange doubleword from r/m32 with r32.",
		.opcode = { 0x87 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XCHG r64, r/m64", .orig_opcode = "REX.W+ 87 /r",
		.desc = "Exchange quadword from r/m64 with r64.",
		.opcode = { 0x87 }, .oplen = 1,
	} } },
	{ "xend", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "XEND", .orig_opcode = "0F 01 D5",
		.desc = "Specifies the end of an RTM code region.",
		.opcode = { 0x0F, 0x01, 0xD5 }, .oplen = 3,
	} } },
	{ "xgetbv", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "XGETBV", .orig_opcode = "0F 01 D0",
		.desc = "Reads an XCR specified by ECX into EDX:EAX.",
		.opcode = { 0x0F, 0x01, 0xD0 }, .oplen = 3,
	} } },
	{ "xlat", 1, (struct x64LookupActualIns[]) { {
		.args = { M8 }, .arglen = 1,
		.orig_ins = "XLAT m8", .orig_opcode = "D7",
		.desc = "Set AL to memory byte DS:[(E)BX + unsigned AL].",
		.opcode = { 0xD7 }, .oplen = 1,
	} } },
	{ "xlatb", 1, (struct x64LookupActualIns[]) { {
		.rex = 0x48, 
		.orig_ins = "XLATB", .orig_opcode = "REX.W+ D7",
		.desc = "Set AL to memory byte [RBX + unsigned AL].",
		.opcode = { 0xD7 }, .oplen = 1,
	} } },
	{ "xor", 38, (struct x64LookupActualIns[]) { {
		.args = { AL, IMM8 }, .arglen = 2, .immediate = 2,
		.orig_ins = "XOR AL, imm8", .orig_opcode = "34 ib",
		.desc = "AL XOR imm8.",
		.opcode = { 0x34 }, .oplen = 1,
	}, {
		.args = { AX, IMM16 }, .arglen = 2, .immediate = 2,
		.orig_ins = "XOR AX, imm16", .orig_opcode = "35 iw",
		.desc = "AX XOR imm16.",
		.prefixes = 0x66, .opcode = { 0x35 }, .oplen = 1,
	}, {
		.args = { EAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "XOR EAX, imm32", .orig_opcode = "35 id",
		.desc = "EAX XOR imm32.",
		.opcode = { 0x35 }, .oplen = 1,
	}, {
		.rex = 0x48, 
		.args = { RAX, IMM32 }, .arglen = 2, .immediate = 2,
		.orig_ins = "XOR RAX, imm32", .orig_opcode = "REX.W+ 35 id",
		.desc = "RAX XOR imm32 (sign-extended).",
		.opcode = { 0x35 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m8, imm8", .orig_opcode = "80 /6 ib",
		.desc = "r/m8 XOR imm8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R8, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m8, imm8", .orig_opcode = "80 /6 ib",
		.desc = "r/m8 XOR imm8.",
		.opcode = { 0x80 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m16, imm16", .orig_opcode = "81 /6 iw",
		.desc = "r/m16 XOR imm16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R16, IMM16 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m16, imm16", .orig_opcode = "81 /6 iw",
		.desc = "r/m16 XOR imm16.",
		.prefixes = 0x66, .opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m32, imm32", .orig_opcode = "81 /6 id",
		.desc = "r/m32 XOR imm32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R32, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m32, imm32", .orig_opcode = "81 /6 id",
		.desc = "r/m32 XOR imm32.",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { M64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m64, imm32", .orig_opcode = "REX.W+ 81 /6 id",
		.desc = "r/m64 XOR imm32 (sign-extended).",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { R64, IMM32 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m64, imm32", .orig_opcode = "REX.W+ 81 /6 id",
		.desc = "r/m64 XOR imm32 (sign-extended).",
		.opcode = { 0x81 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m16, imm8", .orig_opcode = "83 /6 ib",
		.desc = "r/m16 XOR imm8 (sign-extended).",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R16, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m16, imm8", .orig_opcode = "83 /6 ib",
		.desc = "r/m16 XOR imm8 (sign-extended).",
		.prefixes = 0x66, .opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m32, imm8", .orig_opcode = "83 /6 ib",
		.desc = "r/m32 XOR imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { R32, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m32, imm8", .orig_opcode = "83 /6 ib",
		.desc = "r/m32 XOR imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { M64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m64, imm8", .orig_opcode = "REX.W+ 83 /6 ib",
		.desc = "r/m64 XOR imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { R64, IMM8 }, .arglen = 2, .immediate = 2, .mem_operand = 1,
		.orig_ins = "XOR r/m64, imm8", .orig_opcode = "REX.W+ 83 /6 ib",
		.desc = "r/m64 XOR imm8 (sign-extended).",
		.opcode = { 0x83 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XOR r/m8, r8", .orig_opcode = "30 /r",
		.desc = "r/m8 XOR r8.",
		.opcode = { 0x30 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XOR r/m8, r8", .orig_opcode = "30 /r",
		.desc = "r/m8 XOR r8.",
		.opcode = { 0x30 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XOR r/m8, r8", .orig_opcode = "30 /r",
		.desc = "r/m8 XOR r8.",
		.opcode = { 0x30 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, RH }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XOR r/m8, r8", .orig_opcode = "30 /r",
		.desc = "r/m8 XOR r8.",
		.opcode = { 0x30 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XOR r/m16, r16", .orig_opcode = "31 /r",
		.desc = "r/m16 XOR r16.",
		.prefixes = 0x66, .opcode = { 0x31 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XOR r/m16, r16", .orig_opcode = "31 /r",
		.desc = "r/m16 XOR r16.",
		.prefixes = 0x66, .opcode = { 0x31 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { M32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XOR r/m32, r32", .orig_opcode = "31 /r",
		.desc = "r/m32 XOR r32.",
		.opcode = { 0x31 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XOR r/m32, r32", .orig_opcode = "31 /r",
		.desc = "r/m32 XOR r32.",
		.opcode = { 0x31 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { M64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XOR r/m64, r64", .orig_opcode = "REX.W+ 31 /r",
		.desc = "r/m64 XOR r64.",
		.opcode = { 0x31 }, .oplen = 1,
		.preffered = true,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 1, .reg_operand = 2,
		.orig_ins = "XOR r/m64, r64", .orig_opcode = "REX.W+ 31 /r",
		.desc = "r/m64 XOR r64.",
		.opcode = { 0x31 }, .oplen = 1,
		.preffered = true,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XOR r8, r/m8", .orig_opcode = "32 /r",
		.desc = "r8 XOR r/m8.",
		.opcode = { 0x32 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R8, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XOR r8, r/m8", .orig_opcode = "32 /r",
		.desc = "r8 XOR r/m8.",
		.opcode = { 0x32 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, M8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XOR r8, r/m8", .orig_opcode = "32 /r",
		.desc = "r8 XOR r/m8.",
		.opcode = { 0x32 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { RH, R8 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XOR r8, r/m8", .orig_opcode = "32 /r",
		.desc = "r8 XOR r/m8.",
		.opcode = { 0x32 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, M16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XOR r16, r/m16", .orig_opcode = "33 /r",
		.desc = "r16 XOR r/m16.",
		.prefixes = 0x66, .opcode = { 0x33 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R16, R16 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XOR r16, r/m16", .orig_opcode = "33 /r",
		.desc = "r16 XOR r/m16.",
		.prefixes = 0x66, .opcode = { 0x33 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, M32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XOR r32, r/m32", .orig_opcode = "33 /r",
		.desc = "r32 XOR r/m32.",
		.opcode = { 0x33 }, .oplen = 1,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { R32, R32 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XOR r32, r/m32", .orig_opcode = "33 /r",
		.desc = "r32 XOR r/m32.",
		.opcode = { 0x33 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, M64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XOR r64, r/m64", .orig_opcode = "REX.W+ 33 /r",
		.desc = "r64 XOR r/m64.",
		.opcode = { 0x33 }, .oplen = 1,
	}, {
		.rex = 0x48, .modrmreq = true, .modrmreg = true, 
		.args = { R64, R64 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XOR r64, r/m64", .orig_opcode = "REX.W+ 33 /r",
		.desc = "r64 XOR r/m64.",
		.opcode = { 0x33 }, .oplen = 1,
	} } },
	{ "xorpd", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XORPD xmm1, xmm2/m128", .orig_opcode = "66 0F 57 /r",
		.desc = "Bitwise exclusive-OR of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x57 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XORPD xmm1, xmm2/m128", .orig_opcode = "66 0F 57 /r",
		.desc = "Bitwise exclusive-OR of xmm2/m128 and xmm1.",
		.prefixes = 0x66, .opcode = { 0x0F, 0x57 }, .oplen = 2,
	} } },
	{ "xorps", 2, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, M128 }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XORPS xmm1, xmm2/m128", .orig_opcode = "0F 57 /r",
		.desc = "Bitwise exclusive-OR of xmm2/m128 and xmm1.",
		.opcode = { 0x0F, 0x57 }, .oplen = 2,
	}, {
		.modrmreq = true, .modrmreg = true, 
		.args = { XMM, XMM }, .arglen = 2, .mem_operand = 2, .reg_operand = 1,
		.orig_ins = "XORPS xmm1, xmm2/m128", .orig_opcode = "0F 57 /r",
		.desc = "Bitwise exclusive-OR of xmm2/m128 and xmm1.",
		.opcode = { 0x0F, 0x57 }, .oplen = 2,
	} } },
	{ "xrstor", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XRSTOR mem", .orig_opcode = "0F AE /5",
		.desc = "Restore processor extended states from memory. The states are specified by EDX:EAX",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XRSTOR mem", .orig_opcode = "0F AE /5",
		.desc = "Restore processor extended states from memory. The states are specified by EDX:EAX",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x28, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XRSTOR mem", .orig_opcode = "0F AE /5",
		.desc = "Restore processor extended states from memory. The states are specified by EDX:EAX",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "xrstor64", 3, (struct x64LookupActualIns[]) { {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XRSTOR64 mem", .orig_opcode = "REX.W+ 0F AE /5",
		.desc = "Restore processor extended states from memory. The states are specified by EDX:EAX",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XRSTOR64 mem", .orig_opcode = "REX.W+ 0F AE /5",
		.desc = "Restore processor extended states from memory. The states are specified by EDX:EAX",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x28, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XRSTOR64 mem", .orig_opcode = "REX.W+ 0F AE /5",
		.desc = "Restore processor extended states from memory. The states are specified by EDX:EAX",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "xsave", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVE mem", .orig_opcode = "0F AE /4",
		.desc = "Save processor extended states to memory. The states are specified by EDX:EAX",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVE mem", .orig_opcode = "0F AE /4",
		.desc = "Save processor extended states to memory. The states are specified by EDX:EAX",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x20, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVE mem", .orig_opcode = "0F AE /4",
		.desc = "Save processor extended states to memory. The states are specified by EDX:EAX",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "xsave64", 3, (struct x64LookupActualIns[]) { {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVE64 mem", .orig_opcode = "REX.W+ 0F AE /4",
		.desc = "Save processor extended states to memory. The states are specified by EDX:EAX",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVE64 mem", .orig_opcode = "REX.W+ 0F AE /4",
		.desc = "Save processor extended states to memory. The states are specified by EDX:EAX",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x20, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVE64 mem", .orig_opcode = "REX.W+ 0F AE /4",
		.desc = "Save processor extended states to memory. The states are specified by EDX:EAX",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "xsaveopt", 3, (struct x64LookupActualIns[]) { {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVEOPT mem", .orig_opcode = "0F AE /6",
		.desc = "Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVEOPT mem", .orig_opcode = "0F AE /6",
		.desc = "Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.modrmreq = true, .modrm = 0x30, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVEOPT mem", .orig_opcode = "0F AE /6",
		.desc = "Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "xsaveopt64", 3, (struct x64LookupActualIns[]) { {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { M32 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVEOPT64 mem", .orig_opcode = "REX.W+ 0F AE /6",
		.desc = "Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { M16 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVEOPT64 mem", .orig_opcode = "REX.W+ 0F AE /6",
		.desc = "Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible.",
		.prefixes = 0x66, .opcode = { 0x0F, 0xAE }, .oplen = 2,
	}, {
		.rex = 0x48, .modrmreq = true, .modrm = 0x30, 
		.args = { M64 }, .arglen = 1, .mem_operand = 1,
		.orig_ins = "XSAVEOPT64 mem", .orig_opcode = "REX.W+ 0F AE /6",
		.desc = "Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible.",
		.opcode = { 0x0F, 0xAE }, .oplen = 2,
	} } },
	{ "xsetbv", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "XSETBV", .orig_opcode = "0F 01 D1",
		.desc = "Write the value in EDX:EAX to the XCR specified by ECX.",
		.opcode = { 0x0F, 0x01, 0xD1 }, .oplen = 3,
	} } },
	{ "xtest", 1, (struct x64LookupActualIns[]) { {
		.orig_ins = "XTEST", .orig_opcode = "0F 01 D6",
		.desc = "Test if executing in a transactional region",
		.opcode = { 0x0F, 0x01, 0xD6 }, .oplen = 3,
	} } }
};

#define imm(value) (x64Operand) { ((value) == 1 ? ONE : 0) | IMM8 | IMM16 | IMM32 | IMM64, (value) }
// #define imm(value) (x64Operand) { ((value) == 1 ? ONE : 0) | (value < 0x100 && IMM8) | (value < 0x10000 && IMM16) | (value < 0x100000000 && IMM32) | IMM64, (value) }
#define im64(value) (x64Operand) { ((value) == 1 ? ONE : 0) | IMM64, (value) }
#define im32(value) (x64Operand) { ((value) == 1 ? ONE : 0) | IMM32, (value) }
#define im16(value) (x64Operand) { ((value) == 1 ? ONE : 0) | IMM16, (value) }
#define im8(value) (x64Operand) { ((value) == 1 ? ONE : 0) | IMM8, (value) }

#define rh (x64Operand) { RH | R8 }
#define al (x64Operand) { AL | R8 }
#define cl (x64Operand) { CL | R8, 1 }
#define dl (x64Operand) { R8, 2 }
#define bl (x64Operand) { R8, 3 }
#define ah (x64Operand) { RH, 4 }
#define ch (x64Operand) { RH, 5 }
#define dh (x64Operand) { RH, 6 }
#define bh (x64Operand) { RH, 7 }

#define sil (x64Operand) { R8, 4 }
#define dil (x64Operand) { R8, 5 }
#define bpl (x64Operand) { R8, 6 }
#define spl (x64Operand) { R8, 7 }
#define r8b (x64Operand) { R8, 8 }
#define r9b (x64Operand) { R8, 9 }
#define r10b (x64Operand) { R8, 10 }
#define r11b (x64Operand) { R8, 11 }
#define r12b (x64Operand) { R8, 12 }
#define r13b (x64Operand) { R8, 13 }
#define r14b (x64Operand) { R8, 14 }
#define r15b (x64Operand) { R8, 15 }


#define ax (x64Operand) { AX | R16 }
#define cx (x64Operand) { R16, 1 }
#define dx (x64Operand) { DX | R16, 2 }
#define bx (x64Operand) { R16, 3 }

#define si (x64Operand) { R16, 4 }
#define di (x64Operand) { R16, 5 }
#define bp (x64Operand) { R16, 6 }
#define sp (x64Operand) { R16, 7 }
#define r8w (x64Operand) { R16, 8 }
#define r9w (x64Operand) { R16, 9 }
#define r10w (x64Operand) { R16, 10 }
#define r11w (x64Operand) { R16, 11 }
#define r12w (x64Operand) { R16, 12 }
#define r13w (x64Operand) { R16, 13 }
#define r14w (x64Operand) { R16, 14 }
#define r15w (x64Operand) { R16, 15 }

enum x64RegisterReference {
	$eax, $ecx, $edx, $ebx, $esp, $ebp, $esi, $edi, $r8d, $r9d, $r10d, $r11d, $r12d,
	$r13d, $r14d, $r15d, $rax, $rcx, $rdx, $rbx, $rsp, $rbp, $rsi, $rdi, $r8, $r9, $r10,
	$r11, $r12, $r13, $r14, $r15, $rip, $es, $cs, $ss, $ds, $fs, $gs, $riprel = 0x30, $none = 0xfff0
};

#define eax (x64Operand) { EAX | R32, $eax }
#define ecx (x64Operand) { R32, $ecx }
#define edx (x64Operand) { R32, $edx }
#define ebx (x64Operand) { R32, $ebx }
#define esp (x64Operand) { R32, $esp }
#define ebp (x64Operand) { R32, $ebp }
#define esi (x64Operand) { R32, $esi }
#define edi (x64Operand) { R32, $edi }
#define r8d (x64Operand) { R32, $r8d }
#define r9d (x64Operand) { R32, $r9d }
#define r10d (x64Operand) { R32, $r10d }
#define r11d (x64Operand) { R32, $r11d }
#define r12d (x64Operand) { R32, $r12d }
#define r13d (x64Operand) { R32, $r13d }
#define r14d (x64Operand) { R32, $r14d }
#define r15d (x64Operand) { R32, $r15d }

#define rax (x64Operand) { RAX | R64, 0x0 }
#define rcx (x64Operand) { R64, 0x1 }
#define rdx (x64Operand) { R64, 0x2 }
#define rbx (x64Operand) { R64, 0x3 }
#define rsp (x64Operand) { R64, 0x4 }
#define rbp (x64Operand) { R64, 0x5 }
#define rsi (x64Operand) { R64, 0x6 }
#define rdi (x64Operand) { R64, 0x7 }
#define r8 (x64Operand) { R64, 0x8 }
#define r9 (x64Operand) { R64, 0x9 }
#define r10 (x64Operand) { R64, 0xA }
#define r11 (x64Operand) { R64, 0xB }
#define r12 (x64Operand) { R64, 0xC }
#define r13 (x64Operand) { R64, 0xD }
#define r14 (x64Operand) { R64, 0xE }
#define r15 (x64Operand) { R64, 0xF }

// SSE and AVX registers
#define xmm0 (x64Operand) { XMM_0 | XMM, 0 }
#define xmm1 (x64Operand) { XMM, 1 }
#define xmm2 (x64Operand) { XMM, 2 }
#define xmm3 (x64Operand) { XMM, 3 }
#define xmm4 (x64Operand) { XMM, 4 }
#define xmm5 (x64Operand) { XMM, 5 }
#define xmm6 (x64Operand) { XMM, 6 }
#define xmm7 (x64Operand) { XMM, 7 }
#define xmm8 (x64Operand) { XMM, 8 }
#define xmm9 (x64Operand) { XMM, 9 }
#define xmm10 (x64Operand) { XMM, 10 }
#define xmm11 (x64Operand) { XMM, 11 }
#define xmm12 (x64Operand) { XMM, 12 }
#define xmm13 (x64Operand) { XMM, 13 }
#define xmm14 (x64Operand) { XMM, 14 }
#define xmm15 (x64Operand) { XMM, 15 }
#define xmm16 (x64Operand) { XMM, 16 }
#define xmm17 (x64Operand) { XMM, 17 }
#define xmm18 (x64Operand) { XMM, 18 }
#define xmm19 (x64Operand) { XMM, 19 }
#define xmm20 (x64Operand) { XMM, 20 }
#define xmm21 (x64Operand) { XMM, 21 }
#define xmm22 (x64Operand) { XMM, 22 }
#define xmm23 (x64Operand) { XMM, 23 }
#define xmm24 (x64Operand) { XMM, 24 }
#define xmm25 (x64Operand) { XMM, 25 }
#define xmm26 (x64Operand) { XMM, 26 }
#define xmm27 (x64Operand) { XMM, 27 }
#define xmm28 (x64Operand) { XMM, 28 }
#define xmm29 (x64Operand) { XMM, 29 }
#define xmm30 (x64Operand) { XMM, 30 }
#define xmm31 (x64Operand) { XMM, 31 }

#define ymm0 (x64Operand) { YMM, 0 }
#define ymm1 (x64Operand) { YMM, 1 }
#define ymm2 (x64Operand) { YMM, 2 }
#define ymm3 (x64Operand) { YMM, 3 }
#define ymm4 (x64Operand) { YMM, 4 }
#define ymm5 (x64Operand) { YMM, 5 }
#define ymm6 (x64Operand) { YMM, 6 }
#define ymm7 (x64Operand) { YMM, 7 }
#define ymm8 (x64Operand) { YMM, 8 }
#define ymm9 (x64Operand) { YMM, 9 }
#define ymm10 (x64Operand) { YMM, 10 }
#define ymm11 (x64Operand) { YMM, 11 }
#define ymm12 (x64Operand) { YMM, 12 }
#define ymm13 (x64Operand) { YMM, 13 }
#define ymm14 (x64Operand) { YMM, 14 }
#define ymm15 (x64Operand) { YMM, 15 }
#define ymm16 (x64Operand) { YMM, 16 }
#define ymm17 (x64Operand) { YMM, 17 }
#define ymm18 (x64Operand) { YMM, 18 }
#define ymm19 (x64Operand) { YMM, 19 }
#define ymm20 (x64Operand) { YMM, 20 }
#define ymm21 (x64Operand) { YMM, 21 }
#define ymm22 (x64Operand) { YMM, 22 }
#define ymm23 (x64Operand) { YMM, 23 }
#define ymm24 (x64Operand) { YMM, 24 }
#define ymm25 (x64Operand) { YMM, 25 }
#define ymm26 (x64Operand) { YMM, 26 }
#define ymm27 (x64Operand) { YMM, 27 }
#define ymm28 (x64Operand) { YMM, 28 }
#define ymm29 (x64Operand) { YMM, 29 }
#define ymm30 (x64Operand) { YMM, 30 }
#define ymm31 (x64Operand) { YMM, 31 }

#define zmm0 (x64Operand) { ZMM, 0 }
#define zmm1 (x64Operand) { ZMM, 1 }
#define zmm2 (x64Operand) { ZMM, 2 }
#define zmm3 (x64Operand) { ZMM, 3 }
#define zmm4 (x64Operand) { ZMM, 4 }
#define zmm5 (x64Operand) { ZMM, 5 }
#define zmm6 (x64Operand) { ZMM, 6 }
#define zmm7 (x64Operand) { ZMM, 7 }
#define zmm8 (x64Operand) { ZMM, 8 }
#define zmm9 (x64Operand) { ZMM, 9 }
#define zmm10 (x64Operand) { ZMM, 10 }
#define zmm11 (x64Operand) { ZMM, 11 }
#define zmm12 (x64Operand) { ZMM, 12 }
#define zmm13 (x64Operand) { ZMM, 13 }
#define zmm14 (x64Operand) { ZMM, 14 }
#define zmm15 (x64Operand) { ZMM, 15 }
#define zmm16 (x64Operand) { ZMM, 16 }
#define zmm17 (x64Operand) { ZMM, 17 }
#define zmm18 (x64Operand) { ZMM, 18 }
#define zmm19 (x64Operand) { ZMM, 19 }
#define zmm20 (x64Operand) { ZMM, 20 }
#define zmm21 (x64Operand) { ZMM, 21 }
#define zmm22 (x64Operand) { ZMM, 22 }
#define zmm23 (x64Operand) { ZMM, 23 }
#define zmm24 (x64Operand) { ZMM, 24 }
#define zmm25 (x64Operand) { ZMM, 25 }
#define zmm26 (x64Operand) { ZMM, 26 }
#define zmm27 (x64Operand) { ZMM, 27 }
#define zmm28 (x64Operand) { ZMM, 28 }
#define zmm29 (x64Operand) { ZMM, 29 }
#define zmm30 (x64Operand) { ZMM, 30 }
#define zmm31 (x64Operand) { ZMM, 31 }



// mm registers
#define mm0 (x64Operand) { MM, 0 }
#define mm1 (x64Operand) { MM, 1 }
#define mm2 (x64Operand) { MM, 2 }
#define mm3 (x64Operand) { MM, 3 }
#define mm4 (x64Operand) { MM, 4 }
#define mm5 (x64Operand) { MM, 5 }
#define mm6 (x64Operand) { MM, 6 }
#define mm7 (x64Operand) { MM, 7 }

// control registers
#define cr0 (x64Operand) { CR0_7, 0 }
#define cr1 (x64Operand) { CR0_7, 1 }
#define cr2 (x64Operand) { CR0_7, 2 }
#define cr3 (x64Operand) { CR0_7, 3 }
#define cr4 (x64Operand) { CR0_7, 4 }
#define cr5 (x64Operand) { CR0_7, 5 }
#define cr6 (x64Operand) { CR0_7, 6 }
#define cr7 (x64Operand) { CR0_7, 7 }
#define cr8 (x64Operand) { CR8, 8 }

// debug registers
#define dr0 (x64Operand) { DREG, 0 }
#define dr1 (x64Operand) { DREG, 1 }
#define dr2 (x64Operand) { DREG, 2 }
#define dr3 (x64Operand) { DREG, 3 }
#define dr4 (x64Operand) { DREG, 4 }
#define dr5 (x64Operand) { DREG, 5 }
#define dr6 (x64Operand) { DREG, 6 }
#define dr7 (x64Operand) { DREG, 7 }

// FPU registers
#define st0 (x64Operand) { ST_0 | ST, 0 }
#define st1 (x64Operand) { ST, 1 }
#define st2 (x64Operand) { ST, 2 }
#define st3 (x64Operand) { ST, 3 }
#define st4 (x64Operand) { ST, 4 }
#define st5 (x64Operand) { ST, 5 }
#define st6 (x64Operand) { ST, 6 }
#define st7 (x64Operand) { ST, 7 }


// segment registers
#define es (x64Operand) { SREG, 1 }
#define cs (x64Operand) { SREG, 2 }
#define ss (x64Operand) { SREG, 3 }
#define ds (x64Operand) { SREG, 4 }
#define fs (x64Operand) { FS | SREG, 5 }
#define gs (x64Operand) { GS | SREG, 6 }

// #define lb(l) (x64Operand) { LABEL, #l }

#define rel(insns) (x64Operand) { insns > 8 || insns < -8 ? REL32 : REL8, insns }
#define riprel(insns) (x64Operand) 

// DISP    : 0x00000000ffffffff bit 0-31
// BASE    : 0x0000001f00000000 bit 32-36
// INDEX   : 0x00001f0000000000 bit 40-44
// SCALE   : 0x0003000000000000 bit 48-49
// SEG     : 0x0700000000000000 bit 56-58
// ADDR_OR : 0x1000000000000000 bit 60
// RIP     : 0x2000000000000000 bit 61
// RIPREL  : 0x4000000000000000 bit 62

//hi = (disp, base) => (disp & 0xffffffffn | ((base) & 0x30n ? ( (BigInt((base) == 0x20n) && (1n << 61n)) | (BigInt((base) == 0xfff0n) && (0x1n << 36n)) | BigInt((base & 0xfn) << 32n) ) : (0x1n << 60n) | ((base) & 0xfn) << 32n))


#define X64MEM_1_ARGS(base)                      (((base) & 0x30 ?\
																										( ((uint64_t) ((base) == 0x20) ? ((uint64_t) 0x1 << 61) : 0) | ((uint64_t) ((base) == 0x30) ? ((uint64_t) 0x3 << 61) : 0) | ((uint64_t) ((base) == 0xfff0) ? ((uint64_t) 0x1 << 36) : 0) | ((uint64_t) ((base) & 0xf) << 32) ) :\
																										((uint64_t) 0x1 << 60) | (uint64_t) ((base) & 0xf) << 32) |\
																									(uint64_t) 0x10 << 40)
#define X64MEM_2_ARGS(base, disp)                     (disp & 0xffffffff | X64MEM_1_ARGS(base))
#define X64MEM_3_ARGS(base, disp, index)        (disp & 0xffffffff | ((base) & 0x30 ?\
																										( ((uint64_t) ((base) == 0x20) ? ((uint64_t) 0x1 << 61) : 0) | ((uint64_t) ((base) == 0x30) ? ((uint64_t) 0x3 << 61) : 0) | ((uint64_t) ((base) == 0xfff0) ? ((uint64_t) 0x1 << 36) : 0) | ((uint64_t) ((base) & 0xf) << 32) ) :\
																										((uint64_t) 0x1 << 60) | (uint64_t) ((base) & 0xf) << 32) |\
																									(uint64_t) ((index) == 0xfff0 ? 0x10 : (index) & 0xf) << 40)
#define X64MEM_4_ARGS(base, disp, index, scale) (X64MEM_3_ARGS(base, disp, index) | (uint64_t) ((scale) <= 1 ? 0b00 : (scale) == 2 ? 0b01 : (scale) == 4 ? 0b10 : 0b11) << 48)
#define X64MEM_5_ARGS(base, disp, index, scale, segment) (disp & 0xffffffff\
	| ((base) & 0x30 ? /*If the operand is more than 32 bits wide or is equal to the RIP register, set mode to wide addressing and set base register, or RIP addressing*/\
			( ((uint64_t) ((base) == 0x20) ? ((uint64_t) 0x1 << 61) : 0) | ((uint64_t) ((base) == 0x30) ? ((uint64_t) 0x3 << 61) : 0) | ((uint64_t) ((base) == 0xfff0) ? ((uint64_t) 0x1 << 36) : 0) | ((uint64_t) ((base) & 0xf) << 32) ) :\
			((uint64_t) 0x1 << 60) | (uint64_t) ((base) & 0xf) << 32)\
	| (uint64_t) ((index) == 0xfff0 ? 0x10 : (index) & 0xf) << 40\
	| (uint64_t) ((scale) <= 1 ? 0b00 : (scale) == 2 ? 0b01 : (scale) == 4 ? 0b10 : 0b11) << 48\
	| (uint64_t) (((segment) - $rip) & (uint64_t) 0x7) << 56) /* minusing from $rip, because segment registers are 1 + their value for simplification. */

#define GET_4TH_ARG(arg1, arg2, arg3, arg4, arg5, arg6, ...) arg6
#define X64MEM_MACRO_CHOOSER(...) \
    GET_4TH_ARG(__VA_ARGS__, X64MEM_5_ARGS, X64MEM_4_ARGS, X64MEM_3_ARGS, \
                X64MEM_2_ARGS, X64MEM_1_ARGS, )

#define x64mem(...) X64MEM_MACRO_CHOOSER(__VA_ARGS__)(__VA_ARGS__)
#define m8(...) (x64Operand) { M8, x64mem(__VA_ARGS__) }
#define m16(...) (x64Operand) { M16, x64mem(__VA_ARGS__) }
#define m32(...) (x64Operand) { M32, x64mem(__VA_ARGS__) }
#define m64(...) (x64Operand) { M64, x64mem(__VA_ARGS__) }
#define m128(...) (x64Operand) { M128, x64mem(__VA_ARGS__) }
#define m256(...) (x64Operand) { M256, x64mem(__VA_ARGS__) }
#define m512(...) (x64Operand) { M512, x64mem(__VA_ARGS__) }
#define mem(...) (x64Operand) { M8 | M16 | M32 | M64 | M128 | M256 | M512, x64mem(__VA_ARGS__) }

#define END RET, {0}, ((x64Ins) {0, {0}})

uint64_t label(char* name);
uint32_t x64emit(x64Ins* ins, char* opcode_dest);
char* x64as(uint32_t num, x64 p, uint32_t* len);
char* x64stringify(x64 p);
void (*run(void* mem, uint32_t size))();
